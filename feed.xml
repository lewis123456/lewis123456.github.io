<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longman</title>
  <icon>https://www.gravatar.com/avatar/b7e2ba3f68bd206134b3d41535be01b0</icon>
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://longman.kim/"/>
  <updated>2018-11-11T14:32:31.587Z</updated>
  <id>http://longman.kim/</id>
  
  <author>
    <name>lewis longman</name>
    <email>2328811532@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关键字static, final, throws, try-catch-throw-finally</title>
    <link href="http://longman.kim/2018/11/11/%E5%85%B3%E9%94%AE%E5%AD%97static-final-throws-try-catch-throw-finally/"/>
    <id>http://longman.kim/2018/11/11/关键字static-final-throws-try-catch-throw-finally/</id>
    <published>2018-11-11T04:33:21.000Z</published>
    <updated>2018-11-11T14:32:31.587Z</updated>
    
    <content type="html"><![CDATA[<center><br><img src="/img/suo_long.jpg" width="100%"><br></center><p>static用来修饰静态属性、静态方法、静态内部类。对于static修饰的静态属性，该类的所有对象都共享一个。对于static修饰的方法，只能修改静态属性，不能修改私有属性。对于静态内部类，在创建静态内部类时，不需要外部类的对象，并且静态内部类的对象只能访问外部类的静态成员。  </p><p>final修饰不可变的类、成员变量、本地变量、方法。final修饰的类不能被继承，final修饰的本地变量必须在声明时初始化。final修饰的成员变量必须在声明的时候初始化或者在构造器中初始化，否则编译报错。final修饰的方法不能被重写，在编译阶段绑定（静态绑定）。final变量不能再次赋值，只能初始化。接口中声明的所有变量本身是final的。在匿名类中所有变量都必须是final变量。</p><p>throws使用在方法名后，将函数内部的异常向上抛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;/img/suo_long.jpg&quot; width=&quot;100%&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;static用来修饰静态属性、静态方法、静态内部类。对于static修饰的静态属性，该类的所有对象都共享一个。对于static修饰的方法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>private, protected, public</title>
    <link href="http://longman.kim/2018/11/11/private-protected-public/"/>
    <id>http://longman.kim/2018/11/11/private-protected-public/</id>
    <published>2018-11-11T03:54:58.000Z</published>
    <updated>2018-11-11T06:07:52.226Z</updated>
    
    <content type="html"><![CDATA[<center><br><img src="/img/you.jpg" width="100%"><br></center><p>private, default(没加修饰符为friendly), protected, public 都是用来做访问权限控制，权限由小到大，如下表，构成一个<strong>三角型</strong>。其中主要关注default和protected修饰的属性或方法，在本包内能够访问，并且protected修饰的能够在子类访问。</p><table><thead><tr><th style="text-align:left">权限关键字</th><th style="text-align:left">类内部</th><th style="text-align:left">本包</th><th style="text-align:left">子类</th><th style="text-align:left">外部包</th></tr></thead><tbody><tr><td style="text-align:left">private</td><td style="text-align:left">Y</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">default</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">protected</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td></tr></tbody></table><p>类似于这种需要死记硬背的东西，我们可以稍微找出一种规律，那就是<strong>三角型</strong>，即每种情况都要有，所以权限数量依次为1,2,3,4。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;/img/you.jpg&quot; width=&quot;100%&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;private, default(没加修饰符为friendly), protected, public 都是用来做访问权限控制，权限由小到大，如下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员的青春饭</title>
    <link href="http://longman.kim/2018/11/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%9D%92%E6%98%A5%E9%A5%AD/"/>
    <id>http://longman.kim/2018/11/10/程序员的青春饭/</id>
    <published>2018-11-10T13:33:47.000Z</published>
    <updated>2018-11-11T02:40:04.125Z</updated>
    
    <content type="html"><![CDATA[<center><br><img src="/img/lcf.jpg" width="100%"><br></center><p>为什么有程序员吃青春饭这一说法？不知从什么时候开始，程序员是吃青春饭的这种说法开始流行。到底这种说法是对是错呢，有什么依据，我们得知这种说法时，是否认同。我们首先做一个调查，以阿里巴巴不同职级要求为例（2018年情况）。  </p><table><thead><tr><th style="text-align:left">职级</th><th style="text-align:left">条件</th><th style="text-align:left">年薪</th><th style="text-align:left">期权</th><th style="text-align:left">年龄</th></tr></thead><tbody><tr><td style="text-align:left">P5</td><td style="text-align:left">研发（硕士应届生）</td><td style="text-align:left">20k*(12+4.5)=33w</td><td style="text-align:left">无</td><td style="text-align:left">25</td></tr><tr><td style="text-align:left">P6</td><td style="text-align:left">高级研发（2年后5升6）</td><td style="text-align:left">28k*16.5=46w</td><td style="text-align:left">无</td><td style="text-align:left">27</td></tr><tr><td style="text-align:left">P7</td><td style="text-align:left">专家（2年后6升7）</td><td style="text-align:left">45k*16.5=74w(加期权100w)</td><td style="text-align:left">期权</td><td style="text-align:left">29</td></tr><tr><td style="text-align:left">P8</td><td style="text-align:left">高级专家（3年后7升8）</td><td style="text-align:left">60*16.5=99w(加期权160w出头)</td><td style="text-align:left">期权</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">P9</td><td style="text-align:left">资深专家（看组织）</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">P10</td><td style="text-align:left">研究员</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">P11</td><td style="text-align:left">高级研究员</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">P12</td><td style="text-align:left">科学家</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">P13</td><td style="text-align:left">高级科学家</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">？</td></tr></tbody></table><p>P6和P7是阿里的骨干，P8是业务的小队长。普通人靠个人能力能到达P8，如果再前进一步需要看情商了，以及公司给机会了，升到P9基本可认为财务自由。从上面这个表中，我们可以看到，32岁，或者35岁基本是在中国做一个单纯程序员的终结点。2017年网上统计BAT员工的平均年龄分别是23，26，23，看下国外FLAG员工的平均年龄分别是28，29，31，30岁。那过了35岁之后该怎么走，我想大多数人去了其他中小型公司做技术总监、经理、CTO。还有一部分人创业，或者转行。这是现实，残酷而真实。既然存在这个问题，我们普通程序员有何应对之策？  </p><ul><li>不断提高技术水平，尽早进入BAT，在BAT工作至少3年，职级达到P7,P8级别  </li><li>喜欢技术，想一直写程序到老，在BAT待着  </li><li>跳槽至中小型公司成为总监、经理、CTO，从事管理   </li><li>创业/转行  </li></ul><p>世界很真实，我们很迷茫。未来的路很多，但我们只能走一次。遵从自己的心，永不后悔。每个人，都只有一个人生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;/img/lcf.jpg&quot; width=&quot;100%&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;为什么有程序员吃青春饭这一说法？不知从什么时候开始，程序员是吃青春饭的这种说法开始流行。到底这种说法是对是错呢，有什么依据，我们得知这种说法时，是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文章分类</title>
    <link href="http://longman.kim/2018/11/10/%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"/>
    <id>http://longman.kim/2018/11/10/文章分类/</id>
    <published>2018-11-10T06:58:18.000Z</published>
    <updated>2018-11-11T06:13:45.183Z</updated>
    
    <content type="html"><![CDATA[<center><br><img src="/img/zqxj.jpg" width="100%"><br></center><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li>private, protected, public</li><li>关键字static, final, throws, try-catch-throw-finally</li><li>String对象与常量池，StringBuilder, StringBuffer</li><li>枚举类Enum的底层实现</li><li>JVM运行时内存分配</li><li>Java内存模型</li><li>GC垃圾回收的方法与原理</li><li>双亲委派机制</li><li>加载一个类的流程</li><li>单例实现的5种方法</li><li>接口List, Set, Map分析</li><li>Vector, ArrayList, LinkedList源码分析</li><li>HashTable, HashMap, CurrentHashMap实现演变与源码分析</li><li>TreeMap</li><li>CopyOnWrite机制，</li><li>ThreadLocal分析</li><li>线程生命周期</li><li>wait()和sleep()</li><li>Java自带线程池ThreadPoolExecutor分析</li><li>Java中的锁（偏向锁，自旋锁，轻量锁）</li><li>乐观锁，悲观锁，可重入锁</li><li>Java的syncronized, Lock, ReentrantLock, ReadWriteLock</li><li>同步机制volatile, CountDownLatch, Conditon, CycliBarrier, Semaphore</li><li>AQS, CAS, ArraryBlockingQueue, Unsafe, Locksupport </li><li>Java8的lambda表达式</li><li>Stream</li><li>IOStream输入输出流</li><li>网络编程Socket</li><li>动态代理Proxy, CGLIB, ASM</li><li>反射的作用与原理</li><li>序列化与反序列化</li><li>强引用，软引用，弱引用，虚引用</li><li>hashcode, equals的重载</li><li>泛型编程</li><li>Java NIO:Selector, Channal, Buffer</li></ul><h3 id="Spring系列"><a href="#Spring系列" class="headerlink" title="Spring系列"></a>Spring系列</h3><ul><li>SpringMVC</li><li>SpringBoot</li><li>SprintCloud</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul><li>Redis</li><li>Memcache</li><li>Guava Cache</li><li>MySQL</li><li>HBase</li><li>TiDB</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>HTTP协议</li><li>HTTPS协议</li><li>TCP/IP协议</li><li>JSON</li><li>WebService</li><li>域名解析</li><li>NAT</li><li>LVS</li><li>VIP</li><li>Nginx</li><li>OpenResty</li><li>Push, Pull, LongPoll</li><li>Netty</li><li>Servlet</li><li>Tomcat</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>进程、线程、协程</li><li>用户态与内核态</li><li>内存分配与回收</li></ul><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul><li>dubbo</li><li>gRPC</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>MyBatis</li><li>RabbitMQ</li><li>RocketMQ</li><li>ZeroMQ</li><li>Kafka</li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ul><li>ServiceMesh</li><li>Docker</li><li>K8s</li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul><li>ACID</li><li>CAP</li><li>BASE</li><li>XA协议</li><li>两阶段提交</li><li>三阶段提交</li><li>PAXOS</li><li>RAFT</li><li>ZAB</li><li>Zookeeper</li></ul><h3 id="Linux系列"><a href="#Linux系列" class="headerlink" title="Linux系列"></a>Linux系列</h3><ul><li>文件操作</li><li>网络操作</li><li>sed</li><li>awk</li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><ul><li>协程</li></ul><h3 id="大数据系列"><a href="#大数据系列" class="headerlink" title="大数据系列"></a>大数据系列</h3><ul><li>ELK</li><li>MapReduce</li><li>BigTable</li><li>HBase</li><li>HIVE</li><li>Elasticsearch</li><li>Lucense</li></ul><h3 id="机器学习系统"><a href="#机器学习系统" class="headerlink" title="机器学习系统"></a>机器学习系统</h3><ul><li>有监督和无监督学习</li><li>决策树</li><li>K均值算法</li><li>K近邻算法</li><li>线性回归</li><li>SVM</li><li>梯度下降</li><li>神经网络</li><li>深度学习</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>数组</li><li>链表</li><li>栈</li><li>堆</li><li>队列</li><li>哈希表</li><li>二叉树</li><li>二叉搜索树</li><li>平衡二叉树</li><li>红黑树</li><li>B树，B-树，B+树</li><li>图</li><li>深度优先遍历</li><li>广度优先遍历</li><li>跳跃表</li><li>线段树</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>贪心</li><li>迭代与递归</li><li>动态规划DP</li></ul><h3 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h3><ul><li>ROS机器人操作系统</li><li>百度Apollo</li><li>谷歌AlphaGo</li><li>波士顿动力</li><li>运动控制</li><li>路劲规划之全局规划A*</li><li>路径规范之局部规范DWA</li><li>定位ACL</li><li>SLAM之Gmapping</li><li>视觉导航</li><li>马尔科夫决策链</li><li>状态机</li><li>卡尔曼滤波</li><li>粒子滤波</li><li>follow me</li><li>抓取</li></ul><h3 id="设计系列"><a href="#设计系列" class="headerlink" title="设计系列"></a>设计系列</h3><ul><li>photoshop</li><li>illustrator</li><li>after effect</li><li>skatch</li></ul><h3 id="前端系列"><a href="#前端系列" class="headerlink" title="前端系列"></a>前端系列</h3><ul><li>html/html5</li><li>css/css3</li><li>javascript</li><li>jquery</li><li>node.js</li><li>vue</li></ul><h3 id="中医系列"><a href="#中医系列" class="headerlink" title="中医系列"></a>中医系列</h3><ul><li>五行八卦</li><li>周易</li><li>皇帝内经</li><li>伤寒论</li><li>金匮要略</li></ul><h3 id="心理学"><a href="#心理学" class="headerlink" title="心理学"></a>心理学</h3><ul><li>沟通</li><li>人性的弱点</li><li>厚黑学</li></ul><h3 id="好书快读"><a href="#好书快读" class="headerlink" title="好书快读"></a>好书快读</h3><ul><li>《人性的弱点》</li></ul><h3 id="杂事杂感"><a href="#杂事杂感" class="headerlink" title="杂事杂感"></a>杂事杂感</h3><ul><li>程序员的青春饭</li><li>程序员的方向：领域专家，架构师，管理</li><li>打造个人品牌：公众号，博客，github，演讲，培训讲师</li><li>理财：银行定期活期，基金，期货，黄金，股票，私募，P2P</li><li>活着为了什么，人的目标与梦想</li><li>小公司，中型公司，大公司，民企，外企，国企</li><li>每个阶段的焦虑，如何避免贩卖焦虑者的腐蚀</li><li>懒惰者，好高骛远者，迷茫者的自我救赎</li><li>学习的方法论</li><li>思想、身体、财富</li><li>如何识别一个人</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;/img/zqxj.jpg&quot; width=&quot;100%&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Jav
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://longman.kim/2018/10/08/Tomcat/"/>
    <id>http://longman.kim/2018/10/08/Tomcat/</id>
    <published>2018-10-08T02:27:22.000Z</published>
    <updated>2018-10-08T02:27:22.388Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>域名解析的过程</title>
    <link href="http://longman.kim/2018/09/08/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://longman.kim/2018/09/08/域名解析的过程/</id>
    <published>2018-09-08T08:36:21.000Z</published>
    <updated>2018-09-09T04:45:39.108Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-浏览器如何根据域名查找IP？"><a href="#1-浏览器如何根据域名查找IP？" class="headerlink" title="1. 浏览器如何根据域名查找IP？"></a>1. 浏览器如何根据域名查找IP？</h3><ol><li>查浏览器缓存（浏览器会定期刷新DNS缓存）。</li><li>操作系统缓存。</li><li>路由器缓存。</li><li>ISP的DNS服务器。</li><li>根服务器。（cn -&gt; com.cn -&gt; baidu.com.cn -&gt; <a href="http://www.baidu.com.cn）。" target="_blank" rel="noopener">www.baidu.com.cn）。</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-浏览器如何根据域名查找IP？&quot;&gt;&lt;a href=&quot;#1-浏览器如何根据域名查找IP？&quot; class=&quot;headerlink&quot; title=&quot;1. 浏览器如何根据域名查找IP？&quot;&gt;&lt;/a&gt;1. 浏览器如何根据域名查找IP？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;查浏览器缓存
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《算法导论》粗略</title>
    <link href="http://longman.kim/2018/09/07/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%B2%97%E7%95%A5/"/>
    <id>http://longman.kim/2018/09/07/《算法导论》粗略/</id>
    <published>2018-09-07T10:54:00.000Z</published>
    <updated>2018-09-08T08:32:42.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><h5 id="1-如何分析算法，时间复杂度和空间复杂度的计算，最坏、平均、最好情况的分析？"><a href="#1-如何分析算法，时间复杂度和空间复杂度的计算，最坏、平均、最好情况的分析？" class="headerlink" title="1. 如何分析算法，时间复杂度和空间复杂度的计算，最坏、平均、最好情况的分析？"></a>1. 如何分析算法，时间复杂度和空间复杂度的计算，最坏、平均、最好情况的分析？</h5><h5 id="2-如何设计算法，分治法、递归法、主方法（主定理的证明）？"><a href="#2-如何设计算法，分治法、递归法、主方法（主定理的证明）？" class="headerlink" title="2.  如何设计算法，分治法、递归法、主方法（主定理的证明）？"></a>2.  如何设计算法，分治法、递归法、主方法（主定理的证明）？</h5><h5 id="3-概率分析和随机算法？"><a href="#3-概率分析和随机算法？" class="headerlink" title="3. 概率分析和随机算法？"></a>3. 概率分析和随机算法？</h5><h3 id="2-排序和顺序统计学"><a href="#2-排序和顺序统计学" class="headerlink" title="2. 排序和顺序统计学"></a>2. 排序和顺序统计学</h3><h5 id="1-有哪些排序算法，时间复杂度和空间复杂度多少，都有哪些优缺点，哪些方面可以优化？"><a href="#1-有哪些排序算法，时间复杂度和空间复杂度多少，都有哪些优缺点，哪些方面可以优化？" class="headerlink" title="1. 有哪些排序算法，时间复杂度和空间复杂度多少，都有哪些优缺点，哪些方面可以优化？"></a>1. 有哪些排序算法，时间复杂度和空间复杂度多少，都有哪些优缺点，哪些方面可以优化？</h5><p>快排<br>堆排序<br>计数排序<br>基数排序<br>桶排序<br>冒泡<br>选择<br>插入</p><h5 id="2-中位数，最小值，最大值的求解和时空分析？"><a href="#2-中位数，最小值，最大值的求解和时空分析？" class="headerlink" title="2. 中位数，最小值，最大值的求解和时空分析？"></a>2. 中位数，最小值，最大值的求解和时空分析？</h5><h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h3><h5 id="1-有哪些基本的数据结构？"><a href="#1-有哪些基本的数据结构？" class="headerlink" title="1. 有哪些基本的数据结构？"></a>1. 有哪些基本的数据结构？</h5><p>栈<br>队列<br>链表  </p><h5 id="2-如何用数组模拟指针，用链表模拟有根树？"><a href="#2-如何用数组模拟指针，用链表模拟有根树？" class="headerlink" title="2. 如何用数组模拟指针，用链表模拟有根树？"></a>2. 如何用数组模拟指针，用链表模拟有根树？</h5><p>开辟另一个数组，内部元素的值代表指针。</p><h5 id="2-散列表"><a href="#2-散列表" class="headerlink" title="2. 散列表"></a>2. 散列表</h5><h3 id="4-高级设计和分析技术"><a href="#4-高级设计和分析技术" class="headerlink" title="4. 高级设计和分析技术"></a>4. 高级设计和分析技术</h3><h3 id="5-高级数据结构"><a href="#5-高级数据结构" class="headerlink" title="5. 高级数据结构"></a>5. 高级数据结构</h3><h3 id="6-图算法"><a href="#6-图算法" class="headerlink" title="6. 图算法"></a>6. 图算法</h3><h3 id="7-算法研究问题选编"><a href="#7-算法研究问题选编" class="headerlink" title="7. 算法研究问题选编"></a>7. 算法研究问题选编</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. 基础知识&quot;&gt;&lt;/a&gt;1. 基础知识&lt;/h3&gt;&lt;h5 id=&quot;1-如何分析算法，时间复杂度和空间复杂度的计算，最坏、平均、最好情况的分析？&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>乐观锁，悲观锁</title>
    <link href="http://longman.kim/2018/09/04/%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://longman.kim/2018/09/04/乐观锁，悲观锁/</id>
    <published>2018-09-04T13:19:05.000Z</published>
    <updated>2018-09-04T13:36:29.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h3><ol><li><p>使用场景<br>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p></li><li><p>流程<br>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。<br>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。<br>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。<br>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。  </p></li><li><p>排他锁的上锁和释放<br>上锁：select…for update<br>释放：autocommit</p></li><li><p>优缺点<br>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p></li></ol><h3 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h3><ol><li><p>使用场景<br>乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p></li><li><p>实现方法：时间戳、版本号<br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。  </p><pre><code>1.查询出商品信息  select (status,status,version) from t_goods where id=#{id}  2.根据商品信息生成订单  3.修改商品status为2  update t_goods  set status=2,version=version+1  where id=#{id} and version=#{version};  </code></pre><p> 时间戳和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p></li><li><p>优缺点<br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。  </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-悲观锁&quot;&gt;&lt;a href=&quot;#1-悲观锁&quot; class=&quot;headerlink&quot; title=&quot;1. 悲观锁&quot;&gt;&lt;/a&gt;1. 悲观锁&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用场景&lt;br&gt;悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux的I/O多路复用select, poll, epoll</title>
    <link href="http://longman.kim/2018/09/04/Linux%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8select-poll-epoll/"/>
    <id>http://longman.kim/2018/09/04/Linux的I-O多路复用select-poll-epoll/</id>
    <published>2018-09-04T12:46:32.000Z</published>
    <updated>2018-09-04T13:06:04.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-共性"><a href="#1-共性" class="headerlink" title="1. 共性"></a>1. 共性</h3><ol><li><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。  </p></li><li><p>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p></li></ol><h3 id="2-select（消息传递）"><a href="#2-select（消息传递）" class="headerlink" title="2. select（消息传递）"></a>2. select（消息传递）</h3><ol><li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大。  </p></li><li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。  </p></li><li><p>select支持的文件描述符数量太小了，默认是1024。</p></li></ol><h3 id="3-epoll（共享内存）"><a href="#3-epoll（共享内存）" class="headerlink" title="3. epoll（共享内存）"></a>3. epoll（共享内存）</h3><ol><li><p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。  </p></li><li><p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。  </p></li><li><p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。  </p></li><li><p>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p></li></ol><h3 id="3-epoll的优势"><a href="#3-epoll的优势" class="headerlink" title="3. epoll的优势"></a>3. epoll的优势</h3><ol><li><p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，<strong>*但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间</strong>。这就是回调机制带来的性能提升。  </p></li><li><p><strong><em>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次</em></strong>（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。  </p></li><li><p>epoll没有最大并发连接的限制。效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关。内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-共性&quot;&gt;&lt;a href=&quot;#1-共性&quot; class=&quot;headerlink&quot; title=&quot;1. 共性&quot;&gt;&lt;/a&gt;1. 共性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java并发深入CPU内部</title>
    <link href="http://longman.kim/2018/09/04/Java%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5CPU%E5%86%85%E9%83%A8/"/>
    <id>http://longman.kim/2018/09/04/Java并发深入CPU内部/</id>
    <published>2018-09-04T11:36:45.000Z</published>
    <updated>2018-09-04T11:37:20.313Z</updated>
    
    <content type="html"><![CDATA[<p>CPU高速缓存, L1, L2, L3, 多核心<br>MESI缓存一致性协议<br>storebuffe, loadbuffer<br>内存屏障的种类（store, load, full）<br>指令重排序<br>as-if-serial语义<br>可见性</p><p>并发<br>future, countdownlatch, condition, forkjoin, wait/notify</p><p>happensbefore</p><p>JMM Java内存模型<br>多核心处理器、cup缓存、并发、编译器、8种原子操作指令</p><p>线程-&gt;工作内存-&gt;主内存</p><p>lock read load use assign store write unlock</p><p>可见性用锁</p><p>volatile内存屏障防止重排序，通过加lock</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU高速缓存, L1, L2, L3, 多核心&lt;br&gt;MESI缓存一致性协议&lt;br&gt;storebuffe, loadbuffer&lt;br&gt;内存屏障的种类（store, load, full）&lt;br&gt;指令重排序&lt;br&gt;as-if-serial语义&lt;br&gt;可见性&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kafka, rocketmq, wemq的特点，改进</title>
    <link href="http://longman.kim/2018/08/28/kafka-rocketmq-wemq%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E6%94%B9%E8%BF%9B/"/>
    <id>http://longman.kim/2018/08/28/kafka-rocketmq-wemq的特点，改进/</id>
    <published>2018-08-28T12:36:16.000Z</published>
    <updated>2018-08-28T12:36:16.171Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统内存管理</title>
    <link href="http://longman.kim/2018/08/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://longman.kim/2018/08/28/操作系统内存管理/</id>
    <published>2018-08-28T12:34:57.000Z</published>
    <updated>2018-08-28T12:34:57.970Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手，四次挥手，慢启动，流量控制，拥塞控制</title>
    <link href="http://longman.kim/2018/08/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E6%85%A2%E5%90%AF%E5%8A%A8%EF%BC%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://longman.kim/2018/08/28/TCP三次握手，四次挥手，慢启动，流量控制，拥塞控制/</id>
    <published>2018-08-28T12:34:31.000Z</published>
    <updated>2018-08-28T12:34:31.816Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进程、线程间的通信，特点，适用场景</title>
    <link href="http://longman.kim/2018/08/28/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%8C%E7%89%B9%E7%82%B9%EF%BC%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://longman.kim/2018/08/28/进程、线程间的通信，特点，适用场景/</id>
    <published>2018-08-28T12:33:59.000Z</published>
    <updated>2018-09-04T12:36:04.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进程与线程的区别"><a href="#1-进程与线程的区别" class="headerlink" title="1. 进程与线程的区别"></a>1. 进程与线程的区别</h3><ol><li>操作系统以多任务的方式，即多进程的方式运行。</li><li>进程是操作系统分配资源的单位，线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。</li><li>进程之间是通过时间片轮转算法进行调度。</li><li>在Windows中，进行CPU分配是以线程为单位的。</li><li>对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li><li>线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</li><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li><li>在进程内创建、终止线程比创建、终止进程要快，同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。</li><li>通过互斥锁，可以防止多个线程同时读写某一内存区域。</li><li>通过信号量，可以保证多个线程不会互相冲突，mutex是semaphore=1的特殊情况。</li><li>linux中创建进程使用fork, 创建线程使用pthread_create。</li></ol><h3 id="2-进程间的通信"><a href="#2-进程间的通信" class="headerlink" title="2. 进程间的通信"></a>2. 进程间的通信</h3><ol><li><p>共享内存<br>共享内存就是映射一段能被其他多个进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p></li><li><p>消息队列<br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>管道<br>管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在父子进程间使用。</p></li><li><p>信号量<br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p>套接字socket<br>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p></li></ol><h3 id="3-进程间通信的场景"><a href="#3-进程间通信的场景" class="headerlink" title="3. 进程间通信的场景"></a>3. 进程间通信的场景</h3><ol><li><p>共享内存<br>能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。 </p></li><li><p>消息队列<br>容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</p></li><li><p>管道<br>速度慢，容量有限，只有父子进程能通讯。</p></li><li><p>信号量<br>不能传递复杂消息，只能用来同步。</p></li></ol><h3 id="4-线程间的通信与同步"><a href="#4-线程间的通信与同步" class="headerlink" title="4. 线程间的通信与同步"></a>4. 线程间的通信与同步</h3><ol><li><p>通信<br>全局变量，消息</p></li><li><p>同步<br>临界区，互斥量，信号量（PV操作），事件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-进程与线程的区别&quot;&gt;&lt;a href=&quot;#1-进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;1. 进程与线程的区别&quot;&gt;&lt;/a&gt;1. 进程与线程的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;操作系统以多任务的方式，即多进程的方式运行。&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL技巧</title>
    <link href="http://longman.kim/2018/08/23/MySQL%E6%8A%80%E5%B7%A7/"/>
    <id>http://longman.kim/2018/08/23/MySQL技巧/</id>
    <published>2018-08-23T02:38:58.000Z</published>
    <updated>2018-08-23T02:52:57.739Z</updated>
    
    <content type="html"><![CDATA[<ol><li>默认创建时间、更新时间  </li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create_time datetime default current_timestamp comment &apos;创建时间&apos;   </span><br><span class="line">update_time datetime not null default current_timestamp on update current_timestamp comment &apos;更新时间&apos;</span><br></pre></td></tr></table></figure><ol start="2"><li>last_insert_id（功能）<br>使用last_insert_id生成全局ID分配器  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table sequence (id int not null);</span><br><span class="line">insert into sequence values(0);</span><br><span class="line">update sequence set id=last_insert_id(id+1);</span><br><span class="line">select last_insert_id();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;默认创建时间、更新时间  &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create_time datetime d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>token, 流水号, 密码存储的设计方案</title>
    <link href="http://longman.kim/2018/08/17/token-%E6%B5%81%E6%B0%B4%E5%8F%B7-%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://longman.kim/2018/08/17/token-流水号-密码存储的设计方案/</id>
    <published>2018-08-17T07:31:10.000Z</published>
    <updated>2018-08-17T10:11:22.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-token设计方案"><a href="#1-token设计方案" class="headerlink" title="1. token设计方案"></a>1. token设计方案</h3><p>token=version+sha256(module+userId+ua+ip+timestamp+randKey)+timestamp<br>其中module代表业务，userId用户号，randKey系统生成的随机数<br>将token, randKey作为value，module+userId作为key缓存在redis，并设置超时时间timeout</p><ol><li>用户第一次登陆成功后，生成token返回给用户  </li><li>用户每次请求，先校验用户是否已下线或者被踢掉了，下线或者被踢掉了后，需要重新登录鉴权生成token，没有的话根据请求上带的信息生成token(需要利用redis中的randKey)，对比生成的token、redis缓存的token、客户端上带的token，三者对比一致后续期redis的超时时间</li><li>用户两次请求的间隔超过了timeout，redis的数据过期了，需要重新登录鉴权生成token  </li><li>被踢掉时，将原始module+token作为key缓存在redis，并设置超时时间，其超时间要大于timeout。每次鉴权的时候，看以module+token为key的缓存是否存在，存在的话需要重新登录鉴权生成新的token</li><li>主动下线时，删除缓存中登录信息的redis</li></ol><p>csrfToken  </p><h3 id="2-流水号"><a href="#2-流水号" class="headerlink" title="2. 流水号"></a>2. 流水号</h3><ol><li>基于实例ID</li></ol><ol start="2"><li>基于DB</li></ol><ol start="3"><li>基于Redis</li></ol><ol start="4"><li>基于Zookeeper  </li></ol><h3 id="3-密码存储方案"><a href="#3-密码存储方案" class="headerlink" title="3. 密码存储方案"></a>3. 密码存储方案</h3><h5 id="1-一种工作中设计的方案"><a href="#1-一种工作中设计的方案" class="headerlink" title="1.一种工作中设计的方案"></a>1.一种工作中设计的方案</h5><p>前端处理：  </p><ol><li>sha256(userId+password) –&gt; hashvalue  </li><li>rsa encrypt(hashvalue + random) –&gt; encrypt password  </li><li>前端把encrypt password和random上送给后台系统  </li></ol><p>后端处理：  </p><ol><li>rsa decrypt(encrypt password) –&gt; hashvalue + random  </li><li>校验前端的random和第一步解密后的random是否一致，不一致退出，一致进入第三步  </li><li>hash(hashvalue + random salt) –&gt; store password<br>数据库存储userId, salt, store password  </li></ol><h5 id="2-加密技术"><a href="#2-加密技术" class="headerlink" title="2. 加密技术"></a>2. 加密技术</h5><ol><li>哈希函数（单向加密，不可逆）</li><li>哈希函数的破解<br>查找表、反向查找表、彩虹表  </li><li>加盐<br>加盐salt能够让查找表和彩虹表都失效<br>使用相同的盐值或者盐值太短效果不好  </li><li>双重哈希和古怪的哈希函数</li><li>哈希碰撞</li><li>使密码更难破解：慢哈希函数  </li><li>不可能破解的哈希函数<br>密钥哈希（使用AES对哈希值加密、使用密钥哈希算法HMAC）<br>密码哈希设备(YubiHSM)    </li><li>哈希算法<br>建议使用精心设计的密钥扩展算法如PBKDF2、bcrypt、scrypt、crypt安全版本。不建议使用MD5、SHA1、SHA256、SHA512、RipeMD、WHIRLPOOL、SHA3等。  </li></ol><p>参考<a href="http://www.infoq.com/cn/articles/how-to-encrypt-the-user-password-correctly" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/how-to-encrypt-the-user-password-correctly</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-token设计方案&quot;&gt;&lt;a href=&quot;#1-token设计方案&quot; class=&quot;headerlink&quot; title=&quot;1. token设计方案&quot;&gt;&lt;/a&gt;1. token设计方案&lt;/h3&gt;&lt;p&gt;token=version+sha256(module+user
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OAuth和OpenId Connect</title>
    <link href="http://longman.kim/2018/08/16/OAuth%E5%92%8COpenId-Connect/"/>
    <id>http://longman.kim/2018/08/16/OAuth和OpenId-Connect/</id>
    <published>2018-08-16T12:37:13.000Z</published>
    <updated>2018-08-17T06:51:05.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-OAuth的概念"><a href="#1-OAuth的概念" class="headerlink" title="1. OAuth的概念"></a>1. OAuth的概念</h3><p>开放授权，OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站在特定的时段内访问特定的资源。</p><h3 id="2-OAuth1-0和OAuth2-0的区别"><a href="#2-OAuth1-0和OAuth2-0的区别" class="headerlink" title="2. OAuth1.0和OAuth2.0的区别"></a>2. OAuth1.0和OAuth2.0的区别</h3><h3 id="3-OAuth2-0的运行流程"><a href="#3-OAuth2-0的运行流程" class="headerlink" title="3. OAuth2.0的运行流程"></a>3. OAuth2.0的运行流程</h3><ol><li>用户打开客户端以后，客户端要求用户给予授权（火鸡APP要求用户授权微信信息）。</li><li>用户同意给予客户端授权（用户将微信发送的code和wechatAppId发送给火鸡）。</li><li>客户端使用上一步获得的授权，向认证服务器申请令牌（mbaccomm利用code获取access_token, mbaccomm事先保存wechatAppId和wechatAppSecret）。</li><li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌（微信下发access_token）。</li><li>客户端使用令牌，向资源服务器申请获取资源（mbaccomm利用access_token获取用户的微信信息）。</li><li>资源服务器确认令牌无误，同意向客户端开放资源（微信确认access_token后开放用户信息给mbaccomm）。</li></ol><h3 id="4-授权的几种模式"><a href="#4-授权的几种模式" class="headerlink" title="4. 授权的几种模式"></a>4. 授权的几种模式</h3><ol><li><p>授权码模式<br>火鸡APP微信登录，有折公众号登录(code-&gt;access_token-&gt;资源)  </p></li><li><p>简化模式<br>主要用于无服务器端的应用，其流程为<br>a Client(第三方应用)将用户导向认证服务器<br>b 用户决定是否给客户端授权<br>c 如果用户同意给客户端授权，则认证服务器将用户重定向到Client指定的  redirect_url, 并在URL的hash部分包含访问令牌<br>d UA通过javascript解析URL的Hash中的访问令牌信息<br>e UA将解析得到的访问令牌发送给Client<br>f UA或Client利用访问令牌去获取资源服务器的资源<br>其中令牌对于用户和浏览器是可见的。</p></li><li><p>密码模式<br>用户必须把自己的密码给客户端，但是客户端不得储存密码<br>a 用户向客户端提供用户和密码<br>b 客户端将用户密码发送给认证服务器，请求令牌<br>c 认证服务器确认无误后，向客户端发放令牌access_token</p></li><li><p>客户端模式<br>用户直接向客户端注册<br>a 客户端向认证服务器进行身份证，请求令牌<br>b 认证服务器确认无误后，向客户端下发令牌  </p></li><li><p>更新令牌<br>当access_token过期时，使用refresh_token(有效期比较长)更新一个新的令牌，当refresh_token过期时，需要重新授权。</p></li></ol><p>火鸡APP手Q登录 OAuth1.0</p><h3 id="5-OpenID-Connect-OIDC身份认证授权"><a href="#5-OpenID-Connect-OIDC身份认证授权" class="headerlink" title="5. OpenID Connect(OIDC身份认证授权)"></a>5. OpenID Connect(OIDC身份认证授权)</h3><p>OIDC=(Identity, Authentication) + OAuth 2.0。它在OAuth2上构建了一个身份层，是一个基于OAuth2协议的身份认证标准协议。主要原因是因为OAuth2是一个授权协议，它无法提供完善的身份认证功能，OIDC使用OAuth2的授权服务器为第三方客户端提供用户的身份认证，并把对应的身份认证信息传递给客户端。<br>OIDC工作流程：  </p><ol><li>客户端发送一个认证请求给授权服务器  </li><li>授权服务器对用户身份进行认证，然后提供授权  </li><li>授权服务器把ID Token和Access Token返回给客户端  </li><li>客户端利用Access Token请求用户信息接口  </li><li>用户信息接口返回用户的信息  </li></ol><h3 id="6-OAuth2-0与OpenID-Connect的区别"><a href="#6-OAuth2-0与OpenID-Connect的区别" class="headerlink" title="6. OAuth2.0与OpenID Connect的区别"></a>6. OAuth2.0与OpenID Connect的区别</h3><p>OpenID是用来认证协议（我是谁），OAuth是授权协议（我能做什么），二者是互补的。</p><h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h3><p>微信公众平台的授权<br>阿里云的OpenID授权<br>google<br>yahoo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-OAuth的概念&quot;&gt;&lt;a href=&quot;#1-OAuth的概念&quot; class=&quot;headerlink&quot; title=&quot;1. OAuth的概念&quot;&gt;&lt;/a&gt;1. OAuth的概念&lt;/h3&gt;&lt;p&gt;开放授权，OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微服务的难点</title>
    <link href="http://longman.kim/2018/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9/"/>
    <id>http://longman.kim/2018/08/16/微服务的难点/</id>
    <published>2018-08-16T04:37:07.000Z</published>
    <updated>2018-08-16T09:07:53.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-如何拆分微服务"><a href="#1-如何拆分微服务" class="headerlink" title="1. 如何拆分微服务"></a>1. 如何拆分微服务</h3><p>拆分领域数据库  </p><p>领域模型的设计概念，聚合  </p><h3 id="2-微服务和数据库"><a href="#2-微服务和数据库" class="headerlink" title="2. 微服务和数据库"></a>2. 微服务和数据库</h3><p>不同服务间跨表查询困难  </p><p>CQRS解决分布式查询问题</p><p>分布式事务，NoSQL不支持ACID，2PC  </p><p>事件驱动架构的一种技术，事件源，解决分布式事务</p><h3 id="3-DDD聚合"><a href="#3-DDD聚合" class="headerlink" title="3. DDD聚合"></a>3. DDD聚合</h3><h3 id="4-事件源"><a href="#4-事件源" class="headerlink" title="4. 事件源"></a>4. 事件源</h3><h3 id="5-CQRS命令查询责任分离"><a href="#5-CQRS命令查询责任分离" class="headerlink" title="5. CQRS命令查询责任分离"></a>5. CQRS命令查询责任分离</h3><h3 id="6-微服务架构的六种模式"><a href="#6-微服务架构的六种模式" class="headerlink" title="6. 微服务架构的六种模式"></a>6. 微服务架构的六种模式</h3><ol><li>聚合器微服务设计模式</li><li>代理微服务设计模式</li><li>链式微服务设计模式</li><li>分支微服务设计模式</li><li>数据共享微服务设计模式</li><li>异步消息传递微服务设计模式</li></ol><h3 id="7-微服务架构技术选型"><a href="#7-微服务架构技术选型" class="headerlink" title="7. 微服务架构技术选型"></a>7. 微服务架构技术选型</h3><ol><li>生态：容器, PAAS, Cloud Native, gRPC, ServiceMesh, Serverless</li><li>选型标准：生产级、一线互联网公司落地产品、开源社区活跃度</li><li>微服务框架：Spring Boot/Cloud，Dubbo, gRPC</li><li>服务注册中心：Eureka+Ribbon/Consul</li><li>服务网关：Zuul, Nginx/OpenResty</li><li>配置中心：携程Apollo, Spring Cloud Config</li><li>日志监控：ELK</li><li>调用链监控：点评CAT, Zipkin, Pinpoint</li><li>Metrics监控：OpenTSDB, Sensu</li><li>服务容错：Hystrix, Nginx, Kong</li><li>消息系统：Kafka, RocketMQ, RabbitMQ</li><li>缓存治理：CacheCloud, Twemproxy, Codis</li><li>分布式数据访问层：当当shardingjdbc, 阿里mycat</li><li>任务调度：xxl-job, elastic-job</li><li>安全认证授权：基于OAuth和OpenID connect自我定制，Wso2</li><li>集群资源调度系统：K8s, 定制Mesos</li><li>镜像治理：Docker Registry, harbor</li><li>资源治理：CMDB</li><li>发布平台：spinnaker</li><li>IAM：Apereo CAS, Keycloak，自我定制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-如何拆分微服务&quot;&gt;&lt;a href=&quot;#1-如何拆分微服务&quot; class=&quot;headerlink&quot; title=&quot;1. 如何拆分微服务&quot;&gt;&lt;/a&gt;1. 如何拆分微服务&lt;/h3&gt;&lt;p&gt;拆分领域数据库  &lt;/p&gt;
&lt;p&gt;领域模型的设计概念，聚合  &lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQLite</title>
    <link href="http://longman.kim/2018/08/06/SQLite/"/>
    <id>http://longman.kim/2018/08/06/SQLite/</id>
    <published>2018-08-06T13:27:17.000Z</published>
    <updated>2018-08-07T02:46:40.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-优缺点"><a href="#1-优缺点" class="headerlink" title="1. 优缺点"></a>1. 优缺点</h3><ol><li>进程内的库</li><li>自给自足，不需要任何的外部依赖</li><li>无服务器，不需要单独的服务进程或操作系统</li><li>零配置，不需要安装或管理</li><li>事务性，完全兼容ACID，允许多个进程或线程安全访问</li><li>轻量级，完全配置时小于400k，省略配置时小于250k</li><li>不支持alter table中的修改删除列，只能通过重新建表的方式迂回进行</li><li>动态的，弱类型的SQL语法，不进行类型检查</li><li>SQLite不是传统C/S架构的数据库，而是嵌入式数据库</li><li>应用程序直接通过API调用来使用SQLite的功能，相比传统数据库的进程通信，单一进程中的函数调用效率更高</li><li>SQLite将整个数据库（定义、表、索引、数据）作为一个单独的、可跨平台使用的文件存储在主机中</li><li>写数据时，对数据库文件进行加锁。多个进程或线程可以同时访问一个数据库，平行读取同一个数据库。但同一时间只能有一个进程或线程进行数据写入。</li></ol><h3 id="2-Java示例"><a href="#2-Java示例" class="headerlink" title="2. Java示例"></a>2. Java示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.sql.*;</span><br><span class="line">import org.sqlite.JDBC</span><br><span class="line"></span><br><span class="line">public TestSQLite &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;org.sqlite.JDBC&quot;);</span><br><span class="line">            Connection conn = DriverManager.getConnection(&quot;jdbc:sqlite:test.db&quot;); //test.db是SQLite数据库的名称</span><br><span class="line">            Statement stat = conn.createStatement();</span><br><span class="line">            stat.executeUpdate(&quot;create table tb1(name varchar(20), salary int);&quot;);</span><br><span class="line">            stat.executeUpdate(&quot;insert into tb1 values(&apos;Zhangsan&apos;, 8000);&quot;);</span><br><span class="line">            stat.executeUpdate(&quot;insert into tb1 values(&apos;LiSi&apos;, 7800);&quot;);</span><br><span class="line">            ResultSet rs = stat.executeQuery(&quot;select * from tb1;&quot;);</span><br><span class="line">            while(rs.next) &#123;</span><br><span class="line">                System.out.println(&quot;name = &quot; + rs.getString(&quot;name&quot;));</span><br><span class="line">                System.out.println(&quot;salary = &quot; + rs.getString(&quot;salary&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-优缺点&quot;&gt;&lt;a href=&quot;#1-优缺点&quot; class=&quot;headerlink&quot; title=&quot;1. 优缺点&quot;&gt;&lt;/a&gt;1. 优缺点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;进程内的库&lt;/li&gt;
&lt;li&gt;自给自足，不需要任何的外部依赖&lt;/li&gt;
&lt;li&gt;无服务器，不需要单独
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>未来一年的规划（2018.8——2019.8）</title>
    <link href="http://longman.kim/2018/08/02/%E6%9C%AA%E6%9D%A5%E4%B8%80%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92%EF%BC%882018-8%E2%80%94%E2%80%942019-8%EF%BC%89/"/>
    <id>http://longman.kim/2018/08/02/未来一年的规划（2018-8——2019-8）/</id>
    <published>2018-08-02T12:32:43.000Z</published>
    <updated>2018-08-07T06:33:31.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-英语"><a href="#1-英语" class="headerlink" title="1. 英语"></a>1. 英语</h3><p>雅思8分  </p><ol><li>听<br>听新闻  </li><li>说<br>注册网站，与老外视频聊天  </li><li>读<br>读短篇、长篇文章  </li><li>写<br>议论文  </li><li>练<br>做题  </li></ol><h3 id="2-数据结构与算法"><a href="#2-数据结构与算法" class="headerlink" title="2. 数据结构与算法"></a>2. 数据结构与算法</h3><p>leetcode最少2遍（Java和C++各实现一遍）<br>poj最少500题</p><ol><li><p>排序<br>冒泡排序，选择排序，插入排序，堆排序，快速排序，基数排序，桶排序， 归并排序  </p></li><li><p>查找<br>二分查找</p></li><li><p>贪心</p></li><li><p>动态规划</p></li><li><p>KMP</p></li><li><p>A*</p></li><li><p>线段树  </p></li></ol><p>树状数组</p><ol start="8"><li><p>网络流</p></li><li><p>数论</p></li><li><p>最短路径</p></li><li><p>BFS, DFS</p></li><li><p>AVL树、红黑树</p></li><li><p>B, B-, B+树</p></li></ol><h3 id="3-Java-C-源码分析"><a href="#3-Java-C-源码分析" class="headerlink" title="3. Java/C++源码分析"></a>3. Java/C++源码分析</h3><p>分析笔记  </p><ol><li>精读JDK中的util, lang, io, nio</li><li>C++ STL</li></ol><h3 id="4-架构设计"><a href="#4-架构设计" class="headerlink" title="4. 架构设计"></a>4. 架构设计</h3><p>AWS、阿里的设计方案  </p><p>给出解决方案，指出架构的优缺点，结合业务逻辑</p><h3 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h3><p>带实验的知识点笔记  </p><ol><li>架构优化</li><li>JVM优化</li><li>线程池</li><li>数据库优化</li><li>C++程序的调试和性能优化</li></ol><h3 id="6-数据库"><a href="#6-数据库" class="headerlink" title="6. 数据库"></a>6. 数据库</h3><p>画图、带实验的个人总结<br>书籍、数据结构、算法、架构、原理、源码</p><ol><li>mysql</li><li>redis</li><li>hbase</li></ol><h3 id="7-业界方案"><a href="#7-业界方案" class="headerlink" title="7. 业界方案"></a>7. 业界方案</h3><p>腾讯、阿里、百度、美团、微博、豆瓣，它们的github</p><h3 id="8-大数据"><a href="#8-大数据" class="headerlink" title="8. 大数据"></a>8. 大数据</h3><p>画图、实验<br>Hadoop生态</p><h3 id="9-源码分析"><a href="#9-源码分析" class="headerlink" title="9. 源码分析"></a>9. 源码分析</h3><p>手写，带实验的笔记  </p><ol><li>redis</li><li>mongodb</li><li>zookeeper</li><li>spring</li><li>nginx</li><li>tomcat</li><li>netty</li><li>rocketmq</li><li>dubbo</li></ol><h3 id="10-个人品牌输出"><a href="#10-个人品牌输出" class="headerlink" title="10. 个人品牌输出"></a>10. 个人品牌输出</h3><p>完整的后台服务框架需要做哪些东西-业务逻辑和服务治理（服务发现、发布、容灾、容错、扩展、链路分析、服务可降级、白名单、安全）</p><ol><li>登录注册</li><li>负载均衡</li><li>cdn加速</li><li>接入层</li><li>逻辑层</li><li>中间层</li><li>存储层</li><li>业务运营管理平台、配置管理、发布管理、监控告警上报、统计上报</li><li>项目管理、需求管理</li></ol><h3 id="11-Github"><a href="#11-Github" class="headerlink" title="11. Github"></a>11. Github</h3><p>工程实战<br>让github成为自己的名片，以项目推动自己的进步，输出代码和文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-英语&quot;&gt;&lt;a href=&quot;#1-英语&quot; class=&quot;headerlink&quot; title=&quot;1. 英语&quot;&gt;&lt;/a&gt;1. 英语&lt;/h3&gt;&lt;p&gt;雅思8分  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;听&lt;br&gt;听新闻  &lt;/li&gt;
&lt;li&gt;说&lt;br&gt;注册网站，与老外视频聊天  &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例的写法</title>
    <link href="http://longman.kim/2018/08/02/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%86%99%E6%B3%95/"/>
    <id>http://longman.kim/2018/08/02/单例的写法/</id>
    <published>2018-08-02T06:51:25.000Z</published>
    <updated>2018-08-02T08:03:28.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-懒汉"><a href="#1-懒汉" class="headerlink" title="1. 懒汉"></a>1. 懒汉</h3><p>缺点是每次都要加锁。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (null == instance) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-饿汉"><a href="#2-饿汉" class="headerlink" title="2. 饿汉"></a>2. 饿汉</h3><p>缺点是类加载的时候就创建了实例。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-双重校验锁"><a href="#3-双重校验锁" class="headerlink" title="3. 双重校验锁"></a>3. 双重校验锁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (null == instance) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (null == instance) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h3><p>优点是可以防止反序列化创建对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnumSingleton &#123;</span><br><span class="line">    private EnumSingleton()&#123;&#125;</span><br><span class="line">    public static EnumSingleton getInstance() &#123;</span><br><span class="line">        return Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    private static Enum Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        private EnumSingleton singleton;</span><br><span class="line">        private Singleton() &#123;</span><br><span class="line">            singleton = new EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        public EnumSingleton getInstance() &#123;</span><br><span class="line">            return singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>优点是可以延迟加载。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static class SingleHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static final Singleton getInstance() &#123;</span><br><span class="line">        return SingleHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-懒汉&quot;&gt;&lt;a href=&quot;#1-懒汉&quot; class=&quot;headerlink&quot; title=&quot;1. 懒汉&quot;&gt;&lt;/a&gt;1. 懒汉&lt;/h3&gt;&lt;p&gt;缺点是每次都要加锁。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Java虚拟机规范》</title>
    <link href="http://longman.kim/2018/08/01/%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B/"/>
    <id>http://longman.kim/2018/08/01/《Java虚拟机规范》/</id>
    <published>2018-08-01T12:10:25.000Z</published>
    <updated>2018-08-01T13:14:14.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><h5 id="1-1-历史简介"><a href="#1-1-历史简介" class="headerlink" title="1.1 历史简介"></a>1.1 历史简介</h5><h5 id="1-2-Java虚拟机"><a href="#1-2-Java虚拟机" class="headerlink" title="1.2 Java虚拟机"></a>1.2 Java虚拟机</h5><h5 id="1-3-规范制定的组织"><a href="#1-3-规范制定的组织" class="headerlink" title="1.3 规范制定的组织"></a>1.3 规范制定的组织</h5><h5 id="1-4-标记"><a href="#1-4-标记" class="headerlink" title="1.4 标记"></a>1.4 标记</h5><h5 id="1-5-反馈"><a href="#1-5-反馈" class="headerlink" title="1.5 反馈"></a>1.5 反馈</h5><h3 id="2-Java虚拟机的结构"><a href="#2-Java虚拟机的结构" class="headerlink" title="2. Java虚拟机的结构"></a>2. Java虚拟机的结构</h3><h5 id="2-1-class文件的格式"><a href="#2-1-class文件的格式" class="headerlink" title="2.1 class文件的格式"></a>2.1 class文件的格式</h5><h5 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h5><h5 id="2-3-基本类型和值"><a href="#2-3-基本类型和值" class="headerlink" title="2.3 基本类型和值"></a>2.3 基本类型和值</h5><h5 id="2-4-引用类型和值"><a href="#2-4-引用类型和值" class="headerlink" title="2.4 引用类型和值"></a>2.4 引用类型和值</h5><h5 id="2-5-运行时数据区域"><a href="#2-5-运行时数据区域" class="headerlink" title="2.5 运行时数据区域"></a>2.5 运行时数据区域</h5><h5 id="2-6-帧"><a href="#2-6-帧" class="headerlink" title="2.6 帧"></a>2.6 帧</h5><h5 id="2-7-对象的表示"><a href="#2-7-对象的表示" class="headerlink" title="2.7 对象的表示"></a>2.7 对象的表示</h5><h5 id="2-8-浮点类型的计算"><a href="#2-8-浮点类型的计算" class="headerlink" title="2.8 浮点类型的计算"></a>2.8 浮点类型的计算</h5><h5 id="2-9-特别的方法"><a href="#2-9-特别的方法" class="headerlink" title="2.9 特别的方法"></a>2.9 特别的方法</h5><h5 id="2-10-异常"><a href="#2-10-异常" class="headerlink" title="2.10 异常"></a>2.10 异常</h5><h5 id="2-11-命令集总结"><a href="#2-11-命令集总结" class="headerlink" title="2.11 命令集总结"></a>2.11 命令集总结</h5><h5 id="2-12-类库"><a href="#2-12-类库" class="headerlink" title="2.12 类库"></a>2.12 类库</h5><h5 id="2-13-公共、私有的实现"><a href="#2-13-公共、私有的实现" class="headerlink" title="2.13 公共、私有的实现"></a>2.13 公共、私有的实现</h5><h3 id="3-编译Java虚拟机"><a href="#3-编译Java虚拟机" class="headerlink" title="3. 编译Java虚拟机"></a>3. 编译Java虚拟机</h3><h5 id="3-1-例子的格式"><a href="#3-1-例子的格式" class="headerlink" title="3.1 例子的格式"></a>3.1 例子的格式</h5><h5 id="3-2-常量，局部变量，构造函数的使用"><a href="#3-2-常量，局部变量，构造函数的使用" class="headerlink" title="3.2 常量，局部变量，构造函数的使用"></a>3.2 常量，局部变量，构造函数的使用</h5><h5 id="3-3-算术运算"><a href="#3-3-算术运算" class="headerlink" title="3.3 算术运算"></a>3.3 算术运算</h5><h5 id="3-4-访问运行时的常量池"><a href="#3-4-访问运行时的常量池" class="headerlink" title="3.4 访问运行时的常量池"></a>3.4 访问运行时的常量池</h5><h5 id="3-5-更多控制的例子"><a href="#3-5-更多控制的例子" class="headerlink" title="3.5 更多控制的例子"></a>3.5 更多控制的例子</h5><h5 id="3-6-接收参数"><a href="#3-6-接收参数" class="headerlink" title="3.6 接收参数"></a>3.6 接收参数</h5><h5 id="3-7-调用方法"><a href="#3-7-调用方法" class="headerlink" title="3.7 调用方法"></a>3.7 调用方法</h5><h5 id="3-8-类实例的使用"><a href="#3-8-类实例的使用" class="headerlink" title="3.8 类实例的使用"></a>3.8 类实例的使用</h5><h5 id="3-9-数组"><a href="#3-9-数组" class="headerlink" title="3.9 数组"></a>3.9 数组</h5><h5 id="3-10-编译切换"><a href="#3-10-编译切换" class="headerlink" title="3.10 编译切换"></a>3.10 编译切换</h5><h5 id="3-11-栈操作符"><a href="#3-11-栈操作符" class="headerlink" title="3.11 栈操作符"></a>3.11 栈操作符</h5><h5 id="3-12-异常的抛出与处理"><a href="#3-12-异常的抛出与处理" class="headerlink" title="3.12 异常的抛出与处理"></a>3.12 异常的抛出与处理</h5><h5 id="3-13-finally的编译"><a href="#3-13-finally的编译" class="headerlink" title="3.13 finally的编译"></a>3.13 finally的编译</h5><h5 id="3-14-同步Synchronization"><a href="#3-14-同步Synchronization" class="headerlink" title="3.14 同步Synchronization"></a>3.14 同步Synchronization</h5><h5 id="3-15-注解"><a href="#3-15-注解" class="headerlink" title="3.15 注解"></a>3.15 注解</h5><h3 id="4-类class文件的格式"><a href="#4-类class文件的格式" class="headerlink" title="4. 类class文件的格式"></a>4. 类class文件的格式</h3><h5 id="4-1-类文件的结构"><a href="#4-1-类文件的结构" class="headerlink" title="4.1 类文件的结构"></a>4.1 类文件的结构</h5><h5 id="4-2-名字的内部格式"><a href="#4-2-名字的内部格式" class="headerlink" title="4.2 名字的内部格式"></a>4.2 名字的内部格式</h5><h5 id="4-3-描述符"><a href="#4-3-描述符" class="headerlink" title="4.3 描述符"></a>4.3 描述符</h5><h5 id="4-4-常量池"><a href="#4-4-常量池" class="headerlink" title="4.4 常量池"></a>4.4 常量池</h5><h5 id="4-5-域"><a href="#4-5-域" class="headerlink" title="4.5 域"></a>4.5 域</h5><h5 id="4-6-方法"><a href="#4-6-方法" class="headerlink" title="4.6 方法"></a>4.6 方法</h5><h5 id="4-7-属性"><a href="#4-7-属性" class="headerlink" title="4.7 属性"></a>4.7 属性</h5><h5 id="4-8-格式检查"><a href="#4-8-格式检查" class="headerlink" title="4.8 格式检查"></a>4.8 格式检查</h5><h5 id="4-9-Java虚拟机代码的限制"><a href="#4-9-Java虚拟机代码的限制" class="headerlink" title="4.9 Java虚拟机代码的限制"></a>4.9 Java虚拟机代码的限制</h5><h5 id="4-10-类文件的验证"><a href="#4-10-类文件的验证" class="headerlink" title="4.10 类文件的验证"></a>4.10 类文件的验证</h5><h5 id="4-11-Java虚拟机的限制"><a href="#4-11-Java虚拟机的限制" class="headerlink" title="4.11 Java虚拟机的限制"></a>4.11 Java虚拟机的限制</h5><h3 id="5-加载、链接、初始化"><a href="#5-加载、链接、初始化" class="headerlink" title="5 加载、链接、初始化"></a>5 加载、链接、初始化</h3><h5 id="5-1-运行时常量池"><a href="#5-1-运行时常量池" class="headerlink" title="5.1 运行时常量池"></a>5.1 运行时常量池</h5><h5 id="5-2-Java虚拟机的启动"><a href="#5-2-Java虚拟机的启动" class="headerlink" title="5.2 Java虚拟机的启动"></a>5.2 Java虚拟机的启动</h5><h5 id="5-3-创建和加载"><a href="#5-3-创建和加载" class="headerlink" title="5.3 创建和加载"></a>5.3 创建和加载</h5><h5 id="5-4-链接"><a href="#5-4-链接" class="headerlink" title="5.4 链接"></a>5.4 链接</h5><h5 id="5-5-初始化"><a href="#5-5-初始化" class="headerlink" title="5.5 初始化"></a>5.5 初始化</h5><h5 id="5-6-绑定本地方法的实现"><a href="#5-6-绑定本地方法的实现" class="headerlink" title="5.6 绑定本地方法的实现"></a>5.6 绑定本地方法的实现</h5><h5 id="5-7-Java虚拟机的退出"><a href="#5-7-Java虚拟机的退出" class="headerlink" title="5.7 Java虚拟机的退出"></a>5.7 Java虚拟机的退出</h5><h3 id="6-Java虚拟机指令集"><a href="#6-Java虚拟机指令集" class="headerlink" title="6. Java虚拟机指令集"></a>6. Java虚拟机指令集</h3><h5 id="6-1-假设：“必须”的意义"><a href="#6-1-假设：“必须”的意义" class="headerlink" title="6.1 假设：“必须”的意义"></a>6.1 假设：“必须”的意义</h5><h5 id="6-2-保留的Opcodes"><a href="#6-2-保留的Opcodes" class="headerlink" title="6.2 保留的Opcodes"></a>6.2 保留的Opcodes</h5><h5 id="6-3-虚拟机错误"><a href="#6-3-虚拟机错误" class="headerlink" title="6.3 虚拟机错误"></a>6.3 虚拟机错误</h5><h5 id="6-4-指令描述的格式"><a href="#6-4-指令描述的格式" class="headerlink" title="6.4 指令描述的格式"></a>6.4 指令描述的格式</h5><h5 id="6-5-指令集"><a href="#6-5-指令集" class="headerlink" title="6.5 指令集"></a>6.5 指令集</h5><h3 id="7-Opcode"><a href="#7-Opcode" class="headerlink" title="7. Opcode"></a>7. Opcode</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;h5 id=&quot;1-1-历史简介&quot;&gt;&lt;a href=&quot;#1-1-历史简介&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>openjdk-8浏览总结</title>
    <link href="http://longman.kim/2018/08/01/openjdk-8%E6%B5%8F%E8%A7%88%E6%80%BB%E7%BB%93/"/>
    <id>http://longman.kim/2018/08/01/openjdk-8浏览总结/</id>
    <published>2018-08-01T08:22:22.000Z</published>
    <updated>2018-08-09T12:29:54.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块介绍"><a href="#1-模块介绍" class="headerlink" title="1. 模块介绍"></a>1. 模块介绍</h3><ul><li><p>common  </p></li><li><p>corba<br>Common Object Request Broker Architecture(通用对象请求代理架构), 基于对象-服务机制设计，类似于JavaBean和微软的COM技术。  </p><blockquote><ol><li>RPC<br>支持xml和json两种格式的消息，使用http作为其传输协议。  </li><li>CORBA<br>使用IDL作为消息，使用tcp作为传输协议，使用JNDI查找服务。CORBA是OMG(Object Management Group)对象管理组织提出的方案，解决分布式环境中软硬件系统的互联。现在已经用的比较少了，基本被Web Service替代，只有一些大型的电信项目还在用CORBA。</li><li>Web Service<br>包含AXIS, XFire, CFX   </li><li>SOAP<br>使用xml作为消息，使用http作为传输协议。  </li><li>RMI<br>使用JRMP作为消息，可以使用http, tcp等作为传输协议，使用JNDI查找服务。</li></ol></blockquote></li><li><p>hotspot<br>JVM的实现之一</p><blockquote><ol><li>cms</li><li>g1</li><li>parallel scavenge</li></ol></blockquote></li><li><p>jaxp<br>Java API for XML Processing, 解析与校验xml文件，提供了3种接口来处理XML文档。</p><blockquote><p>DOM接口(文档对象模型解析)<br>SAX接口(XML简单API解析)<br>StAX接口(XML流API)</p></blockquote></li><li><p>jaxws<br>XML Web Services的Java API, 全称Java API for Web Services，允许开发者选择面向RPC(RPC-oriented)或是面向消息(Message-oriented)的方式来实现自己的Web Services。</p></li><li><p>jdk<br>JDK的实现  </p><blockquote><ol><li>ThreadLocal</li><li>BlockingQueue</li><li>EnumMap</li><li>EnumSet</li><li>HashMap</li><li>CurrentHashMap</li><li>ArraryList</li><li>HashSet</li><li>TreeSet</li><li>LinkedHashMap</li><li>TreeMap</li><li>LinkedList</li><li>HashTable</li><li>Vector</li></ol></blockquote></li><li><p>langtools<br>Java语言工具，包含javac, javap等实用程序的源码。</p></li><li><p>make</p></li><li><p>nashorn<br>JVM上的JavaScript运行时</p></li><li><p>test</p></li></ul><h3 id="2-辅助书籍"><a href="#2-辅助书籍" class="headerlink" title="2. 辅助书籍"></a>2. 辅助书籍</h3><ol><li>《Java虚拟机规范》</li><li>《深入理解Java虚拟机》</li><li>《Hotspot实战》</li></ol><h3 id="3-其他建议"><a href="#3-其他建议" class="headerlink" title="3. 其他建议"></a>3. 其他建议</h3><ol><li><p>精读源码<br>java.util<br>java.lang<br>java.io  </p></li><li><p>深刻理解<br>java.lang.reflect<br>java.net<br>java.net.<em><br>java.nio<br>java.util.concurrent.</em></p></li><li><p>会用即可<br>java.lang.annotation<br>javax.annotation.<em><br>java.lang.ref<br>java.math<br>java.rmi.</em><br>javax.rmi.<em><br>java.security.</em><br>javax.security.<em><br>java.sql<br>javax.sql.</em><br>javax.transaction.<em><br>java.text<br>javax.xml.</em><br>org.w3c.dom.<em><br>org.xml.sax.</em><br>javax.crypto.<em><br>javax.imageio.</em><br>javax.jws.*<br>java.util.jar<br>java.util.logging<br>java.util.prefs<br>java.util.regex<br>java.util.zip  </p></li></ol><h3 id="4-java-util"><a href="#4-java-util" class="headerlink" title="4. java.util"></a>4. java.util</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-模块介绍&quot;&gt;&lt;a href=&quot;#1-模块介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 模块介绍&quot;&gt;&lt;/a&gt;1. 模块介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;common  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;corba&lt;br&gt;Common O
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>临时</title>
    <link href="http://longman.kim/2018/08/01/%E4%B8%B4%E6%97%B6/"/>
    <id>http://longman.kim/2018/08/01/临时/</id>
    <published>2018-08-01T01:37:48.000Z</published>
    <updated>2018-09-04T11:35:31.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-零拷贝"><a href="#1-零拷贝" class="headerlink" title="1. 零拷贝"></a>1. 零拷贝</h3><h3 id="2-Netty的ChannelPipeline"><a href="#2-Netty的ChannelPipeline" class="headerlink" title="2. Netty的ChannelPipeline"></a>2. Netty的ChannelPipeline</h3><h3 id="3-2PC，3PC"><a href="#3-2PC，3PC" class="headerlink" title="3. 2PC，3PC"></a>3. 2PC，3PC</h3><h3 id="4-redis选举"><a href="#4-redis选举" class="headerlink" title="4. redis选举"></a>4. redis选举</h3><h3 id="5-CAP中的P"><a href="#5-CAP中的P" class="headerlink" title="5. CAP中的P"></a>5. CAP中的P</h3><h3 id="6-HBase与MySQL的对比"><a href="#6-HBase与MySQL的对比" class="headerlink" title="6. HBase与MySQL的对比"></a>6. HBase与MySQL的对比</h3><h3 id="7-POW挖矿，POF-DPOF-RAFT"><a href="#7-POW挖矿，POF-DPOF-RAFT" class="headerlink" title="7. POW挖矿，POF, DPOF, RAFT"></a>7. POW挖矿，POF, DPOF, RAFT</h3><h3 id="8-行内的架构"><a href="#8-行内的架构" class="headerlink" title="8. 行内的架构"></a>8. 行内的架构</h3><h3 id="9-消息中间件需要解决的问题"><a href="#9-消息中间件需要解决的问题" class="headerlink" title="9. 消息中间件需要解决的问题"></a>9. 消息中间件需要解决的问题</h3><h3 id="10-BloomFilter-布隆过滤器"><a href="#10-BloomFilter-布隆过滤器" class="headerlink" title="10. BloomFilter 布隆过滤器"></a>10. BloomFilter 布隆过滤器</h3><h3 id="11-MySQL-流式查询"><a href="#11-MySQL-流式查询" class="headerlink" title="11. MySQL 流式查询"></a>11. MySQL 流式查询</h3><h3 id="12-区间树-树状数组"><a href="#12-区间树-树状数组" class="headerlink" title="12. 区间树/树状数组"></a>12. 区间树/树状数组</h3><h3 id="13-MYSQL的分区字段"><a href="#13-MYSQL的分区字段" class="headerlink" title="13. MYSQL的分区字段"></a>13. MYSQL的分区字段</h3><h3 id="14-last-insert-id"><a href="#14-last-insert-id" class="headerlink" title="14. last_insert_id"></a>14. last_insert_id</h3><h3 id="15-下载大文件"><a href="#15-下载大文件" class="headerlink" title="15. 下载大文件"></a>15. 下载大文件</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-零拷贝&quot;&gt;&lt;a href=&quot;#1-零拷贝&quot; class=&quot;headerlink&quot; title=&quot;1. 零拷贝&quot;&gt;&lt;/a&gt;1. 零拷贝&lt;/h3&gt;&lt;h3 id=&quot;2-Netty的ChannelPipeline&quot;&gt;&lt;a href=&quot;#2-Netty的ChannelP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一致性算法</title>
    <link href="http://longman.kim/2018/07/26/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    <id>http://longman.kim/2018/07/26/一致性算法/</id>
    <published>2018-07-26T14:09:06.000Z</published>
    <updated>2018-07-31T04:52:15.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-2PC"><a href="#1-2PC" class="headerlink" title="1. 2PC"></a>1. 2PC</h3><ol><li>投票阶段<blockquote><p>协调者向所有参与者发送事务内容，等待参与者的响应；<br>参与者执行事务，并将undo和redo信息记入事务日志；<br>参与者向协调者反馈事务的响应YES或者NO；  </p></blockquote></li></ol><ol start="2"><li><p>提交阶段</p><blockquote><p>如果所有参与者都反馈YES，则协调者向所有参与者发出提交请求，参与者完成事务提交后，向协调者发送ACK信息，协调者收到所有参与者的ACK信息后，完成事务。<br>任何一个参与者反馈NO，或者等待超时后，协调者会中断事务。协调者向所有参与者发送回滚请求，参与者收到回滚请求后，会利用undo信息进行事务回滚，并在完成回滚之后释放整个事务执行期间所占用的资源。参与者完成事务回滚之后，答复ACK信息。协调者收到所有的ACK信息后，完成事务中断。</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：原理简单、实现方便<br>确定：同步阻塞（执行2PC过程中所有参与该事务操作的逻辑都是阻塞状态）、单点问题（如果协调者挂了，2PC将无法运转，如果在提交阶段挂了，参与者将一直处于锁定事务资源的状态）、数据不一致（在提交阶段如果由于网络等问题导致commit请求没有到达部分参与者，则会出现数据不一致）、太过保守（如果参与者出现故障，协调者只能通过超时来判断是否需要中断事务）。</p></blockquote></li></ol><h3 id="2-3PC（解决2PC的阻塞，但数据还可能不一致）"><a href="#2-3PC（解决2PC的阻塞，但数据还可能不一致）" class="headerlink" title="2. 3PC（解决2PC的阻塞，但数据还可能不一致）"></a>2. 3PC（解决2PC的阻塞，但数据还可能不一致）</h3><ol><li><p>询问阶段</p><blockquote><p>协调者向参与者发送询问是否能执行该事务的请求，并等待。<br>参与者收到询问后，正常情况下，反馈YES，否则反馈NO。  </p></blockquote></li><li><p>预提交阶段</p><blockquote><p>如果询问阶段协调者收到的响应都是YES，那么事务进入预提交。<br>协调者向所有参与者发送预提交请求。<br>参与者收到预提交请求后，执行该事务，并记录undo和redo到事务日记中。<br>参与者向协调者反馈预提交的结果，并等待最终指令，提交commit或者终止abort。<br>如果询问阶段任何一个参与者反馈了No，或者协调者等待超时，那么就会执行中断事务。<br>协调者向所有参与者发送中断请求。<br>无论是收到协调者的中断请求还是等待超时，参与者都执行中断事务。  </p></blockquote></li><li><p>提交阶段</p><blockquote><p>假设协调者正常工作，接收到了所有参与者的ACK响应，它将从预提交阶段进入提交状态，并向所有参与者发送提交请求。<br>参与者收到提交请求后，正式提交事务，在事务完成后释放资源<br>参与者完成事务提交后，向协调者发送ACK<br>协调者收到所有ACK信息，完成事务<br>假设协调者正常工作，任一参与者反馈No，或者等待超时后，协调者都会中断事务。<br>协调者向所有参与者发送中断请求<br>参与者接收到中断请求后，利用undo日志执行事务回滚，并在完成事务回滚后释放资源。<br>参与者在完成事务回滚后，向协调者发送ACK信息。<br>协调者收到所有参与者的ACK信息后，中断事务。  </p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：降低参与者阻塞范围，能够在出现单点故障后继续达成一致。解决了2PC的阻塞问题，引入了预提交阶段，当所有参与者收到预提交请求后，不执行动作，直到收到提交请求或者超时。<br>缺点：引入预提交阶段，在这个阶段如果出现网络分区，协调者无法与参与者正常通信，参与者依然会进行事务提交，造成数据不一致。  </p></blockquote></li></ol><h3 id="3-拜占庭问题"><a href="#3-拜占庭问题" class="headerlink" title="3. 拜占庭问题"></a>3. 拜占庭问题</h3><p>消息不完整或者被篡改。  </p><h3 id="4-PAXOS（解决单点问题）"><a href="#4-PAXOS（解决单点问题）" class="headerlink" title="4. PAXOS（解决单点问题）"></a>4. PAXOS（解决单点问题）</h3><ol><li>Prepare阶段<blockquote><p>提案号，任何结点在Prepare阶段时都会拒绝其值小于当前提案号的请求。如果接收结点收到的提案号n大于其他结点发过来的提案号，这个结点会回应YES（本结点上最新的被批准提案号），并保证不接收其他&lt;n的提案号。</p></blockquote></li></ol><ol start="2"><li>Accept阶段<blockquote><p>如果提案者收到了超过半数的结点返回YES，它就会向所有的结点发布Accept Request，如果没有半数的话，那就返回失败。<br>当结点收到的Accept Request后，如果对于该结点来说n是最大的，它就通过request。如果发现自己有一个更大的提案号，结点就会拒绝request。</p></blockquote></li></ol><h3 id="5-RAFT"><a href="#5-RAFT" class="headerlink" title="5. RAFT"></a>5. RAFT</h3><p>follower、candidate、leader三个角色。<br>最开始大家都是follower，当follower监听不到leader时，自己成为candidate，并发起投票。</p><ol><li><p>leader的选举</p><blockquote><p>选举的timeout。follower随机等待一定时间成为candidate，看谁先成为candidate，它会先投自己一票，然后向其他结点发起投票邀请。如果得到大多数的投票就成为leader，之后定期向follower发送心跳。如果两个follower同时成为candidate，并且最后的投票相同，则等待其他的follower的选择超时后，开始新一轮的选举。</p></blockquote></li><li><p>log复制</p><blockquote><p>leader把变动的log借助心跳同步给follower，过半回复之后才成功提交，之后再下一次心跳之后，follower也commit变动，在自己的node上生效。  </p></blockquote></li></ol><h3 id="6-ZAB"><a href="#6-ZAB" class="headerlink" title="6. ZAB"></a>6. ZAB</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-2PC&quot;&gt;&lt;a href=&quot;#1-2PC&quot; class=&quot;headerlink&quot; title=&quot;1. 2PC&quot;&gt;&lt;/a&gt;1. 2PC&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;投票阶段&lt;blockquote&gt;
&lt;p&gt;协调者向所有参与者发送事务内容，等待参与者的响应；&lt;br&gt;参
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《代码的未来》</title>
    <link href="http://longman.kim/2018/07/26/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%AA%E6%9D%A5%E3%80%8B/"/>
    <id>http://longman.kim/2018/07/26/《代码的未来》/</id>
    <published>2018-07-26T12:22:43.000Z</published>
    <updated>2018-07-26T14:02:26.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-编程的时间和空间"><a href="#1-编程的时间和空间" class="headerlink" title="1. 编程的时间和空间"></a>1. 编程的时间和空间</h3><h3 id="2-编程语言的过去、现在和未来"><a href="#2-编程语言的过去、现在和未来" class="headerlink" title="2. 编程语言的过去、现在和未来"></a>2. 编程语言的过去、现在和未来</h3><h3 id="3-编程语言的新潮流"><a href="#3-编程语言的新潮流" class="headerlink" title="3. 编程语言的新潮流"></a>3. 编程语言的新潮流</h3><h3 id="4-云计算时代的编程"><a href="#4-云计算时代的编程" class="headerlink" title="4. 云计算时代的编程"></a>4. 云计算时代的编程</h3><h3 id="5-支撑大数据的数据存储技术"><a href="#5-支撑大数据的数据存储技术" class="headerlink" title="5. 支撑大数据的数据存储技术"></a>5. 支撑大数据的数据存储技术</h3><h3 id="6-多核时代的编程"><a href="#6-多核时代的编程" class="headerlink" title="6. 多核时代的编程"></a>6. 多核时代的编程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-编程的时间和空间&quot;&gt;&lt;a href=&quot;#1-编程的时间和空间&quot; class=&quot;headerlink&quot; title=&quot;1. 编程的时间和空间&quot;&gt;&lt;/a&gt;1. 编程的时间和空间&lt;/h3&gt;&lt;h3 id=&quot;2-编程语言的过去、现在和未来&quot;&gt;&lt;a href=&quot;#2-编程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring中的事务（传播机制、隔离级别、回滚、超时）</title>
    <link href="http://longman.kim/2018/07/24/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E5%9B%9E%E6%BB%9A%E3%80%81%E8%B6%85%E6%97%B6%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/24/Spring中的事务（传播机制、隔离级别、回滚、超时）/</id>
    <published>2018-07-24T03:21:55.000Z</published>
    <updated>2018-07-24T03:30:15.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-传播机制"><a href="#1-传播机制" class="headerlink" title="1. 传播机制"></a>1. 传播机制</h3><h3 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2. 隔离级别"></a>2. 隔离级别</h3><h3 id="3-回滚"><a href="#3-回滚" class="headerlink" title="3. 回滚"></a>3. 回滚</h3><h3 id="4-超时"><a href="#4-超时" class="headerlink" title="4. 超时"></a>4. 超时</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-传播机制&quot;&gt;&lt;a href=&quot;#1-传播机制&quot; class=&quot;headerlink&quot; title=&quot;1. 传播机制&quot;&gt;&lt;/a&gt;1. 传播机制&lt;/h3&gt;&lt;h3 id=&quot;2-隔离级别&quot;&gt;&lt;a href=&quot;#2-隔离级别&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ELK搭建网站监控系统</title>
    <link href="http://longman.kim/2018/07/23/ELK%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>http://longman.kim/2018/07/23/ELK搭建网站监控系统/</id>
    <published>2018-07-23T12:36:53.000Z</published>
    <updated>2018-08-01T12:53:46.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网站流量监控系统"><a href="#网站流量监控系统" class="headerlink" title=". 网站流量监控系统"></a>. 网站流量监控系统</h3><h3 id="1-Logstash-JRuby编写"><a href="#1-Logstash-JRuby编写" class="headerlink" title="1. Logstash(JRuby编写)"></a>1. Logstash(JRuby编写)</h3><p>矿工，日志收集，日志来自于业务系统，业务系统由不同的语言编写，过滤日志格式。Logstash采用Ruby语法，自定义日志格式过滤器，将格式化后的数据输出到ElasticSearch。它的可靠性低，占用CPU和内存的比率很高。</p><h3 id="2-ElasticSearch-Java编写"><a href="#2-ElasticSearch-Java编写" class="headerlink" title="2. ElasticSearch(Java编写)"></a>2. ElasticSearch(Java编写)</h3><p>日志仓库，提供全文检索，快速检索，分布式存储。ElasticSearch采用主备部署。<br>插件elasticsearch-head。</p><h3 id="3-Kibana-javascript编写"><a href="#3-Kibana-javascript编写" class="headerlink" title="3. Kibana(javascript编写)"></a>3. Kibana(javascript编写)</h3><p>可视化，数据来源于ES，实时读取数据变化。</p><h3 id="4-Filebeat"><a href="#4-Filebeat" class="headerlink" title="4. Filebeat"></a>4. Filebeat</h3><p>承担数据采集的角色</p><h3 id="6-ELK海量日志监控的部署"><a href="#6-ELK海量日志监控的部署" class="headerlink" title="6. ELK海量日志监控的部署"></a>6. ELK海量日志监控的部署</h3><p>利用Kafka将同步改成异步</p><h3 id="7-场景"><a href="#7-场景" class="headerlink" title="7. 场景"></a>7. 场景</h3><p>监控、统计、分析、检索</p><hr><h3 id="8-咕泡学院"><a href="#8-咕泡学院" class="headerlink" title="8. 咕泡学院"></a>8. 咕泡学院</h3><h5 id="8-1-日志的级别"><a href="#8-1-日志的级别" class="headerlink" title="8.1 日志的级别"></a>8.1 日志的级别</h5><p>DEBUG, INFO, WARN, ERROR</p><h5 id="8-2-系统监控"><a href="#8-2-系统监控" class="headerlink" title="8.2 系统监控"></a>8.2 系统监控</h5><p>日志、APO、心跳监控、数据库监控、Filter、Trace</p><h5 id="8-3-集中式监控"><a href="#8-3-集中式监控" class="headerlink" title="8.3 集中式监控"></a>8.3 集中式监控</h5><h5 id="8-4-ELK"><a href="#8-4-ELK" class="headerlink" title="8.4 ELK"></a>8.4 ELK</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网站流量监控系统&quot;&gt;&lt;a href=&quot;#网站流量监控系统&quot; class=&quot;headerlink&quot; title=&quot;. 网站流量监控系统&quot;&gt;&lt;/a&gt;. 网站流量监控系统&lt;/h3&gt;&lt;h3 id=&quot;1-Logstash-JRuby编写&quot;&gt;&lt;a href=&quot;#1-Logst
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://longman.kim/2018/07/23/MongoDB/"/>
    <id>http://longman.kim/2018/07/23/MongoDB/</id>
    <published>2018-07-23T12:10:52.000Z</published>
    <updated>2018-07-23T12:10:52.249Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Netty实战</title>
    <link href="http://longman.kim/2018/07/20/Netty%E5%AE%9E%E6%88%98/"/>
    <id>http://longman.kim/2018/07/20/Netty实战/</id>
    <published>2018-07-20T08:08:46.000Z</published>
    <updated>2018-07-23T14:12:39.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Netty——异步和事件驱动"><a href="#1-Netty——异步和事件驱动" class="headerlink" title="1. Netty——异步和事件驱动"></a>1. Netty——异步和事件驱动</h3><ol><li>Java网络编程</li></ol><blockquote><ol><li>阻塞I/O<br>例如accept会一直阻塞到一个连接的建立，readLine会一直阻塞到换行符或者回车结尾的字符被读取。进一步，可以采用线程池处理多个请求，但存在大量的线程因为等待I/O数据就绪而处于休眠状态，并且需要为每个线程分配调用栈并切换上下文，同时虚拟机支持的线程数量有限。    </li><li>Java NIO, 非阻塞I/O<br>用setsocketopt()配置套接字，在读写调用没有数据时立即返回，当有任何套接字已经有数据可供读写时，使用操作系统的事件通知主线程。主线程中有一个selector，它可以监控多个Buffer相连，每个Buffer和一个Socket相连，当任何Buffer中有数据可读写时，selector就会选择该Buffer进行读写，即和该Buffer对应的Socket通信。  </li></ol></blockquote><ol start="2"><li>Netty简介<blockquote><p>Netty的特点  </p><ol><li>设计<br>统一的API，支持多种传输类型，阻塞和非阻塞，简单而强大的线程模型，真正的无连接数据报套接字支持，链接逻辑组件以支持复用  </li><li>易于使用  </li><li>性能<br>比Java核心API更高的吞吐量以及更低的延迟，得益于池化和复用，拥有更低的资源消耗，最少的内存复制  </li><li>健壮性<br>不会因为慢速、快速或者超载的连接而导致OutOfMemoryError，消除在高速网络中NIO应用程序常见的不公平读/写比率  </li><li>安全性<br>完整的SSL/TLS以及StartTLS支持，可用于受限环境下  </li><li>社区驱动<br>发布快速而且频繁  </li></ol><p>Netty常用来做HTTP长连接，或者各种推送通知  </p><p>异步和事件驱动  </p></blockquote></li></ol><ol start="3"><li>Netty的核心组件</li></ol><blockquote><ol><li>Channel<br>Channel是Java NIO的一个基本构造，代表一个到实体的开放连接，如读写操作。可以把Channel看作是传入（入站）和传出（出站）数据的载体，它可以被打开，被关闭，连接或者断开连接。  </li><li>回调<br>回调是一个方法，其他系统在某个操作完成后通知该系统时，就是调用的回调方法。  </li><li>Future<br>异步操作的结果的占位符，它将在未来的某个时候完成，并提供对其结果的访问。在JDK中只允许手动检测对应的操作是否已经完成，或者一直阻塞直到它完成。Netty中自己实现了ChannelFuture,用于异步操作。ChannelFuture能够注册一个或多个监听器ChannelFutureListener, 在操作完成时会调用监听器的operationComplete()方法，ChannelFutureListener提供的通知机制消除了手动检查对应操作是否完成的必要。每个Netty的传出I/O操作都将返回一个ChannelFuture，即它们不会阻塞，Netty是完成异步和事件驱动的。</li><li>事件和ChannelHandler<br>入站事件：连接已被激活或者连接失活，数据读取，用户事件，错误事件。<br>出站事件：打开或者关闭到远程节点的连接，将数据写到或者冲刷到套接字。<br>入站事件-&gt;入站处理器，出站-&gt;出站处理器<br>拦截操作以及高速地转换入站和出站数据，都只需要你提供回调函数或者利用操作返回的Future。Netty为每个Channel分配一个EventLoop来处理所有事件，包括注册感兴趣的事件，将事件派发给ChannelHandler, 安排进一步的动作。Netty的EventLoop是一个线程驱动，处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会变。      </li></ol></blockquote><h3 id="2-你的第一款Netty应用程序"><a href="#2-你的第一款Netty应用程序" class="headerlink" title="2. 你的第一款Netty应用程序"></a>2. 你的第一款Netty应用程序</h3><ol><li><p>Echo服务器</p><blockquote><ol><li>至少一个ChannelHandler，处理从客户端接收到的数据，即业务处理。  </li><li>引导，配置服务器的启动代码，绑定端口，配置Channel。</li><li>ChannelHandler继承ChannelInboundHandlerAdapter，ChannelInboundHandlerAdapter实现ChannelInboundHandler接口，响应入站事件。我们感兴趣的方法有channelRead()对于每个传入的消息要调用，channelReadComplete()通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息。exeptionCaught()在读取操作期间，有异常抛出时会调用。</li><li>针对不同类型的事件来调用ChannelHandler。  </li><li>应用程序通过实现或者扩展ChannelHandler来挂钩到事件的生命周期，并且提供自定义的应用程序逻辑。  </li><li>在架构上，ChannelHandler有助于保持业务逻辑与网络处理代码的分离。   </li><li>服务器的大致流程，其中EchoServerHandler实现业务逻辑，main方法引导服务器<br>7.1 创建一个ServerBootstrap的实例以引导和绑定服务器<br>7.2 创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接收连接以及读写数据<br>7.3 指定服务器绑定本地的InetSocketAddress<br>7.4 使用一个EchoServerHandler的实例初始化每个新的Channel<br>7.5 调用ServerBootstrap.bind()绑定服务器  </li></ol></blockquote></li><li><p>Echo客户端</p><blockquote><ol><li>客户端的流程<br>1.1 连接到服务器<br>1.2 发送一个或者多个消息<br>1.3 对于每个消息，等待并接收从服务器发回的相同的消息<br>1.4 关闭连接  </li><li>ChannelHandler继承SimpleChannelInboundHandler实现ChannelInboundHandler，主要重写三个方法，channelActive()在到服务器的连接已经建立之后将被调用，channelRead0()当从服务器接收到一条消息时被调用，exceptionCaught()在处理过程中引发异常时被调用。  </li><li>SimpleChannelInboundHandler和ChannelInboundHandlerAdapter  </li></ol></blockquote></li></ol><h3 id="3-Netty的组件和设计"><a href="#3-Netty的组件和设计" class="headerlink" title="3. Netty的组件和设计"></a>3. Netty的组件和设计</h3><h3 id="4-传输"><a href="#4-传输" class="headerlink" title="4. 传输"></a>4. 传输</h3><h3 id="5-ByteBuf"><a href="#5-ByteBuf" class="headerlink" title="5. ByteBuf"></a>5. ByteBuf</h3><h3 id="6-ChannelHandler和ChannelPipeline"><a href="#6-ChannelHandler和ChannelPipeline" class="headerlink" title="6. ChannelHandler和ChannelPipeline"></a>6. ChannelHandler和ChannelPipeline</h3><h3 id="7-Eventloop和线程模型"><a href="#7-Eventloop和线程模型" class="headerlink" title="7. Eventloop和线程模型"></a>7. Eventloop和线程模型</h3><h3 id="8-引导"><a href="#8-引导" class="headerlink" title="8. 引导"></a>8. 引导</h3><h3 id="9-单元测试"><a href="#9-单元测试" class="headerlink" title="9. 单元测试"></a>9. 单元测试</h3><h3 id="10-编解码器框架"><a href="#10-编解码器框架" class="headerlink" title="10. 编解码器框架"></a>10. 编解码器框架</h3><h3 id="11-预置的ChannelHandler和编解码器"><a href="#11-预置的ChannelHandler和编解码器" class="headerlink" title="11. 预置的ChannelHandler和编解码器"></a>11. 预置的ChannelHandler和编解码器</h3><h3 id="12-WebSocket"><a href="#12-WebSocket" class="headerlink" title="12. WebSocket"></a>12. WebSocket</h3><h3 id="13-使用UDP广播事件"><a href="#13-使用UDP广播事件" class="headerlink" title="13. 使用UDP广播事件"></a>13. 使用UDP广播事件</h3><h3 id="14-案例研究，第一部分"><a href="#14-案例研究，第一部分" class="headerlink" title="14. 案例研究，第一部分"></a>14. 案例研究，第一部分</h3><h3 id="15-案例研究，第二部分"><a href="#15-案例研究，第二部分" class="headerlink" title="15. 案例研究，第二部分"></a>15. 案例研究，第二部分</h3><h3 id="附录-Maven介绍"><a href="#附录-Maven介绍" class="headerlink" title="附录 Maven介绍"></a>附录 Maven介绍</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Netty——异步和事件驱动&quot;&gt;&lt;a href=&quot;#1-Netty——异步和事件驱动&quot; class=&quot;headerlink&quot; title=&quot;1. Netty——异步和事件驱动&quot;&gt;&lt;/a&gt;1. Netty——异步和事件驱动&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Java网络
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式事务与秒杀技巧</title>
    <link href="http://longman.kim/2018/07/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E7%A7%92%E6%9D%80%E6%8A%80%E5%B7%A7/"/>
    <id>http://longman.kim/2018/07/20/分布式事务与秒杀技巧/</id>
    <published>2018-07-20T08:07:51.000Z</published>
    <updated>2018-07-20T08:08:21.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式事务的解法"><a href="#1-分布式事务的解法" class="headerlink" title="1. 分布式事务的解法"></a>1. 分布式事务的解法</h3><ol><li><p>一个系统操作多个数据库</p><blockquote><p>XA协议（数据库要支持XA协议）<br>基本功能：数据库功能+开源组件（atomikos）实现</p></blockquote></li><li><p>多系统操作多数据库</p><blockquote><p>MQ消息队列（生产者消费者模型），优点是解耦，缺点是不能保证实时性（需要结合业务场景进行规避）  </p></blockquote></li><li><p>TCC补偿机制</p><blockquote><p>可逆操作，编程式分布式事务，一种解决方案<br>atomikos的论文《Tcc For Rest》<br>TCC三要素try(预留资源，临时状态), canfirm(确认操作), cancel(操作回滚)<br>bytetcc</p></blockquote></li><li><p>TOC</p><blockquote><p>未知异常：人工干预</p></blockquote></li><li><p>CAP,BASE</p><blockquote><p>取舍一致性和可用性</p></blockquote></li></ol><h3 id="2-秒杀系统架构分析与实现"><a href="#2-秒杀系统架构分析与实现" class="headerlink" title="2. 秒杀系统架构分析与实现"></a>2. 秒杀系统架构分析与实现</h3><ol><li><p>超卖，解决方案是使用数据库的乐观锁</p></li><li><p>用户重复提交，前端控制防止重复提交，后台限流</p></li><li><p>超过服务器单台机器承受能力，解决方案nginx负载均衡多台机器</p></li><li><p>码农通过脚本攻击，redis(性能每秒10w，用pipeline每秒55w)针对userId限制操作频率</p></li><li><p>超过数据库最大连接数，采用令牌机制，预先生成令牌放在reids中，拿到令牌的可以操作数据库</p></li><li><p>其他方法</p><blockquote><p>采用消息队列，异步执行SQL<br>数据库分库分表<br>微服务架构独立秒杀系统，Docker实现快速扩容</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式事务的解法&quot;&gt;&lt;a href=&quot;#1-分布式事务的解法&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式事务的解法&quot;&gt;&lt;/a&gt;1. 分布式事务的解法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个系统操作多个数据库&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法工程师</title>
    <link href="http://longman.kim/2018/07/19/%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://longman.kim/2018/07/19/算法工程师/</id>
    <published>2018-07-18T17:37:27.000Z</published>
    <updated>2018-07-18T17:48:25.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><h3 id="2-回归"><a href="#2-回归" class="headerlink" title="2. 回归"></a>2. 回归</h3><h3 id="3-推荐"><a href="#3-推荐" class="headerlink" title="3. 推荐"></a>3. 推荐</h3><h3 id="4-深度学习"><a href="#4-深度学习" class="headerlink" title="4. 深度学习"></a>4. 深度学习</h3><h3 id="5-强化学习"><a href="#5-强化学习" class="headerlink" title="5. 强化学习"></a>5. 强化学习</h3><h3 id="6-NLP自然语言处理"><a href="#6-NLP自然语言处理" class="headerlink" title="6. NLP自然语言处理"></a>6. NLP自然语言处理</h3><h3 id="7-机器人定位算法"><a href="#7-机器人定位算法" class="headerlink" title="7. 机器人定位算法"></a>7. 机器人定位算法</h3><h3 id="8-多传感器融合算法"><a href="#8-多传感器融合算法" class="headerlink" title="8. 多传感器融合算法"></a>8. 多传感器融合算法</h3><h3 id="9-SLAM地图构建算法"><a href="#9-SLAM地图构建算法" class="headerlink" title="9. SLAM地图构建算法"></a>9. SLAM地图构建算法</h3><h3 id="10-路径规划算法"><a href="#10-路径规划算法" class="headerlink" title="10. 路径规划算法"></a>10. 路径规划算法</h3><h3 id="11-视觉算法（检测，跟踪）"><a href="#11-视觉算法（检测，跟踪）" class="headerlink" title="11. 视觉算法（检测，跟踪）"></a>11. 视觉算法（检测，跟踪）</h3><h3 id="12-TensorFlow"><a href="#12-TensorFlow" class="headerlink" title="12. TensorFlow"></a>12. TensorFlow</h3><h3 id="13-Caffe"><a href="#13-Caffe" class="headerlink" title="13. Caffe"></a>13. Caffe</h3><h3 id="14-有监督学习"><a href="#14-有监督学习" class="headerlink" title="14. 有监督学习"></a>14. 有监督学习</h3><h3 id="15-无监督学习"><a href="#15-无监督学习" class="headerlink" title="15. 无监督学习"></a>15. 无监督学习</h3><h3 id="16-卡尔曼滤波、粒子滤波"><a href="#16-卡尔曼滤波、粒子滤波" class="headerlink" title="16. 卡尔曼滤波、粒子滤波"></a>16. 卡尔曼滤波、粒子滤波</h3><h3 id="17-马尔科夫决策过程"><a href="#17-马尔科夫决策过程" class="headerlink" title="17. 马尔科夫决策过程"></a>17. 马尔科夫决策过程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分类&quot;&gt;&lt;a href=&quot;#1-分类&quot; class=&quot;headerlink&quot; title=&quot;1. 分类&quot;&gt;&lt;/a&gt;1. 分类&lt;/h3&gt;&lt;h3 id=&quot;2-回归&quot;&gt;&lt;a href=&quot;#2-回归&quot; class=&quot;headerlink&quot; title=&quot;2. 回归&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大数据开发工程师</title>
    <link href="http://longman.kim/2018/07/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://longman.kim/2018/07/19/大数据开发工程师/</id>
    <published>2018-07-18T17:00:07.000Z</published>
    <updated>2018-07-18T17:35:23.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Hadoop生态"><a href="#1-Hadoop生态" class="headerlink" title="1. Hadoop生态"></a>1. Hadoop生态</h3><h5 id="1-对大量数据进行分布式处理的软件框架Hadoop"><a href="#1-对大量数据进行分布式处理的软件框架Hadoop" class="headerlink" title="1. 对大量数据进行分布式处理的软件框架Hadoop"></a>1. 对大量数据进行分布式处理的软件框架Hadoop</h5><h5 id="2-分布式存储系统HDFS"><a href="#2-分布式存储系统HDFS" class="headerlink" title="2. 分布式存储系统HDFS"></a>2. 分布式存储系统HDFS</h5><h5 id="3-分布式计算框架MapReduce"><a href="#3-分布式计算框架MapReduce" class="headerlink" title="3. 分布式计算框架MapReduce"></a>3. 分布式计算框架MapReduce</h5><h5 id="4-分布式计算框架YARN"><a href="#4-分布式计算框架YARN" class="headerlink" title="4. 分布式计算框架YARN"></a>4. 分布式计算框架YARN</h5><h5 id="5-分布式数据库Hbase"><a href="#5-分布式数据库Hbase" class="headerlink" title="5. 分布式数据库Hbase"></a>5. 分布式数据库Hbase</h5><h5 id="6-分布式协调服务Zookeeper"><a href="#6-分布式协调服务Zookeeper" class="headerlink" title="6. 分布式协调服务Zookeeper"></a>6. 分布式协调服务Zookeeper</h5><h5 id="7-工作流引擎Pig-Pig2"><a href="#7-工作流引擎Pig-Pig2" class="headerlink" title="7. 工作流引擎Pig, Pig2"></a>7. 工作流引擎Pig, Pig2</h5><h5 id="8-数据仓库Hive-Hive2"><a href="#8-数据仓库Hive-Hive2" class="headerlink" title="8. 数据仓库Hive, Hive2"></a>8. 数据仓库Hive, Hive2</h5><h5 id="9-日志收集Flume"><a href="#9-日志收集Flume" class="headerlink" title="9. 日志收集Flume"></a>9. 日志收集Flume</h5><h5 id="10-作业流调度系统Oozie"><a href="#10-作业流调度系统Oozie" class="headerlink" title="10. 作业流调度系统Oozie"></a>10. 作业流调度系统Oozie</h5><h5 id="11-数据库TEL工具Sqoop"><a href="#11-数据库TEL工具Sqoop" class="headerlink" title="11. 数据库TEL工具Sqoop"></a>11. 数据库TEL工具Sqoop</h5><h5 id="12-安装部署工具Ambari"><a href="#12-安装部署工具Ambari" class="headerlink" title="12. 安装部署工具Ambari"></a>12. 安装部署工具Ambari</h5><h3 id="2-大数据处理框架Spark"><a href="#2-大数据处理框架Spark" class="headerlink" title="2. 大数据处理框架Spark"></a>2. 大数据处理框架Spark</h3><h3 id="3-基于数据流的实时处理系统Storm"><a href="#3-基于数据流的实时处理系统Storm" class="headerlink" title="3. 基于数据流的实时处理系统Storm"></a>3. 基于数据流的实时处理系统Storm</h3><h3 id="4-开源流处理平台Kafka"><a href="#4-开源流处理平台Kafka" class="headerlink" title="4. 开源流处理平台Kafka"></a>4. 开源流处理平台Kafka</h3><h3 id="5-面向分布式数据流处理和批量数据处理的开源计算平台Flink"><a href="#5-面向分布式数据流处理和批量数据处理的开源计算平台Flink" class="headerlink" title="5. 面向分布式数据流处理和批量数据处理的开源计算平台Flink"></a>5. 面向分布式数据流处理和批量数据处理的开源计算平台Flink</h3><h3 id="6-基于Lucence的搜索服务器Elasticsearch"><a href="#6-基于Lucence的搜索服务器Elasticsearch" class="headerlink" title="6. 基于Lucence的搜索服务器Elasticsearch"></a>6. 基于Lucence的搜索服务器Elasticsearch</h3><h3 id="7-MapReduce"><a href="#7-MapReduce" class="headerlink" title="7. MapReduce"></a>7. MapReduce</h3><h3 id="8-系统Debug-Profiling能力和经验"><a href="#8-系统Debug-Profiling能力和经验" class="headerlink" title="8. 系统Debug/Profiling能力和经验"></a>8. 系统Debug/Profiling能力和经验</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Hadoop生态&quot;&gt;&lt;a href=&quot;#1-Hadoop生态&quot; class=&quot;headerlink&quot; title=&quot;1. Hadoop生态&quot;&gt;&lt;/a&gt;1. Hadoop生态&lt;/h3&gt;&lt;h5 id=&quot;1-对大量数据进行分布式处理的软件框架Hadoop&quot;&gt;&lt;a h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂味</title>
    <link href="http://longman.kim/2018/07/18/%E6%9D%82%E5%91%B3/"/>
    <id>http://longman.kim/2018/07/18/杂味/</id>
    <published>2018-07-18T13:49:13.000Z</published>
    <updated>2018-07-18T16:55:27.424Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-MySQL主从同步的实现方式"><a href="#1-MySQL主从同步的实现方式" class="headerlink" title="1. MySQL主从同步的实现方式"></a>1. MySQL主从同步的实现方式</h5><blockquote><p>MySQL的复制是异步实时，具体步骤是：主服务器把数据更改记录写到binlog中，从服务器把binlog复制到自己的中继日志relay log中，然后重做中继日志，把更改应用到自己的数据库。</p></blockquote><h5 id="2-MySQL存储引擎的对比"><a href="#2-MySQL存储引擎的对比" class="headerlink" title="2. MySQL存储引擎的对比"></a>2. MySQL存储引擎的对比</h5><ol><li><p>Innodb</p><blockquote><p>支持事务、OLTP、行锁、支持外键、缓存索引缓存数据、MVCC(多版本并发控制)</p></blockquote></li><li><p>MyISAM</p><blockquote><p>不支持事务、OLAP、表锁、只缓存索引不缓存数据</p></blockquote></li></ol><h5 id="3-MySQL索引的实现"><a href="#3-MySQL索引的实现" class="headerlink" title="3. MySQL索引的实现"></a>3. MySQL索引的实现</h5><ol><li><p>B+树索引  </p><blockquote><p>记录节点按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。B树中的关键字分布在整棵树中，叶子节点不包含任何关键字信息，而B+树关键字集合分布在叶子节点中，非叶子节点只是叶子节点中关键字的索引。B树中任何一个关键字只出现在一个节点中，而B+树中的关键字必须出现在叶节点中，也可能在非叶节点中重复出现。<br>B+树比B树更适合做文件索引和数据库索引。B树只适合随机检索，B+树同时支持随机检索和顺序检索。B+树的磁盘读写代价更低。B+树的查询效率更加稳定。数据库中基于范围的查询是非常频繁的。<br>B+树索引支持 like ‘xxx%’和 like ‘%xxx’</p></blockquote></li><li><p>全文检索  </p><blockquote><p>倒排索引<br>全文索引支持 like ‘%xxx%’</p></blockquote></li></ol><h5 id="4-处理内存泄漏的经验"><a href="#4-处理内存泄漏的经验" class="headerlink" title="4. 处理内存泄漏的经验"></a>4. 处理内存泄漏的经验</h5><h5 id="5-长连接，离线推送，在线推送，及时通信IM，直播"><a href="#5-长连接，离线推送，在线推送，及时通信IM，直播" class="headerlink" title="5. 长连接，离线推送，在线推送，及时通信IM，直播"></a>5. 长连接，离线推送，在线推送，及时通信IM，直播</h5><ol><li><p>长连接</p><blockquote><p> HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP/1.0默认使用短连接，一次HTTP操作，就建立一次连接，任务结束就中断连接。HTTP/1.1默认使用长连接Connection:keep-alive，保持一定的时间，没有请求再断开。TCP长连接的保活功能主要由服务器应用提供，在给定的连接两个小时内没有任何动作，服务器就会向客户端发送一个探测报文。长连接多用户操作频繁，点对点的通讯，而且连接数不能太多。</p></blockquote></li><li><p>即时通讯IM</p><blockquote><p>C1,C2登录时即时服务IM验证用户名和密码，并登记各自的IP和PORT，并从服务器上拉取好友列表（包括好友的IP和PORT）给C1,C2。C1和C2通讯的方式有两种，一种是C1和C2之间采用TCP连接通讯。一种是C1和Server, C2和Server进行TCP连接，即使用Server中转通讯。<br>如果C1,C2都在内网，需要进行路由器进行NAT才能出去。使用STUN隧道技术，完成透明NAT，受限NAT，端口受限圆锥型NAT，对称型NAT（双向NAT，大公司使用）。<br>同时需要客户端给服务器发送心跳，如果没有响应，就断开长连接。还需要考虑重连机制、双向PingPong机制（ping对方，如果没有在约定的时间内返回就断开socket）、QOS机制（服务质量保证通讯延迟和阻塞）。<br>聊天协议：原生Socket(代表框架CocoAsyncSocket)、WebSocket(代表框架SocketRocket)、MQTT(代表框架MQTTKit)、XMPP(代表框架XMPPFramework)</p></blockquote></li></ol><h5 id="6-https的步骤"><a href="#6-https的步骤" class="headerlink" title="6. https的步骤"></a>6. https的步骤</h5><ol><li>client发送连接请求给server</li><li>server返回服务端证书给client</li><li>client通过浏览器内置根证书对服务端证书CA进行校验</li><li>client通过证书中的公钥加密对称密钥发送给server</li><li>双方通过对称密钥加密数据开始通信</li></ol><h5 id="7-ACCS-阿里云通道服务"><a href="#7-ACCS-阿里云通道服务" class="headerlink" title="7. ACCS(阿里云通道服务)"></a>7. ACCS(阿里云通道服务)</h5><h5 id="8-构建高性能的分布式系统"><a href="#8-构建高性能的分布式系统" class="headerlink" title="8. 构建高性能的分布式系统"></a>8. 构建高性能的分布式系统</h5><ol><li>分布式服务治理框架Dubbo</li><li>分布式消息中间件RocketMQ</li><li>数据库连接池Druid和JSON库Fastjson</li><li>云数据库Redis分支ApasaraCache</li><li>自研富容器技术Pouch和文件分发系统Dragonfly</li><li>开源数据看看AliSQL</li><li>分布式文件系统FastDFS</li><li>分布式数据库OceanBase</li><li>Web服务器Tengine</li><li>Redis缓存服务器AliRedis</li><li>分布式数据库同步系统otter</li><li>系统信息采集和监控工具Tsar</li><li>非侵入式运行期AOP框架Dexposed</li></ol><h5 id="9-互联网时代的用户端"><a href="#9-互联网时代的用户端" class="headerlink" title="9. 互联网时代的用户端"></a>9. 互联网时代的用户端</h5><ol><li>Ant Design，前端的美好呈现</li><li>企业级Web基础框架Egg</li><li>灵活的Android开发框架Atlas</li><li>跨平台移动开发工具Weex </li></ol><h5 id="10-源自最佳实践的参考规范"><a href="#10-源自最佳实践的参考规范" class="headerlink" title="10. 源自最佳实践的参考规范"></a>10. 源自最佳实践的参考规范</h5><ol><li>阿里巴巴Java开发规范</li><li>分布式消息领域的国际标准OpenMessaging</li></ol><h5 id="11-物联网时代"><a href="#11-物联网时代" class="headerlink" title="11. 物联网时代"></a>11. 物联网时代</h5><ol><li>新一代物联网操作系统AliOS Things</li><li>轻量化操作系统AliOS Lite</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-MySQL主从同步的实现方式&quot;&gt;&lt;a href=&quot;#1-MySQL主从同步的实现方式&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL主从同步的实现方式&quot;&gt;&lt;/a&gt;1. MySQL主从同步的实现方式&lt;/h5&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java程序性能优化</title>
    <link href="http://longman.kim/2018/07/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://longman.kim/2018/07/17/Java程序性能优化/</id>
    <published>2018-07-17T14:25:03.000Z</published>
    <updated>2018-07-17T14:25:03.362Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java架构师技术图谱</title>
    <link href="http://longman.kim/2018/07/17/Java%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <id>http://longman.kim/2018/07/17/Java架构师技术图谱/</id>
    <published>2018-07-16T16:23:31.000Z</published>
    <updated>2018-07-17T13:19:25.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1. 源码分析"></a>1. 源码分析</h3><h5 id="1-常用设计模式"><a href="#1-常用设计模式" class="headerlink" title="1. 常用设计模式"></a>1. 常用设计模式</h5><ol><li><p>Proxy代理模式</p><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问，例如Spring AOP。</p></blockquote></li><li><p>Factory工厂模式</p><blockquote><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，例如数据库访问。</p></blockquote></li><li><p>Singleton单例模式</p><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote></li></ol><ol start="4"><li><p>Delegate委派模式</p><blockquote></blockquote></li><li><p>Strategy策略模式</p><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换。</p></blockquote></li><li><p>Prototype原型模式</p><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote></li><li><p>Template模板模式</p><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote></li></ol><h5 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2. Spring"></a>2. Spring</h5><ol><li>Beans<blockquote><p>1 接口实例化<br>构造函数、静态工厂、实例工厂<br>BeanFactory getBean() -&gt; 默认构造函数 -&gt; 属性值注入 -&gt; 实现了InitializingBean接口调用afterPropertiesSet() -&gt; init-method</p></blockquote></li></ol><blockquote><p>2 代理Bean操作<br>JDK的Proxy代理类，CGLIB</p></blockquote><ol start="2"><li>Context<blockquote><p>1 IOC容器设计原理及高级特性<br>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。反射（reflection）允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p></blockquote></li></ol><blockquote><p>2 AOP设计原理<br>JDK的Proxy代理类，CGLIB</p></blockquote><blockquote><p>3 FactoryBean与BeanFactory<br>BeanFactory是IOC最基本的容器，负责生产和管理bean，例如DefaultListableBeanFactory。<br>FactoryBean是一个接口，当容器实现了FactoryBean之后，通过getBean获取到的Bean对象，是实现类中的getObject方法返回的对象。</p></blockquote><ol start="3"><li>Transaction<blockquote><p>1 声明式事务底层原理<br>@Transaction注解，传播行为，隔离级别，是否只读，事务超时，回滚规则。事务管理的切面属于<a href="aop:around" target="_blank" rel="noopener">aop:around</a>即AOP环绕类型的切面。</p></blockquote></li></ol><blockquote><p>2 Spring事务处理机制</p></blockquote><blockquote><p>3 事务的传播与监控<br>PROPAGATION_REQUIRED<br>默认传播机制，支持当前事务，如果没有，则新建一个事务。<br>PROPAGATION_REQUIRED_NEW<br>新建事务，如果当前存在事务，把当前事务挂起。新建的事务与被挂起的事务没有任何关系，是独立的两个事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作。<br>PROPAGATION_SUPPORTS<br>支持当前事务，如果没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY<br>支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_NOT_SUPPORTED<br>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER<br>以非事务方式执行操作，如果当前存在事务，则抛出异常。<br>PROPAGATION_NESTED<br>如果一个事务存在，则运行在一个嵌套的事务中。</p></blockquote><blockquote><p>4 基于Springjdbc手写orm框架</p></blockquote><ol start="4"><li>MVC<blockquote><p>1 MVC原理<br>模型，视图，控制器。</p></blockquote></li></ol><blockquote><p>2 与IOC容器整合的原理</p></blockquote><blockquote><p>3 HandlerMapping实现原理<br>负责定位</p></blockquote><blockquote><p>4 HandlerAdapter实现原理<br>负责调用</p></blockquote><blockquote><p>5 ViewResolver实现原理<br>视图解析</p></blockquote><blockquote><p>6 Controller调用原理</p></blockquote><blockquote><p>7 动态参数匹配原理</p></blockquote><blockquote><p>8 手写实现SpringMVC框架<br>请求-&gt;DispatcherServlet-&gt;处理器映射-&gt;控制器-&gt;模式及逻辑视图名-&gt;视图解析器-&gt;视图-&gt;响应</p></blockquote><h5 id="3-Mybatis"><a href="#3-Mybatis" class="headerlink" title="3. Mybatis"></a>3. Mybatis</h5><ol><li>代码自动生成器：Generator</li><li><p>Mybatis下1对多、多对多嵌套结果、嵌套查询</p></li><li><p>一级缓存、二级缓存使用场景及选择策略</p><blockquote><p>在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认开启一级缓存。二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存。二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个Mapper的二级缓存区域。</p></blockquote></li><li><p>Mybatis与Spring集成Spring-Mybatis分析</p></li><li><p>Spring集成下的SqlSession与Mapper</p></li><li><p>Mybatis的事务</p></li><li><p>分析Mybatis的动态代理的真正实现</p></li><li><p>一步一步手写实现Mybatis1.0到2.0</p></li></ol><p>###2. 并发编程</p><h5 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h5><ol><li>线程通信<blockquote><ol><li>共享内存<br>线程之间通过写-读内存中的公共状态  </li><li>消息传递</li></ol></blockquote></li></ol><h5 id="2-内存模型"><a href="#2-内存模型" class="headerlink" title="2. 内存模型"></a>2. 内存模型</h5><ol><li><p>重排序</p><blockquote><ol><li>编译器优化的重排序</li><li>处理器重排序，指令级并行技术ILP</li><li>内存系统的重排序</li></ol></blockquote></li><li><p>顺序一致性</p></li></ol><ol start="3"><li><p>Happen-Before</p><blockquote><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p></blockquote></li><li><p>As-If-Serial</p><blockquote><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会改变。</p></blockquote></li></ol><h5 id="3-Synchronized"><a href="#3-Synchronized" class="headerlink" title="3. Synchronized"></a>3. Synchronized</h5><ol><li>同步、重量级锁</li><li>Syncronized原理</li><li>锁优化<blockquote><ol><li>自旋锁</li><li>轻量级锁</li><li>重量级锁</li><li>偏向锁</li></ol></blockquote></li></ol><h5 id="4-Volatile"><a href="#4-Volatile" class="headerlink" title="4. Volatile"></a>4. Volatile</h5><ol><li>Volatile实现机制</li><li>内存语义</li><li>内存模型</li></ol><h5 id="5-DCL"><a href="#5-DCL" class="headerlink" title="5. DCL"></a>5. DCL</h5><ol><li>单例模式</li><li>DCL</li><li>解决方案</li></ol><h5 id="6-并发基础"><a href="#6-并发基础" class="headerlink" title="6. 并发基础"></a>6. 并发基础</h5><ol><li><p>AQS</p><blockquote><ol><li>AbstractQueuedSyncronizer同步器</li><li>CLH同步队列</li><li>同步状态的获取与释放</li><li>线程阻塞与唤醒</li></ol></blockquote></li><li><p>CAS</p><blockquote><ol><li>Compare And Swap</li><li>缺陷</li></ol></blockquote></li></ol><h5 id="7-锁"><a href="#7-锁" class="headerlink" title="7. 锁"></a>7. 锁</h5><ol><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>Condition</li></ol><h5 id="8-并发工具类"><a href="#8-并发工具类" class="headerlink" title="8. 并发工具类"></a>8. 并发工具类</h5><ol><li>CyclicBarrier</li><li>CountdownLatch</li><li>Semphore</li></ol><h5 id="9-并发集合"><a href="#9-并发集合" class="headerlink" title="9. 并发集合"></a>9. 并发集合</h5><ol><li>ConcurrentHashMap</li><li>ConcurrentLinkedQueue</li></ol><h5 id="10-原子操作"><a href="#10-原子操作" class="headerlink" title="10. 原子操作"></a>10. 原子操作</h5><ol><li><p>基本类型</p><blockquote><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ol></blockquote></li><li><p>数组</p><blockquote><ol><li>AtomicIntegerArrary</li><li>AtomicLongArrary</li><li>AtomicReferenceArrary</li></ol></blockquote></li><li><p>引用类型</p><blockquote><ol><li>AtomicReference</li><li>AtomicReferenceFieldUpdater</li></ol></blockquote></li></ol><h5 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11. 线程池"></a>11. 线程池</h5><ol><li>Executor</li><li>ThreadPoolExecutor</li><li>Callable和Future</li><li>ScheduledExecutorService</li></ol><h5 id="12-其他"><a href="#12-其他" class="headerlink" title="12. 其他"></a>12. 其他</h5><ol><li>ThreadLocal</li><li>Fork/Join</li></ol><p>###3. 性能调优</p><p>###4. 分布式架构</p><h5 id="1-漫谈分布式架构"><a href="#1-漫谈分布式架构" class="headerlink" title="1. 漫谈分布式架构"></a>1. 漫谈分布式架构</h5><ol><li>初识分布式架构及意义</li><li>如何把应用从单机扩展到分布式</li><li><p>构建分布式架构最重要因素</p><blockquote><ol><li>CDN加速静态文件访问</li><li>分布式存储</li><li>分布式搜索引擎</li><li>应用发布与监控</li><li>应用容灾及机房规划</li><li>系统动态扩容</li></ol></blockquote></li><li><p>分布式架构设计</p><blockquote><ol><li>主流架构模型-SOA架构与微服务架构</li><li>领域驱动设计及业务驱动划分</li><li>分布式架构的基本理论CAP,BASE及其应用</li><li>什么是分布式架构下的高可用设计</li><li>分布式架构下的可伸缩设计</li><li>构建高性能的分布式架构</li></ol></blockquote></li></ol><h5 id="2-分布式架构策略-分而治之"><a href="#2-分布式架构策略-分而治之" class="headerlink" title="2. 分布式架构策略-分而治之"></a>2. 分布式架构策略-分而治之</h5><ol><li>从简到难，从网络通信探究分布式通信的原理</li><li>基于消息方式的系统间通信</li><li>理解通信协议传输过程中的序列化与反序列化机制</li><li><p>基于框架的RPC通信技术</p><blockquote><ol><li>Webservice/Apache Cxf</li><li>RMI/Spring RMI</li><li>Hessian</li></ol></blockquote></li><li><p>传统RPC技术在大型分布式架构下面临的问题</p></li><li>分布式架构下的RPC解决方案</li><li><p>分布式系统的基石-Zookeeper</p><blockquote><ol><li>从0开始搭建3个节点的Zookeeper集群</li><li>深入分析Zookeeper在Discon配置中心的应用</li><li>基于Zookeeper的分布式锁解决方案</li><li>Zookeeper集群升级、迁移</li><li>基于Zookeeper实现分布式服务器动态上线感知</li><li>深入分析Zookeeper ZAB协议及选举机制源码解读</li></ol></blockquote></li><li><p>使用Dubbo对单一应用服务改造</p><blockquote><ol><li>Dubbo管理中心及监控平台安装部署</li><li>Dubbo分布式服务模块划分（领域驱动）</li><li>基于Dubbo的分布式系统架构实战</li><li>Dubbo负载均衡策略分析</li><li>Dubbo服务调试之服务只订阅及服务只注册配置</li><li>Dubbo服务接口的设计原则（实战经验分享）</li><li>Dubbo设计原理及源码分析</li><li>基于Dubbo构建大型分布式电商平台实战雏形</li><li>Dubbo容器机制及高扩展分析</li></ol></blockquote></li></ol><h5 id="3-分布式架构-中间件"><a href="#3-分布式架构-中间件" class="headerlink" title="3. 分布式架构-中间件"></a>3. 分布式架构-中间件</h5><ol><li><p>分布式消息通信</p><blockquote><ol><li>消息中间件在分布式架构中的作用</li><li>ActiveMQ高可用集群企业级部署方案</li><li>ActiveMQ P2P及Pub/Sub模型详解</li><li>ActiveMQ消息确认及重发策略</li><li>ActiveMQ基于Spring完全分布式消息队列实战</li><li>Kafka基于Zookeeper搭建高可用集群实战</li><li>Kafka消息处理过程剖析</li><li>Java客户端实现Kafka生产者与消费者实例</li><li>Kafka的副本机制及选举原理剖析</li><li>基于Kafka实现应用日志实时上报统计分析</li><li>初步认识RabbitMQ及高可用集群部署</li><li>了解RabbitMQ消息分发机制及主题消息分发</li><li>RabbitMQ消息路由机制分析</li><li>RabbitMQ消息确认机制</li></ol></blockquote></li><li><p>分布式缓存</p><blockquote><ol><li>从入门到精通，Redis的数据结构分析</li><li>Redis主从复制原理及无磁盘复制分析</li><li>Redis管道模式详解</li><li>Redis缓存与数据库一致性问题解决方案</li><li>基于Redis实现分布式锁实战</li><li>图解Redis中aof和rdb持久化策略的原理</li><li>Redis读写分离架构实践</li><li>Redis哨兵架构及数据丢失问题分析</li><li>Redis Cluster数据分布算法之Hash Slot</li><li>Redis使用常见问题及性能优化思路</li><li>Redis高可用及高伸缩架构实战</li><li>缓存击穿、缓存雪崩预防策略</li><li>Redis批量查询优化</li><li>Redis高性能集群之Twemproxy or Codis</li></ol></blockquote></li></ol><ol start="3"><li>数据存储<blockquote><ol><li>NoSQL简介及Mongodb基本概念</li><li>Mongodb支持的数据类型分析</li><li>Mongodb可视化客户端及Java API实践</li><li>手写基于Mongodb的orm框架</li><li>Mongodb企业级集群解决方案</li><li>Mongodb聚合、索引及基本执行命令</li><li>Mongodb数据分片、转存及恢复策略</li><li>MySQL主从复制及读写分离</li><li>MySQL+Keepalived实现双主高可用方案实践</li><li>MySQL高性能解决方案之分库分表</li><li>数据库中间件初识Mycat</li><li>基于Mycat实现MySQL数据库读写分离</li><li>基于Mycat实战之数据库切分策略剖析</li><li>Mycat全局表、E表、分片策略分析</li></ol></blockquote></li></ol><ol start="4"><li>后台服务<blockquote><ol><li>基于Openretry部署应用层Nginx以及Nginx+Lua实践</li><li>Nginx反向代理服务器及负载均衡服务配置实战</li><li>利用Keepalived+Nginx实践Nginx高可用方案</li><li>基于Nginx实现访问控制、连接限制</li><li>Nginx动静分离实战</li><li>Nginx Location，Rewrite等语法配置及原理分析</li><li>Nginx提供Https服务</li><li>基于Nginx+Lua完成访问流量实时上报Kafka的实战</li></ol></blockquote></li></ol><ol start="5"><li>高性能NIO框架<blockquote><ol><li>IO的基本概念、NIO、AIO、BIO深入分析</li><li>NIO的核心设计思想</li><li>Netty产生的背景及应用场景分析</li><li>基于Netty实现高性能lm聊天</li><li>基于Netty实现Dubbo多协议通信支持</li><li>Netty无锁串行化及高并发处理机制</li><li>手写实现多协议RPC框架</li></ol></blockquote></li></ol><h5 id="4-分布式解决方案"><a href="#4-分布式解决方案" class="headerlink" title="4. 分布式解决方案"></a>4. 分布式解决方案</h5><ol><li>分布式全局ID生成方案</li><li>Session跨域共享及企业级单点登录解决方案实战</li><li>分布式事务解决方案实战</li><li>高并发下的服务降级、限流实战</li><li>基于分布式架构下分布式锁的解决方案实战</li><li>分布式架构下实现分布式定时调度</li></ol><p>###5. 微服务架构</p><h5 id="1-微框架"><a href="#1-微框架" class="headerlink" title="1. 微框架"></a>1. 微框架</h5><ol><li>Spring Boot与微服务之间的关系</li><li>Spring Boot热部署实战</li><li>核心组件之Starter、Actuator、Auto-Configuration、Cli</li><li>Spring Boot集成Mybatis实现多数据源路由实战</li><li>Spring Boot集成Dubbo实战</li><li>Spring Boot集成Redis实战</li><li>Spring Boot集成Swagger2构建API管理及测试体系</li><li>Spring Boot实现多环境配置动态解析</li></ol><h5 id="2-SpringCloud"><a href="#2-SpringCloud" class="headerlink" title="2. SpringCloud"></a>2. SpringCloud</h5><ol><li>Eureka注册中心</li><li>Ribbon集成Rest实现负载均衡</li><li>Fegion声明式服务调用</li><li>Hystrix服务熔断降级方式</li><li>Zuul实现微服务网关</li><li>Config分布式统一配置中心</li><li>Sleuth调用链路跟踪</li><li>Blus消息总线</li><li>基于Hystrix实现接口降级实战</li><li>Spring Boot集成Spring Cloud实现统一整合方案</li></ol><h5 id="3-Docker虚拟化"><a href="#3-Docker虚拟化" class="headerlink" title="3. Docker虚拟化"></a>3. Docker虚拟化</h5><ol><li>了解Docker的镜像、仓库、容器</li><li>Dockerfile构建lnmp环境部署个人博客wordpress</li><li>Docker Compose构建lnmp环境部署个人博客wordpress</li><li>Docker网络组成、路由互联、Openvswitch</li><li>基于Swarm构建Docker集群实战</li><li>Kubernetes简介</li></ol><h5 id="4-漫谈微服务架构"><a href="#4-漫谈微服务架构" class="headerlink" title="4. 漫谈微服务架构"></a>4. 漫谈微服务架构</h5><ol><li>SOA架构和微服务架构之间的区别和联系</li><li>如何设计微服务及其设计原则</li><li>解惑Spring Boot流行因素及能够解决什么问题</li><li>什么事Spring Cloud，为何选择Spring Cloud</li><li>基于全局分析Spring Cloud各个组件所解决的问题</li></ol><p>###6. 电商项目实战</p><h5 id="1-用户认证系统（Passport）"><a href="#1-用户认证系统（Passport）" class="headerlink" title="1. 用户认证系统（Passport）"></a>1. 用户认证系统（Passport）</h5><ol><li><p>用户注册</p></li><li><p>用户登录</p><blockquote><ol><li>Sso单点登录</li><li>第三方登录</li></ol></blockquote></li><li><p>用户权限控制</p><blockquote><ol><li>UI页面拦截</li><li>业务方法拦截</li></ol></blockquote></li></ol><h5 id="2-搜索模块（大数据）"><a href="#2-搜索模块（大数据）" class="headerlink" title="2. 搜索模块（大数据）"></a>2. 搜索模块（大数据）</h5><h5 id="3-商品管理系统（Item）"><a href="#3-商品管理系统（Item）" class="headerlink" title="3. 商品管理系统（Item）"></a>3. 商品管理系统（Item）</h5><h5 id="4-订单系统（Order）"><a href="#4-订单系统（Order）" class="headerlink" title="4. 订单系统（Order）"></a>4. 订单系统（Order）</h5><h5 id="5-支付系统（Pay）"><a href="#5-支付系统（Pay）" class="headerlink" title="5. 支付系统（Pay）"></a>5. 支付系统（Pay）</h5><h5 id="6-数据统计分析系统（Anal）"><a href="#6-数据统计分析系统（Anal）" class="headerlink" title="6. 数据统计分析系统（Anal）"></a>6. 数据统计分析系统（Anal）</h5><h5 id="7-通知推送系统"><a href="#7-通知推送系统" class="headerlink" title="7. 通知推送系统"></a>7. 通知推送系统</h5><ol><li><p>融云推送</p><blockquote><ol><li>活动推送</li><li>交易信息推送</li><li>异常提醒</li></ol></blockquote></li><li><p>消息中间件</p><blockquote><ol><li>消息同步</li><li>消息处理</li></ol></blockquote></li></ol><h5 id="8-聊天系统"><a href="#8-聊天系统" class="headerlink" title="8. 聊天系统"></a>8. 聊天系统</h5><ol><li>用户群聊</li><li>点对点聊天</li><li>文件断点续传</li></ol><p>###7. 团队协作效率</p><h5 id="1-Maven-Gradle"><a href="#1-Maven-Gradle" class="headerlink" title="1. Maven/Gradle"></a>1. Maven/Gradle</h5><h5 id="2-Jenkins"><a href="#2-Jenkins" class="headerlink" title="2. Jenkins"></a>2. Jenkins</h5><h5 id="3-Sonar"><a href="#3-Sonar" class="headerlink" title="3. Sonar"></a>3. Sonar</h5><h5 id="4-Git"><a href="#4-Git" class="headerlink" title="4. Git"></a>4. Git</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-源码分析&quot;&gt;&lt;a href=&quot;#1-源码分析&quot; class=&quot;headerlink&quot; title=&quot;1. 源码分析&quot;&gt;&lt;/a&gt;1. 源码分析&lt;/h3&gt;&lt;h5 id=&quot;1-常用设计模式&quot;&gt;&lt;a href=&quot;#1-常用设计模式&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从Paxos到Zookeeper分布式一致性原理与实践</title>
    <link href="http://longman.kim/2018/07/15/%E4%BB%8EPaxos%E5%88%B0Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://longman.kim/2018/07/15/从Paxos到Zookeeper分布式一致性原理与实践/</id>
    <published>2018-07-15T10:27:30.000Z</published>
    <updated>2018-07-16T16:22:28.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式架构"><a href="#1-分布式架构" class="headerlink" title="1. 分布式架构"></a>1. 分布式架构</h3><ol><li>从集中式到分布式<blockquote><ol><li>集中式的特点<br>IBM的System/360系列大型主机是集中式计算机系统架构的代表，部署结构简单，单机性能卓越。  </li><li>分布式的特点<br>分布性，多台计算机在空间上随意分布，且机器的分布情况也会随时变动。<br>对等性，计算机之间没有主从之分，都是对等的。副本是分布式系统对数据和服务提供的一种冗余方式，数据副本解决数据丢失问题，服务副本使每个节点都能处理请求。<br>并发性，并发操作共享资源。缺乏全局时钟，很难定义两个事件究竟谁先谁后。故障总是会发生，一条黄金定理是设计时考虑到的异常情况一定会发生。    </li><li>分布式环境的各种问题<br>通信异常，网络光纤、路由器和DNS等硬件设备不可用导致通信异常，系统之间存在延时等。<br>网络分区，分布式系统中只有部分节点能够正常通信，而另一些节点不能，俗称脑裂，存在分布式一致性问题。<br>三态，成功、失败与超时，其中超时情况下无法确定请求是否成功。<br>节点故障，组成分布式系统的服务器节点出现的宕机或者僵死现象。</li></ol></blockquote></li></ol><ol start="2"><li>从ACID到CAP/BASE  <blockquote><ol><li>ACID<br>事务的四个特性。原子性，要么全部成功执行，要么全部不执行。一致性，数据库必须从一个一致性状态转变到另一个一致性状态，不存在事务对数据库的修改一部分已写入另一部没有。隔离性，并发的事务不能相互干扰。持久性，即事务一旦提交，对数据库中对于数据的状态变更就应该是永久性的。</li><li>事务的隔离性<br>未授权读取，最低级别，允许脏读。A事务对数据做了一系列修改但未提交，B事务可以看到数据这一系列的中间值。<br>授权读取，与未授权读取的区别是只允许获取已经被提交的数据，授权读取允许不可重复读。<br>可重复读取，保证在事务的处理过程中，多次读取同一个数据，其值都和事务开始时刻一致的，禁止了不可重复读取(一个事务中多次读取的数据不一样)和脏读（提交前读取，读取后发生回滚），但会出现幻读（读取之后另个一事务插入了新数据）。<br>串行化，要求所有的事务都被串行化执行，不能并发。<br>一般的做法是设置成授权读取，加上乐观锁或者悲观锁。    </li><li>分布式事务<br>事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。  </li><li>CAP和BASE理论<br>CAP理论告诉我们一个分布式系统不可能同时满足一致性（所有的数据都能都得到最新的值）、可用性（在有限时间内返回结果）和分区容错性（任何网络分区有故障仍然能提供一致性和可用性服务），最多只能同时满足其中的两项，其中分区容错性是必须保证的，只需要在一致性和可用性之间寻求平衡。<br>BASE，基本可用（损失部分功能，损失响应时间），弱状态（存在中间状态），最终一致性（经过一段时间后数据一致）。最终一致性的5类变体，因果一致性、读己之所写、会话一致性、单调读一致性、单调写一致性。</li></ol></blockquote></li></ol><h3 id="2-一致性协议"><a href="#2-一致性协议" class="headerlink" title="2. 一致性协议"></a>2. 一致性协议</h3><ol><li><p>2PC与3PC</p><blockquote><ol><li>2PC<br>提交事务请求，事务询问-&gt;执行事务-&gt;各参与者向协调者反馈事务询问的响应<br>执行事务提交，发送提交请求-&gt;事务提交-&gt;反馈事务提交结果-&gt;完成事务，发送回滚请求-&gt;事务回滚-&gt;反馈事务回滚结果-&gt;中断事务<br>原理简单，实现方便。同步阻塞，协调者的单点问题，脑裂，太过保守。  </li><li>3PC<br>阶段一CanCommit，事务询问-&gt;各参与者向协调者反馈事务询问的响应<br>阶段二PreCommit，执行事务预提交，发送预提交请求-&gt;事务预提交-&gt;各参与者向协调者反馈事务执行的响应。中断事务，发送中断请求-&gt;中断事务<br>阶段三doCommit，执行提交，发送提交请求-&gt;事务提交-&gt;反馈事务提交结果-&gt;完成事务。中断事务，发送中断请求-&gt;事务回滚-&gt;反馈事务回滚结果-&gt;中断事务。<br>存在数据不一致情况</li></ol></blockquote></li><li><p>Paxos算法</p><blockquote><ol><li>假设不存在拜占庭将军问题，即消息都是完整的，没有被篡改，在这种情况下提出了Paxos算法。Paxos小岛采用议会的形式通过法令，通过信使传递消息。  </li><li>问题描述，提案的选定，推导过程，数学归纳法证明，Proposer生成提案，Acceptor批准提案，算法优化，算法陈述</li></ol></blockquote></li></ol><h3 id="3-Paxos的工程实践"><a href="#3-Paxos的工程实践" class="headerlink" title="3. Paxos的工程实践"></a>3. Paxos的工程实践</h3><ol><li>Chubby</li><li>Hypertable</li></ol><h3 id="4-Zookeeper与Paxos"><a href="#4-Zookeeper与Paxos" class="headerlink" title="4. Zookeeper与Paxos"></a>4. Zookeeper与Paxos</h3><ol><li>初识Zookeeper</li><li>Zookeeper的ZAB协议</li></ol><h3 id="5-使用Zookeeper"><a href="#5-使用Zookeeper" class="headerlink" title="5. 使用Zookeeper"></a>5. 使用Zookeeper</h3><h3 id="6-Zookeeper的典型应用场景"><a href="#6-Zookeeper的典型应用场景" class="headerlink" title="6. Zookeeper的典型应用场景"></a>6. Zookeeper的典型应用场景</h3><h3 id="7-Zookeeper技术内幕"><a href="#7-Zookeeper技术内幕" class="headerlink" title="7. Zookeeper技术内幕"></a>7. Zookeeper技术内幕</h3><ol><li>系统模型  </li><li>序列化与协议</li><li>客户端</li><li>会话</li><li>服务器启动</li><li>Leader选举<blockquote><ol><li>Leader  </li><li>Follower  </li><li>Observer  </li><li>集群间消息通信  </li></ol></blockquote></li><li>各服务器角色介绍</li><li>请求处理</li><li>数据与存储</li></ol><h3 id="8-Zookeeper运维"><a href="#8-Zookeeper运维" class="headerlink" title="8. Zookeeper运维"></a>8. Zookeeper运维</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式架构&quot;&gt;&lt;a href=&quot;#1-分布式架构&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式架构&quot;&gt;&lt;/a&gt;1. 分布式架构&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;从集中式到分布式&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;集中式的特点&lt;br&gt;IB
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机行业职业发展路线的一些思考</title>
    <link href="http://longman.kim/2018/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://longman.kim/2018/07/15/计算机行业职业发展路线的一些思考/</id>
    <published>2018-07-15T01:54:54.000Z</published>
    <updated>2018-07-15T09:02:04.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>想想自己在计算机行业待了快9年了（本科4年，研究生3年，工作2年），对这个行业却只能说是初步了解。读书期间很抵触做网站，但自己却一个网站都没有搭起来过。那时候很崇拜算法，但没有深入学习，算法也是普通人的水平。现在我工作2年了，从事网站后台开发，却依然是菜鸟级别。技术水平菜，为人处世又不成熟，所以过得让自己不开心，也让身边的人不开心。自命清高，眼高手低，也许说的就是我这种人吧。努力想改变这种状态，却依然在网络上寻找灵丹妙药。其实网上有很多建议，但可能只针对部分人有用，因为每个人自身的情况，所处的环境都不相同。小人常立志，圣人立长志，这句话是从亲人身上学到的。人应该有个目标，然后有自制力的执行自己的目标。有志者，事竟成，破釜沉舟，百二秦关终属楚，苦心人，天不负，卧薪尝胆，三千越甲可吞吴。</p><h3 id="2-行业的预见"><a href="#2-行业的预见" class="headerlink" title="2. 行业的预见"></a>2. 行业的预见</h3><p>我预见计算机行业未来将只会存在设计师、全栈开发工程师、算法工程师、硬件工程师。  </p><ol><li><strong><em>设计师</em></strong><br>人，希望自己独一无二，希望自己美丽漂亮。对美的追求植根于所有人的心中，设计师是将思想化为现实的桥梁，他们需要灵感。设计师就是艺术家，艺术家是为了洗涤人的精神世界，无形而威力巨大。  </li><li><strong><em>全栈开发</em></strong><br>随着技术的不断发展，网站开发的需求量会逐渐减少。到最后，会被云计算公司，类似于亚马逊、微软、阿里巴巴这样的公司所垄断。普通的前端后端开发工程师将会非常被动，因为普通公司的网站都交给那些大型巨头做了，中小型公司不需要自己的IT部门。以后对于普通网站开发的需求，应该是中大型公司，他们要求全栈开发并且对某个行业业务深入了解的人，即会IT技能的业务专家。  </li><li><strong><em>算法工程师</em></strong><br>程序=算法+数据结构，算法是计算机的精髓。从通用的算法（排序，查找等），到AI算法（推荐、学习），算法一直阐述着计算机科学的未来发展之路。  </li><li><strong><em>硬件工程师</em></strong><br>软硬结合，传感器，物联网。从芯片，到外围电路，未来是软硬结合的世界。</li></ol><h3 id="3-个人的发展之路"><a href="#3-个人的发展之路" class="headerlink" title="3. 个人的发展之路"></a>3. 个人的发展之路</h3><ol><li>初级开发工程师  </li><li>中级开发工程师</li><li>高级开发工程师  </li><li>组长  </li><li>室经理  </li><li>部门经理</li><li>CTO  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;想想自己在计算机行业待了快9年了（本科4年，研究生3年，工作2年），对这个行业却只能说是初步了解。读书期间很抵触做网站，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>国内主流互联网公司的RPC和MOM</title>
    <link href="http://longman.kim/2018/07/12/%E5%9B%BD%E5%86%85%E4%B8%BB%E6%B5%81%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84RPC%E5%92%8CMOM/"/>
    <id>http://longman.kim/2018/07/12/国内主流互联网公司的RPC和MOM/</id>
    <published>2018-07-12T09:48:59.000Z</published>
    <updated>2018-07-23T12:14:16.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-RPC服务框架"><a href="#1-RPC服务框架" class="headerlink" title="1. RPC服务框架"></a>1. RPC服务框架</h3><ol><li><p>Dubbo(阿里)</p><blockquote><ol><li>架构<br>Provider(Container), Conumer, Registry, Monitor</li><li>通讯协议<br>2.1 dubbo的特性是连接个数单连接，连接方式长连接，传输协议TCP，传输方式NIO异步通讯，序列化Hessian二进制序列化，适用范围数据包小，消费者比提供者个数多，dubbo不适合传输大数据量的服务。<br>2.2 rmi的特性是多连接，短连接，TCP，同步传输，Java标准二进制序列化，数据包大小混合，消费者和提供者个数差不多。<br>2.3 hessian的特性是多连接，短连接，http，同步传输，hessian二进制序列化，数据包较大，提供者比消费者个数多，可传文件。<br>2.4 http的特性是多连接，短连接，http，同步传输，表单序列化，数据包大小混合，提供者比消费者个数多，不支持传文件。<br>2.5 webservice的特性是多连接，短连接，http，同步传输，SOAP文本序列化。<br>2.6 其他协议thrift、memcached、redis、rest</li><li>注册中心<br>3.1 Zookeeper,临时节点原理<br>3.2 Multicast<br>3.3 Redis<br>3.4 Simple</li><li>集群容错<br>4.1 FailOver<br>读操作的默认方式，失败自动切换，重试其他服务。<br>4.2 FailFast<br>写操作的默认方法，快速失败，只发起一次调用，失败立即报错。<br>4.3 FailBack<br>消息通知，失败自动恢复，记录失败请求，定时重发。<br>4.4 Forking<br>并行调用多个服务器，只要一个成功即可。<br>4.5 Broadcast<br>广播调用所有提供者，任意一台报错则报错。<br>4.6 Failsafe<br>失败安全，出现异常时，直接忽略，常用在写审计日志。</li><li>其他特点<br>5.1 使用微内核+插件技术，利用SPI(ServiceProviderInterface)技术+策略模式，使得Dubbo扩展性极强。<br>5.2 常用配置<br>dubbo:application, dubbo:registry, dubbo:protocol, dubbo:service, dubbo:reference  </li><li>启动流程<br>6.1 服务容器负责启动，加载，运行服务提供者。<br>6.2 服务提供者在启动时，向注册中心注册自己提供的服务。<br>6.3 服务消费者在启动时，向注册中心订阅自己所需的服务。<br>6.4 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>6.5 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者调用，如果调用失败，再选另一台。<br>6.6 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发一次统计数据到监控中心。  </li></ol></blockquote></li><li><p>HSF(阿里)</p></li><li>pigeon(美团点评)</li><li>rdsn(小米)</li><li>motan(微博)</li><li>gRPC(谷歌)</li><li>thrift(脸书)</li><li>tars(腾讯)</li><li>brpc(百度)</li><li>SpringCloud</li></ol><h3 id="2-MOM消息中间件"><a href="#2-MOM消息中间件" class="headerlink" title="2. MOM消息中间件"></a>2. MOM消息中间件</h3><ol><li><p>RocketMQ(阿里)</p><blockquote><ol><li></li></ol></blockquote></li><li><p>QService(微博)</p></li><li>Kafka</li><li><p>RabbitMQ</p><blockquote><ol><li></li></ol></blockquote></li><li><p>ActiveMQ</p></li><li>ZeroMQ</li><li>Redis</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-RPC服务框架&quot;&gt;&lt;a href=&quot;#1-RPC服务框架&quot; class=&quot;headerlink&quot; title=&quot;1. RPC服务框架&quot;&gt;&lt;/a&gt;1. RPC服务框架&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Dubbo(阿里)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站技术架构-核心原理与案例分析</title>
    <link href="http://longman.kim/2018/07/11/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://longman.kim/2018/07/11/大型网站技术架构-核心原理与案例分析/</id>
    <published>2018-07-11T12:02:57.000Z</published>
    <updated>2018-07-13T04:17:49.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-大型网站架构演进"><a href="#1-大型网站架构演进" class="headerlink" title="1. 大型网站架构演进"></a>1. 大型网站架构演进</h3><ol><li><p>大型网站软件系统的特点</p><blockquote><p>高并发，大流量，高可用，海量数据，用户分布广泛，网络情况复杂，安全环境恶劣，需求快速变更，发布频繁，渐进式发展  </p></blockquote></li><li><p>大型网站架构演化发展历程</p><blockquote><ol><li>初始阶段<br>LAMP单机</li><li>应用服务和数据服务分离  </li><li>使用缓存改善网站性能  </li><li>使用应用服务器集群改善网站的并发处理能力</li><li>数据库读写分离</li><li>使用反向代理和CDN加速网站响应  </li><li>使用分布式文件系统和分布式数据库系统</li><li>使用NoSQL和搜索引擎</li><li>业务拆分</li><li>分布式服务</li></ol></blockquote></li><li><p>大型网站架构演化的价值观</p><blockquote><ol><li>网站所需灵活应对</li><li>业务发展是驱动力</li></ol></blockquote></li><li><p>网站架构设计误区</p><blockquote><ol><li>一味追求大公司的解决方案</li><li>为了技术而技术</li><li>企图用技术解决所有问题</li></ol></blockquote></li></ol><h3 id="2-大型网站结构模式"><a href="#2-大型网站结构模式" class="headerlink" title="2. 大型网站结构模式"></a>2. 大型网站结构模式</h3><ol><li><p>网站架构模式</p><blockquote><ol><li>分层<br>应用层，服务层，数据层  </li><li>分割  </li><li>分布式<br>分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算，分布式配置，分布式锁，分布式文件系统</li><li>集群</li><li>缓存<br>CDN，反向代理，本地缓存，分布式缓存</li><li>异步<br>解耦，异步模式，生产者消费者，提高可用性，加快响应速度，消除并发访问高峰</li><li>冗余<br>冷备份，热备份，灾备数据中心</li><li>自动化<br>发布过程自动化，自动化代码管理，自动化测试，自动化安全检测，自动化部署，自动化监控，自动化报警，自动化失效转移，自动化失效恢复，自动化降级，自动化资源分配</li><li>安全<br>密码，手机校验码，加密，XSS攻击，SQL注入，信息过滤，风险控制</li></ol></blockquote></li><li><p>架构模式在新浪微博的应用</p><blockquote><ol><li>LAMP</li><li>基础服务层：数据库，缓存，存储，搜索</li><li>平台服务和应用服务</li><li>API和业务层</li><li>分布式部署，集群，异步推拉结合，多级缓存，冗余，自动化，安全</li></ol></blockquote></li></ol><h3 id="3-大型网站核心架构要素"><a href="#3-大型网站核心架构要素" class="headerlink" title="3. 大型网站核心架构要素"></a>3. 大型网站核心架构要素</h3><p>最高层次的规划，难以改变的决定</p><ol><li>性能<blockquote><ol><li>浏览器端，浏览器缓存，页面压缩，合理布局，减少cookie传输</li><li>CDN，动静分离，部署反向代理，缓存热点文件</li><li>服务端，本地缓存，分布式缓存，异步消息队列，集群，多线程，改善内存管理</li><li>数据库，索引，缓存，SQL优化，NoSQL</li><li>响应时间，TPS</li></ol></blockquote></li><li>可用性<blockquote><ol><li>7*24小时可用，4个9即99.99%可用</li><li>主要是手段是冗余</li><li>应用服务器，负载均衡，集群</li><li>存储服务器，实时备份</li></ol></blockquote></li><li>伸缩性<blockquote><ol><li>应用服务器用合适的负载均衡器向集群中加机器</li><li>缓存服务器，改进缓存路由算法，保证缓存的可访问性</li><li>关系数据库支持数据复制，主从热备等机制，但很难保证大规模的伸缩性。主要通过路由分区将多个数据库的服务器组成一个集群。NoSQL比较好扩展。</li></ol></blockquote></li><li>扩展性<blockquote><p>如何设计网站的架构使其能够快速响应需求的变化。</p><ol><li>事件驱动架构<br>消息队列</li><li>分布式服务<br>将业务和可复用服务分离，通过分布式服务框架调用。</li></ol></blockquote></li><li>安全性<blockquote><p>保护数据</p></blockquote></li></ol><h3 id="4-瞬时响应：网站的高性能架构"><a href="#4-瞬时响应：网站的高性能架构" class="headerlink" title="4. 瞬时响应：网站的高性能架构"></a>4. 瞬时响应：网站的高性能架构</h3><ol><li>网站性能测试<blockquote><ol><li>响应时间，请求开始到收到响应所需的时间</li><li>并发数，系统能够同时处理请求的数目</li><li>吞吐量，TPS（每秒事务数），QPS（每秒查询数），HPS（每秒HTTP请求数）</li><li>性能技术器<br>系统负载，对象与线程数，内存使用，CPU使用，磁盘与网络I/O</li><li>性能测试方法<br>性能测试，负载测试（直到处理能力下降），压力测试（直到系统崩溃或不能处理任何请求），稳定性测试（不同环境）</li></ol></blockquote></li><li>Web前端性能优化<blockquote><ol><li>减少http请求</li><li>使用浏览器缓存</li><li>启用压缩</li><li>css放在页面最上面，javasript放在页面最下面</li><li>减少cookie传输</li><li>CDN缓存静态资源</li><li>反向代理缓存</li></ol></blockquote></li><li>应用服务器性能优化<blockquote><ol><li>分布式缓存<br>Hash表，读多写少，二八定律</li><li>合理使用缓存<br>频繁修改的数据不适合缓存，非热点数据不适合缓存，可能存在数据不一致和脏读，缓存的可用性，缓存利用LRU(最近最久未用算法)，缓存预热，缓存穿透</li><li>分布式缓存架构<br>更新同步的缓存（与应用部署在一起），互不通信的缓存（与应用部署在不同的服务器，采用Hash一致性算法可伸缩）。Memcached采用TCP通信，序列化协议基于文本的自定义，网络通信基于libevent，内存管理使用固定空间分配，存储时根据数据的size寻找一个大于size的最小的chunk，互不通信的服务器集群架构。</li><li>异步操作<br>使用消息队列</li><li>使用集群<br>负载均衡</li><li>代码优化<br>多线程，线程安全（将对象设计为无状态对象，使用局部对象，并发访问资源时使用锁），资源复用（单例模式，线程池），数据结构，垃圾回收</li></ol></blockquote></li><li>存储性能优化<blockquote><ol><li>机械硬盘和固态硬盘</li><li>B+树和LSM树</li><li>RAID（廉价磁盘冗余阵列）和HDFS（MapReduce）</li></ol></blockquote></li></ol><h3 id="5-网站的高可用架构"><a href="#5-网站的高可用架构" class="headerlink" title="5. 网站的高可用架构"></a>5. 网站的高可用架构</h3><ol><li>网站可用性的度量与考核<blockquote><p>网站不可用时间，网站年度可用性指标（多少个9）</p></blockquote></li><li>高可用的网站架构<blockquote><p>保证服务器硬件故障时服务依然可用、数据依然保存并能够被访问，手段主要是数据和服务的冗余备份及失效转移。应用层使用负载均衡应对高并发，心跳机制将问题服务器从集群中剔除。服务层使用RPC框架，在客户端使用软负载均衡，服务注册中心剔除不可用服务器。数据层需要写入数据时同步复制，实现数据冗余。</p></blockquote></li><li>高可用的应用<blockquote><ol><li>无状态应用</li><li>使用负载均衡进行失效转移</li><li>session管理的发展，seesion复制-&gt;session绑定(hash)-&gt;利用cookie记录session-&gt;session服务器</li></ol></blockquote></li><li>高可用的服务<blockquote><ol><li>服务器分级管理，物理机&gt;虚拟机，线程隔离</li><li>超时设置</li><li>异步调用</li><li>服务降级，拒绝服务，关闭功能</li><li>幂等设计</li></ol></blockquote></li><li>高可用的数据<blockquote><ol><li>数据多备份，实现持久化，并在失效时，快速切换访问数据的副本。</li><li>整个网站共享同一个分布式缓存集群</li><li>CAP原理，优先保证AP，数据一致性保证最终一致性</li><li>数据冷备采用定期备份，不能保证最终一致性，不能保证数据可用性。数据热备分为异步热备（成功写一份，异步写其他副本）和同步热备（多份数据副本同步写入）。关系数据库热备使用master，slave同步机制。读写分离，只写master，只读slave。</li><li>失效转移（将宕机服务器的读写请求路由到其他服务器）。失效确认，应用程序访问失败报告和控制中心的心跳检测。访问转移，重新路由，需要考虑存储不对等的情况。数据恢复，数据复制。</li></ol></blockquote></li><li>高可用网站的软件质量保证<blockquote><ol><li>网站发布<br>发布过程中，每次关闭集群中的一小部分服务器，发布完后可以立即访问，不影响用户</li><li>自动化测试<br>自动化测试工具Selenium</li><li>预发布验证<br>预发布服务器没有配置在负载均衡器上，只运行开发和测试访问。处理错误的一个理念是快速失败。</li><li>代码控制<br>分支开发，主干发布</li><li>自动化发布<br>固定发布日期</li><li>灰度发布<br>每天发布一部分服务器</li></ol></blockquote></li><li>网站运行监控<blockquote><p>不允许没有监控的服务上下</p><ol><li>监控数据采集<br>服务器端日志收集，客户端浏览器日志收集，实时计算框架storm的日志统计与分析，服务器性能监控（系统load、内存占用、磁盘IO、网络IO）Ganglia，运行数据报告（缓存命中率、平均响应延迟时间、待处理任务总数）</li><li>监控管理<br>系统报警，失效转移，自动优雅降级</li></ol></blockquote></li></ol><h3 id="6-永无止境：网站的伸缩性架构"><a href="#6-永无止境：网站的伸缩性架构" class="headerlink" title="6. 永无止境：网站的伸缩性架构"></a>6. 永无止境：网站的伸缩性架构</h3><ol><li><p>网站架构的伸缩性设计</p><blockquote><ol><li>不同功能进行物理分隔实现伸缩<br>纵向分离（分层后分离），横向分离（业务分隔后分离）</li><li>单一功能通过集群规模实现伸缩</li></ol></blockquote></li><li><p>应用服务器集群的伸缩性设计</p><blockquote><ol><li>HTTP重定向负载均衡，返回浏览器302</li><li>DNS域名解析负载均衡，一个域名多个IP</li><li>反向代理负载均衡，应用层（HTTP）负载均衡</li><li>IP负载均衡，修改目的地址的IP</li><li>数据链路层负载均衡，直接路由方式（DR），不修改IP修改MAC，LVS工作在这层</li><li>负载均衡算法<br>轮训（Round Robin, RR），加权轮训（Weighted Round Robin, WRR），随机，最少连接，源地址散列（hash）</li></ol></blockquote></li><li>分布式缓存集群的伸缩性设计<blockquote><p>新加入缓存服务器后使整个缓存服务器集群中已经缓存的数据尽可能还被访问到。</p><ol><li>Memcached分布式缓存集群的访问机制</li><li>分布式缓存的一致性Hash算法，虚拟节点</li></ol></blockquote></li><li>数据存储服务器集群的伸缩性设计<blockquote><ol><li>关系数据库集群的伸缩性设计<br>数据分库，跨库的表不能进行Join操作。进行了分库和主从复制后，单表数据仍很大，需要将一张表拆开分别存储在多个数据库中，即分片。支持数据分片的分布式数据库产品主要有Amoeba和Cobar。Cobar做负载均衡，MySQL做数据迁移。避免事务或者利用补偿机制代替数据库事务，分解数据访问逻辑避免JOIN操作。</li><li>NoSQL数据库的伸缩性设计<br>HBase的架构，HBase依赖可分裂的HRegion以及可伸缩的分布式文件系统HDFS。Zookeeper，HMaster，HRegionServer，HRegion。</li></ol></blockquote></li></ol><h3 id="7-随需应变：网站的可扩展架构"><a href="#7-随需应变：网站的可扩展架构" class="headerlink" title="7. 随需应变：网站的可扩展架构"></a>7. 随需应变：网站的可扩展架构</h3><ol><li>构建可扩展的网站架构<blockquote><p>扩展性（开闭原则，对扩展开放，对修改关闭），伸缩性（增加资源规模提高系统处理能力），模块化，降低模块之间的耦合</p></blockquote></li><li>利用分布式消息队列降低系统耦合性<blockquote><ol><li>事件驱动架构<br>生成者消费者模式就是常见的事件驱动模式，分布式消息队列。</li><li>分布式消息队列<br>FIFO，通过消息对象分解系统耦合性</li></ol></blockquote></li><li>利用分布式服务打造可复用的业务平台<blockquote><p>通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用</p><ol><li>WebService与企业级分布式服务</li><li>大型网站分布式服务的需求与特点<br>负载均衡，失效转移，高效的远程通信，整合异构系统，对应用最少侵入，版本管理，实时监控</li><li>分布式服务框架设计<br>Dubbo，服务框架客户端，服务注册中心，负载均衡策略，服务提供者</li></ol></blockquote></li><li>可扩展的数据结构<blockquote><p>关系数据库的schema，NoSQL的ColumnFamily</p></blockquote></li><li>利用开放平台建设网站生态圈<blockquote><ol><li>API接口</li><li>协议转换</li><li>安全</li><li>审计</li><li>路由</li><li>流程</li></ol></blockquote></li></ol><h3 id="8-固若金汤：网站的安全架构"><a href="#8-固若金汤：网站的安全架构" class="headerlink" title="8. 固若金汤：网站的安全架构"></a>8. 固若金汤：网站的安全架构</h3><ol><li>网站应用攻击与防御<blockquote><ol><li>XSS攻击<br>反射型，嵌入恶意脚本的链接，持久型，黑客提交恶意脚本到正常页面。防护手段有消毒，即对危险字符进行转义。HttpOnly，禁止访问cookie。</li><li>注入攻击<br>SLQ注入攻击，在请求中注入恶意SQL命令。黑客获取数据库结构的手段，开源，错误回显，盲注。防护手段有消毒，正则匹配过滤SQL。参数绑定，预编译。</li><li>CSRF攻击<br>通过跨站请求，以合法身份进行非法操作，其核心是利用了浏览器的cookie或者服务器的session策略，盗用用户身份。防御手段有表单token，验证码，referer check。</li><li>其他攻击和漏洞<br>error code，HTML注释，文件上传，路径遍历</li><li>Web应用防火墙<br>ModSecurity</li><li>网站安全漏洞扫描</li></ol></blockquote></li><li>信息加密技术及密钥安全管理<blockquote><ol><li>单向散列加密<br>密码保存与验证，加盐salt增加破解难度，MD5，SHA</li><li>对称加密<br>DES算法，RC算法</li><li>非对称加密算法<br>RSA算法，HTTPS里面的数字证书</li><li>密钥安全管理<br>密钥和算法放在独立的服务器上甚至做出专用硬件，加解密算法放在应用中，密钥放在独立的服务器中，密钥分片存储</li></ol></blockquote></li><li>信息过滤与反垃圾<blockquote><ol><li>文本匹配<br>正则匹配，Tri树，多级Hash表</li><li>分类算法<br>朴素贝叶斯分类，聚类挖掘</li><li>黑名单</li></ol></blockquote></li><li>电子商务风险控制<blockquote><ol><li>风险<br>账户风险，买家风险，卖家风险，交易风险</li><li>风控<br>规则引擎，统计模型</li></ol></blockquote></li></ol><h3 id="9-淘宝网的架构演化案例分析"><a href="#9-淘宝网的架构演化案例分析" class="headerlink" title="9. 淘宝网的架构演化案例分析"></a>9. 淘宝网的架构演化案例分析</h3><h3 id="10-维基百科的高性能架构设计分析"><a href="#10-维基百科的高性能架构设计分析" class="headerlink" title="10. 维基百科的高性能架构设计分析"></a>10. 维基百科的高性能架构设计分析</h3><h3 id="11-海量分布式存储系统Doris的高可用架构设计分析"><a href="#11-海量分布式存储系统Doris的高可用架构设计分析" class="headerlink" title="11. 海量分布式存储系统Doris的高可用架构设计分析"></a>11. 海量分布式存储系统Doris的高可用架构设计分析</h3><h3 id="12-网购秒杀系统架构设计案例分析"><a href="#12-网购秒杀系统架构设计案例分析" class="headerlink" title="12. 网购秒杀系统架构设计案例分析"></a>12. 网购秒杀系统架构设计案例分析</h3><h3 id="13-大型网站典型故障案例分析"><a href="#13-大型网站典型故障案例分析" class="headerlink" title="13. 大型网站典型故障案例分析"></a>13. 大型网站典型故障案例分析</h3><h3 id="14-架构师领导艺术"><a href="#14-架构师领导艺术" class="headerlink" title="14. 架构师领导艺术"></a>14. 架构师领导艺术</h3><h3 id="15-网站架构师职场攻略"><a href="#15-网站架构师职场攻略" class="headerlink" title="15. 网站架构师职场攻略"></a>15. 网站架构师职场攻略</h3><h3 id="16-漫话网站架构师"><a href="#16-漫话网站架构师" class="headerlink" title="16. 漫话网站架构师"></a>16. 漫话网站架构师</h3><h3 id="附录A-大型网站架构技术一览"><a href="#附录A-大型网站架构技术一览" class="headerlink" title="附录A 大型网站架构技术一览"></a>附录A 大型网站架构技术一览</h3><h3 id="附录B-Web开发技术发展历程"><a href="#附录B-Web开发技术发展历程" class="headerlink" title="附录B Web开发技术发展历程"></a>附录B Web开发技术发展历程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-大型网站架构演进&quot;&gt;&lt;a href=&quot;#1-大型网站架构演进&quot; class=&quot;headerlink&quot; title=&quot;1. 大型网站架构演进&quot;&gt;&lt;/a&gt;1. 大型网站架构演进&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;大型网站软件系统的特点&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
  </entry>
  
</feed>
