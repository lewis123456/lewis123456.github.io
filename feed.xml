<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longman</title>
  <icon>https://www.gravatar.com/avatar/b7e2ba3f68bd206134b3d41535be01b0</icon>
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://longman.kim/"/>
  <updated>2018-07-12T09:49:00.020Z</updated>
  <id>http://longman.kim/</id>
  
  <author>
    <name>lewis longman</name>
    <email>2328811532@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>国内主流互联网公司的RPC和MOM</title>
    <link href="http://longman.kim/2018/07/12/%E5%9B%BD%E5%86%85%E4%B8%BB%E6%B5%81%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84RPC%E5%92%8CMOM/"/>
    <id>http://longman.kim/2018/07/12/国内主流互联网公司的RPC和MOM/</id>
    <published>2018-07-12T09:48:59.000Z</published>
    <updated>2018-07-12T09:49:00.020Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站技术架构-核心原理与案例分析</title>
    <link href="http://longman.kim/2018/07/11/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://longman.kim/2018/07/11/大型网站技术架构-核心原理与案例分析/</id>
    <published>2018-07-11T12:02:57.000Z</published>
    <updated>2018-07-12T14:22:32.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-大型网站架构演进"><a href="#1-大型网站架构演进" class="headerlink" title="1. 大型网站架构演进"></a>1. 大型网站架构演进</h3><ol><li><p>大型网站软件系统的特点</p><blockquote><p>高并发，大流量，高可用，海量数据，用户分布广泛，网络情况复杂，安全环境恶劣，需求快速变更，发布频繁，渐进式发展  </p></blockquote></li><li><p>大型网站架构演化发展历程</p><blockquote><ol><li>初始阶段<br>LAMP单机</li><li>应用服务和数据服务分离  </li><li>使用缓存改善网站性能  </li><li>使用应用服务器集群改善网站的并发处理能力</li><li>数据库读写分离</li><li>使用反向代理和CDN加速网站响应  </li><li>使用分布式文件系统和分布式数据库系统</li><li>使用NoSQL和搜索引擎</li><li>业务拆分</li><li>分布式服务</li></ol></blockquote></li><li><p>大型网站架构演化的价值观</p><blockquote><ol><li>网站所需灵活应对</li><li>业务发展是驱动力</li></ol></blockquote></li><li><p>网站架构设计误区</p><blockquote><ol><li>一味追求大公司的解决方案</li><li>为了技术而技术</li><li>企图用技术解决所有问题</li></ol></blockquote></li></ol><h3 id="2-大型网站结构模式"><a href="#2-大型网站结构模式" class="headerlink" title="2. 大型网站结构模式"></a>2. 大型网站结构模式</h3><ol><li><p>网站架构模式</p><blockquote><ol><li>分层<br>应用层，服务层，数据层  </li><li>分割  </li><li>分布式<br>分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算，分布式配置，分布式锁，分布式文件系统</li><li>集群</li><li>缓存<br>CDN，反向代理，本地缓存，分布式缓存</li><li>异步<br>解耦，异步模式，生产者消费者，提高可用性，加快响应速度，消除并发访问高峰</li><li>冗余<br>冷备份，热备份，灾备数据中心</li><li>自动化<br>发布过程自动化，自动化代码管理，自动化测试，自动化安全检测，自动化部署，自动化监控，自动化报警，自动化失效转移，自动化失效恢复，自动化降级，自动化资源分配</li><li>安全<br>密码，手机校验码，加密，XSS攻击，SQL注入，信息过滤，风险控制</li></ol></blockquote></li><li><p>架构模式在新浪微博的应用</p><blockquote><ol><li>LAMP</li><li>基础服务层：数据库，缓存，存储，搜索</li><li>平台服务和应用服务</li><li>API和业务层</li><li>分布式部署，集群，异步推拉结合，多级缓存，冗余，自动化，安全</li></ol></blockquote></li></ol><h3 id="3-大型网站核心架构要素"><a href="#3-大型网站核心架构要素" class="headerlink" title="3. 大型网站核心架构要素"></a>3. 大型网站核心架构要素</h3><p>最高层次的规划，难以改变的决定</p><ol><li>性能<blockquote><ol><li>浏览器端，浏览器缓存，页面压缩，合理布局，减少cookie传输</li><li>CDN，动静分离，部署反向代理，缓存热点文件</li><li>服务端，本地缓存，分布式缓存，异步消息队列，集群，多线程，改善内存管理</li><li>数据库，索引，缓存，SQL优化，NoSQL</li><li>响应时间，TPS</li></ol></blockquote></li><li>可用性<blockquote><ol><li>7*24小时可用，4个9即99.99%可用</li><li>主要是手段是冗余</li><li>应用服务器，负载均衡，集群</li><li>存储服务器，实时备份</li></ol></blockquote></li><li>伸缩性<blockquote><ol><li>应用服务器用合适的负载均衡器向集群中加机器</li><li>缓存服务器，改进缓存路由算法，保证缓存的可访问性</li><li>关系数据库支持数据复制，主从热备等机制，但很难保证大规模的伸缩性。主要通过路由分区将多个数据库的服务器组成一个集群。NoSQL比较好扩展。</li></ol></blockquote></li><li>扩展性<blockquote><p>如何设计网站的架构使其能够快速响应需求的变化。</p><ol><li>事件驱动架构<br>消息队列</li><li>分布式服务<br>将业务和可复用服务分离，通过分布式服务框架调用。</li></ol></blockquote></li><li>安全性<blockquote><p>保护数据</p></blockquote></li></ol><h3 id="4-瞬时响应：网站的高性能架构"><a href="#4-瞬时响应：网站的高性能架构" class="headerlink" title="4. 瞬时响应：网站的高性能架构"></a>4. 瞬时响应：网站的高性能架构</h3><ol><li>网站性能测试<blockquote><ol><li>响应时间，请求开始到收到响应所需的时间</li><li>并发数，系统能够同时处理请求的数目</li><li>吞吐量，TPS（每秒事务数），QPS（每秒查询数），HPS（每秒HTTP请求数）</li><li>性能技术器<br>系统负载，对象与线程数，内存使用，CPU使用，磁盘与网络I/O</li><li>性能测试方法<br>性能测试，负载测试（直到处理能力下降），压力测试（直到系统崩溃或不能处理任何请求），稳定性测试（不同环境）</li></ol></blockquote></li><li>Web前端性能优化<blockquote><ol><li>减少http请求</li><li>使用浏览器缓存</li><li>启用压缩</li><li>css放在页面最上面，javasript放在页面最下面</li><li>减少cookie传输</li><li>CDN缓存静态资源</li><li>反向代理缓存</li></ol></blockquote></li><li>应用服务器性能优化<blockquote><ol><li>分布式缓存<br>Hash表，读多写少，二八定律</li><li>合理使用缓存<br>频繁修改的数据不适合缓存，非热点数据不适合缓存，可能存在数据不一致和脏读，缓存的可用性，缓存利用LRU(最近最久未用算法)，缓存预热，缓存穿透</li><li>分布式缓存架构<br>更新同步的缓存（与应用部署在一起），互不通信的缓存（与应用部署在不同的服务器，采用Hash一致性算法可伸缩）。Memcached采用TCP通信，序列化协议基于文本的自定义，网络通信基于libevent，内存管理使用固定空间分配，存储时根据数据的size寻找一个大于size的最小的chunk，互不通信的服务器集群架构。</li><li>异步操作<br>使用消息队列</li><li>使用集群<br>负载均衡</li><li>代码优化<br>多线程，线程安全（将对象设计为无状态对象，使用局部对象，并发访问资源时使用锁），资源复用（单例模式，线程池），数据结构，垃圾回收</li></ol></blockquote></li><li>存储性能优化<blockquote><ol><li>机械硬盘和固态硬盘</li><li>B+树和LSM树</li><li>RAID（廉价磁盘冗余阵列）和HDFS（MapReduce）</li></ol></blockquote></li></ol><h3 id="5-网站的高可用架构"><a href="#5-网站的高可用架构" class="headerlink" title="5. 网站的高可用架构"></a>5. 网站的高可用架构</h3><ol><li>网站可用性的度量与考核<blockquote><p>网站不可用时间，网站年度可用性指标（多少个9）</p></blockquote></li><li>高可用的网站架构<blockquote><p>保证服务器硬件故障时服务依然可用、数据依然保存并能够被访问，手段主要是数据和服务的冗余备份及失效转移。应用层使用负载均衡应对高并发，心跳机制将问题服务器从集群中剔除。服务层使用RPC框架，在客户端使用软负载均衡，服务注册中心剔除不可用服务器。数据层需要写入数据时同步复制，实现数据冗余。</p></blockquote></li><li>高可用的应用<blockquote><ol><li>无状态应用</li><li>使用负载均衡进行失效转移</li><li>session管理的发展，seesion复制-&gt;session绑定(hash)-&gt;利用cookie记录session-&gt;session服务器</li></ol></blockquote></li><li>高可用的服务<blockquote><ol><li>服务器分级管理，物理机&gt;虚拟机，线程隔离</li><li>超时设置</li><li>异步调用</li><li>服务降级，拒绝服务，关闭功能</li><li>幂等设计</li></ol></blockquote></li><li>高可用的数据<blockquote><ol><li>数据多备份，实现持久化，并在失效时，快速切换访问数据的副本。</li><li>整个网站共享同一个分布式缓存集群</li><li>CAP原理，优先保证AP，数据一致性保证最终一致性</li><li>数据冷备采用定期备份，不能保证最终一致性，不能保证数据可用性。数据热备分为异步热备（成功写一份，异步写其他副本）和同步热备（多份数据副本同步写入）。关系数据库热备使用master，slave同步机制。读写分离，只写master，只读slave。</li><li>失效转移（将宕机服务器的读写请求路由到其他服务器）。失效确认，应用程序访问失败报告和控制中心的心跳检测。访问转移，重新路由，需要考虑存储不对等的情况。数据恢复，数据复制。</li></ol></blockquote></li><li>高可用网站的软件质量保证<blockquote><ol><li>网站发布<br>发布过程中，每次关闭集群中的一小部分服务器，发布完后可以立即访问，不影响用户</li><li>自动化测试<br>自动化测试工具Selenium</li><li>预发布验证<br>预发布服务器没有配置在负载均衡器上，只运行开发和测试访问。处理错误的一个理念是快速失败。</li><li>代码控制<br>分支开发，主干发布</li><li>自动化发布<br>固定发布日期</li><li>灰度发布<br>每天发布一部分服务器</li></ol></blockquote></li><li>网站运行监控<blockquote><p>不允许没有监控的服务上下</p><ol><li>监控数据采集<br>服务器端日志收集，客户端浏览器日志收集，实时计算框架storm的日志统计与分析，服务器性能监控（系统load、内存占用、磁盘IO、网络IO）Ganglia，运行数据报告（缓存命中率、平均响应延迟时间、待处理任务总数）</li><li>监控管理<br>系统报警，失效转移，自动优雅降级</li></ol></blockquote></li></ol><h3 id="6-永无止境：网站的伸缩性架构"><a href="#6-永无止境：网站的伸缩性架构" class="headerlink" title="6. 永无止境：网站的伸缩性架构"></a>6. 永无止境：网站的伸缩性架构</h3><ol><li><p>网站架构的伸缩性设计</p><blockquote><ol><li>不同功能进行物理分隔实现伸缩<br>纵向分离（分层后分离），横向分离（业务分隔后分离）</li><li>单一功能通过集群规模实现伸缩</li></ol></blockquote></li><li><p>应用服务器集群的伸缩性设计</p><blockquote><ol><li>HTTP重定向负载均衡，返回浏览器302</li><li>DNS域名解析负载均衡，一个域名多个IP</li><li>反向代理负载均衡，应用层（HTTP）负载均衡</li><li>IP负载均衡，修改目的地址的IP</li><li>数据链路层负载均衡，直接路由方式（DR），不修改IP修改MAC，LVS工作在这层</li><li>负载均衡算法<br>轮训（Round Robin, RR），加权轮训（Weighted Round Robin, WRR），随机，最少连接，源地址散列（hash）</li></ol></blockquote></li><li>分布式缓存集群的伸缩性设计<blockquote><p>新加入缓存服务器后使整个缓存服务器集群中已经缓存的数据尽可能还被访问到。</p><ol><li>Memcached分布式缓存集群的访问机制</li><li>分布式缓存的一致性Hash算法，虚拟节点</li></ol></blockquote></li><li>数据存储服务器集群的伸缩性设计<blockquote><ol><li>关系数据库集群的伸缩性设计<br>数据分库，跨库的表不能进行Join操作。进行了分库和主从复制后，单表数据仍很大，需要将一张表拆开分别存储在多个数据库中，即分片。支持数据分片的分布式数据库产品主要有Amoeba和Cobar。Cobar做负载均衡，MySQL做数据迁移。避免事务或者利用补偿机制代替数据库事务，分解数据访问逻辑避免JOIN操作。</li><li>NoSQL数据库的伸缩性设计<br>HBase的架构，HBase依赖可分裂的HRegion以及可伸缩的分布式文件系统HDFS。Zookeeper，HMaster，HRegionServer，HRegion。</li></ol></blockquote></li></ol><h3 id="7-随需应变：网站的可扩展架构"><a href="#7-随需应变：网站的可扩展架构" class="headerlink" title="7. 随需应变：网站的可扩展架构"></a>7. 随需应变：网站的可扩展架构</h3><ol><li>构建可扩展的网站架构<blockquote><p>扩展性（开闭原则，对扩展开放，对修改关闭），伸缩性（增加资源规模提高系统处理能力），模块化，降低模块之间的耦合</p></blockquote></li><li>利用分布式消息队列降低系统耦合性<blockquote><ol><li>事件驱动架构<br>生成者消费者模式就是常见的事件驱动模式，分布式消息队列。</li><li>分布式消息队列<br>FIFO，通过消息对象分解系统耦合性</li></ol></blockquote></li><li>利用分布式服务打造可复用的业务平台<blockquote><p>通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用</p><ol><li>WebService与企业级分布式服务</li><li>大型网站分布式服务的需求与特点<br>负载均衡，失效转移，高效的远程通信，整合异构系统，对应用最少侵入，版本管理，实时监控</li><li>分布式服务框架设计<br>Dubbo，服务框架客户端，服务注册中心，负载均衡策略，服务提供者</li></ol></blockquote></li><li>可扩展的数据结构<blockquote><p>关系数据库的schema，NoSQL的ColumnFamily</p></blockquote></li><li>利用开放平台建设网站生态圈<blockquote><ol><li>API接口</li><li>协议转换</li><li>安全</li><li>审计</li><li>路由</li><li>流程</li></ol></blockquote></li></ol><h3 id="8-固若金汤：网站的安全架构"><a href="#8-固若金汤：网站的安全架构" class="headerlink" title="8. 固若金汤：网站的安全架构"></a>8. 固若金汤：网站的安全架构</h3><ol><li>网站应用攻击与防御<blockquote><ol><li>XSS攻击<br>反射型，嵌入恶意脚本的链接，持久型，黑客提交恶意脚本到正常页面。防护手段有消毒，即对危险字符进行转义。HttpOnly，禁止访问cookie。</li><li>注入攻击<br>SLQ注入攻击，在请求中注入恶意SQL命令。黑客获取数据库结构的手段，开源，错误回显，盲注。防护手段有消毒，正则匹配过滤SQL。参数绑定，预编译。</li><li>CSRF攻击<br>通过跨站请求，以合法身份进行非法操作，其核心是利用了浏览器的cookie或者服务器的session策略，盗用用户身份。防御手段有表单token，验证码，referer check。</li><li>其他攻击和漏洞<br>error code，HTML注释，文件上传，路径遍历</li><li>Web应用防火墙<br>ModSecurity</li><li>网站安全漏洞扫描</li></ol></blockquote></li><li>信息加密技术及密钥安全管理<blockquote><ol><li>单向散列加密<br>密码保存与验证，加盐salt增加破解难度，MD5，SHA</li><li>对称加密<br>DES算法，RC算法</li><li>非对称加密算法<br>RSA算法，HTTPS里面的数字证书</li><li>密钥安全管理<br>密钥和算法放在独立的服务器上甚至做出专用硬件，加解密算法放在应用中，密钥放在独立的服务器中，密钥分片存储</li></ol></blockquote></li><li>信息过滤与反垃圾<blockquote><ol><li>文本匹配<br>正则匹配，Tri树，多级Hash表</li><li>分类算法<br>朴素贝叶斯分类，聚类挖掘</li><li>黑名单</li></ol></blockquote></li><li>电子商务风险控制</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-大型网站架构演进&quot;&gt;&lt;a href=&quot;#1-大型网站架构演进&quot; class=&quot;headerlink&quot; title=&quot;1. 大型网站架构演进&quot;&gt;&lt;/a&gt;1. 大型网站架构演进&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;大型网站软件系统的特点&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七周七并发模型</title>
    <link href="http://longman.kim/2018/07/09/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://longman.kim/2018/07/09/七周七并发模型/</id>
    <published>2018-07-08T17:24:59.000Z</published>
    <updated>2018-07-08T17:24:59.670Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七周七数据库</title>
    <link href="http://longman.kim/2018/07/09/%E4%B8%83%E5%91%A8%E4%B8%83%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://longman.kim/2018/07/09/七周七数据库/</id>
    <published>2018-07-08T17:23:10.000Z</published>
    <updated>2018-07-08T17:24:21.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-PostgreSQL"><a href="#1-PostgreSQL" class="headerlink" title="1. PostgreSQL"></a>1. PostgreSQL</h3><h3 id="2-Riak"><a href="#2-Riak" class="headerlink" title="2. Riak"></a>2. Riak</h3><h3 id="3-Hbase"><a href="#3-Hbase" class="headerlink" title="3. Hbase"></a>3. Hbase</h3><h3 id="4-mongodb"><a href="#4-mongodb" class="headerlink" title="4. mongodb"></a>4. mongodb</h3><h3 id="5-CouchDB"><a href="#5-CouchDB" class="headerlink" title="5. CouchDB"></a>5. CouchDB</h3><h3 id="6-Neo4j"><a href="#6-Neo4j" class="headerlink" title="6. Neo4j"></a>6. Neo4j</h3><h3 id="7-Redis"><a href="#7-Redis" class="headerlink" title="7. Redis"></a>7. Redis</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-PostgreSQL&quot;&gt;&lt;a href=&quot;#1-PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;1. PostgreSQL&quot;&gt;&lt;/a&gt;1. PostgreSQL&lt;/h3&gt;&lt;h3 id=&quot;2-Riak&quot;&gt;&lt;a href=&quot;#2-Ria
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AWS认证考试（云技术架构师）</title>
    <link href="http://longman.kim/2018/07/09/AWS%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%EF%BC%88%E4%BA%91%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%B8%88%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/09/AWS认证考试（云技术架构师）/</id>
    <published>2018-07-08T17:03:18.000Z</published>
    <updated>2018-07-08T17:03:18.590Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://longman.kim/2018/07/08/Zookeeper/"/>
    <id>http://longman.kim/2018/07/08/Zookeeper/</id>
    <published>2018-07-08T13:55:34.000Z</published>
    <updated>2018-07-11T11:15:39.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Zookeeper是什么？"><a href="#1-Zookeeper是什么？" class="headerlink" title="1. Zookeeper是什么？"></a>1. Zookeeper是什么？</h3><p>Zookeeper是一个分布式的分布式应用程序协调服务，它为分布式应用提供一致性服务，功能包括：配置维护、域名服务、分布式同步、组服务等，提供的接口主要有分布式独享锁、选举、队列。</p><h3 id="2-Zookeeper的架构与组成"><a href="#2-Zookeeper的架构与组成" class="headerlink" title="2. Zookeeper的架构与组成"></a>2. Zookeeper的架构与组成</h3><ol><li>类似于文件系统，多叉树的结构，每个节点znode的大小&lt;1M。Zookeeper服务由多个互相通信的Server构成，其中有一个Server是leader。当leader挂了之后，会重新选择一个新的leader。</li><li>普通的Server能处理read和watch请求，只有leader能处理write请求。因此，当普通Server收到write请求时，它会将请求重定向到leader。Client配置所有Server的列表，但只会选择其中的一个Server进行连接。</li><li>当Client连接的Server挂了之后，Client会重新选择一个Server，建立新的会话。</li><li>update操作必须严格有序执行，对每一个操作都有对应的交易ID。</li><li>Zookeeper中的数据保存在内存，写操作先写磁盘再写内存，更新操作先写更新记录到磁盘再更新内存。</li><li>读写比是10:1时，zookeeper表现最好。  </li><li>zookeeper中不使用相对路径。</li><li>znode中有修改的版本号，ACL的版本号，时间戳等。修改znode时，要对版本号进行核对。</li><li>Zookeeper中ACL控制不是递归的，能访问父节点不一定能访问子节点。<h3 id="3-Fast-Paxos算法，ZAB算法"><a href="#3-Fast-Paxos算法，ZAB算法" class="headerlink" title="3. Fast Paxos算法，ZAB算法"></a>3. Fast Paxos算法，ZAB算法</h3></li><li><strong><em>数据修改</em></strong><br>ZAB(Zookeeper Atomic Broadcast)原子广播协议，是2PC(两阶段提交)协议的变体。<br>1.1  follower收到write请求后，将请求重定向到leader。<br>1.2  leader将write请求（携带序列号64位，前32位SID（服务器的唯一标识）和后32位ZXID（事务ID））广播给follower。<br>1.3  follower将write请求放在history队列里面，然后回复ACK给leader。<br>1.4  leader收到一半的ACK后，广播commit给follower。<br>1.5  follower收到commit请求后，如果发现这个交易的序列号在history队列里面是最小的，就执行该请求。如果发现这个交易的序列号不是最小的，需要等待小的序列号执行commmit后，才执行这个大序列号的交易。</li><li><strong><em>leader挂了后的选举</em></strong><br>服务器如果无法和leader连接时进入leader选举状态，称为looking状态。looking状态的机器会向集群中所有的机器发起投票。投票包含该服务器最近的序列号(sid, zxid)和选举轮次。最开始都投自己，然后比较接收到的序列号（先比较zxid，再比较sid），投给最大序列号对应的服务器，两轮就能确定。</li><li><strong><em>初始化数据恢复</em></strong><br>确保那些在leader服务器上提交的事务最终被执行，丢弃那些只在leader服务器被提出的事务。选择leader完成后，followers发送自己接收的最大zxid的epoch给leader。leader从接收到的epoch中，选择最大的并加1，发送给follower。follower接收到epoch之后，更新自己的epoch。然后将自己的history历史事务集反馈给leader。leader在收到过半的反馈后，从收到的反馈中选择epoch最大，同时zxid最大的follower的事务集合作为初始化事务集合。leader将初始化集合发给follower，follower接收并处理事务集，反馈给leader，leader收到反馈后发送commit。</li><li><strong><em>client挂了后的处理</em></strong><br>zookeeper允许client创建两种类型的节点：persistent, ephemeral，ephemeral类型的节点与client一起共存亡。客户端与follower连接时，会创建一个session, follower和leader都保存了session信息。client定期向follower发送ping包，证明自己活着。leader定期向follower发送ping包，检查是否有超过一半的follower还活着，同时follower会返回session，告诉leader哪些client还活着，这样leader就可以删除不错在客户端的ephemeral节点，ephemeral不允许有children。</li></ol><h3 id="4-动物园管理员（Zookeeper）的故事"><a href="#4-动物园管理员（Zookeeper）的故事" class="headerlink" title="4. 动物园管理员（Zookeeper）的故事"></a>4. 动物园管理员（Zookeeper）的故事</h3><h3 id="5-优点与缺点"><a href="#5-优点与缺点" class="headerlink" title="5. 优点与缺点"></a>5. 优点与缺点</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Zookeeper是什么？&quot;&gt;&lt;a href=&quot;#1-Zookeeper是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Zookeeper是什么？&quot;&gt;&lt;/a&gt;1. Zookeeper是什么？&lt;/h3&gt;&lt;p&gt;Zookeeper是一个分布式的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://longman.kim/2018/07/08/Kafka/"/>
    <id>http://longman.kim/2018/07/08/Kafka/</id>
    <published>2018-07-08T13:32:30.000Z</published>
    <updated>2018-07-09T08:38:32.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Kalfka？"><a href="#1-什么是Kalfka？" class="headerlink" title="1. 什么是Kalfka？"></a>1. 什么是Kalfka？</h3><h3 id="2-Kalka的各种组件"><a href="#2-Kalka的各种组件" class="headerlink" title="2. Kalka的各种组件"></a>2. Kalka的各种组件</h3><h3 id="3-offset的角色"><a href="#3-offset的角色" class="headerlink" title="3. offset的角色"></a>3. offset的角色</h3><h3 id="4-consumer-group是什么"><a href="#4-consumer-group是什么" class="headerlink" title="4. consumer group是什么"></a>4. consumer group是什么</h3><h3 id="5-Zookeeper的角色"><a href="#5-Zookeeper的角色" class="headerlink" title="5. Zookeeper的角色"></a>5. Zookeeper的角色</h3><h3 id="6-Kalka可以不使用Zookeeper吗"><a href="#6-Kalka可以不使用Zookeeper吗" class="headerlink" title="6. Kalka可以不使用Zookeeper吗"></a>6. Kalka可以不使用Zookeeper吗</h3><h3 id="7-leader和follower的概念"><a href="#7-leader和follower的概念" class="headerlink" title="7. leader和follower的概念"></a>7. leader和follower的概念</h3><h3 id="8-复制和ISR的角色"><a href="#8-复制和ISR的角色" class="headerlink" title="8. 复制和ISR的角色"></a>8. 复制和ISR的角色</h3><h3 id="9-复制在Kafka中的重要性"><a href="#9-复制在Kafka中的重要性" class="headerlink" title="9. 复制在Kafka中的重要性"></a>9. 复制在Kafka中的重要性</h3><h3 id="10-Kafka启动流程"><a href="#10-Kafka启动流程" class="headerlink" title="10. Kafka启动流程"></a>10. Kafka启动流程</h3><h3 id="11-如何定义一个Partitioning-key"><a href="#11-如何定义一个Partitioning-key" class="headerlink" title="11. 如何定义一个Partitioning key?"></a>11. 如何定义一个Partitioning key?</h3><h3 id="12-生产者的队列什么时候会变满了？"><a href="#12-生产者的队列什么时候会变满了？" class="headerlink" title="12. 生产者的队列什么时候会变满了？"></a>12. 生产者的队列什么时候会变满了？</h3><h3 id="13-介绍下Kafka中Production的API"><a href="#13-介绍下Kafka中Production的API" class="headerlink" title="13. 介绍下Kafka中Production的API"></a>13. 介绍下Kafka中Production的API</h3><h3 id="14-介绍下Kafka中Consumer的API"><a href="#14-介绍下Kafka中Consumer的API" class="headerlink" title="14. 介绍下Kafka中Consumer的API"></a>14. 介绍下Kafka中Consumer的API</h3><h3 id="15-介绍下Kafka中Stream的API"><a href="#15-介绍下Kafka中Stream的API" class="headerlink" title="15. 介绍下Kafka中Stream的API"></a>15. 介绍下Kafka中Stream的API</h3><h3 id="16-介绍下Kafka中Connector的API"><a href="#16-介绍下Kafka中Connector的API" class="headerlink" title="16. 介绍下Kafka中Connector的API"></a>16. 介绍下Kafka中Connector的API</h3><h3 id="17-Kafka和Flume的区别"><a href="#17-Kafka和Flume的区别" class="headerlink" title="17. Kafka和Flume的区别"></a>17. Kafka和Flume的区别</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是Kalfka？&quot;&gt;&lt;a href=&quot;#1-什么是Kalfka？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Kalfka？&quot;&gt;&lt;/a&gt;1. 什么是Kalfka？&lt;/h3&gt;&lt;h3 id=&quot;2-Kalka的各种组件&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员国外面试流程（同事口述）</title>
    <link href="http://longman.kim/2018/07/06/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9B%BD%E5%A4%96%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B%EF%BC%88%E5%90%8C%E4%BA%8B%E5%8F%A3%E8%BF%B0%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/06/程序员国外面试流程（同事口述）/</id>
    <published>2018-07-06T12:54:55.000Z</published>
    <updated>2018-07-06T13:06:06.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-面试准备"><a href="#1-面试准备" class="headerlink" title="1. 面试准备"></a>1. 面试准备</h3><ol><li><p>英语<br>口语，可以找网上一对一的私教</p></li><li><p>算法<br>ACM类型的算法题目，刷leetcode，打比赛</p></li><li><p>项目  </p></li></ol><ol start="4"><li><p>面向对象设计，设计模式<br>面向对象的思想，设计模式</p></li><li><p>架构<br>AWS的一些架构</p></li></ol><h3 id="2-面试流程"><a href="#2-面试流程" class="headerlink" title="2. 面试流程"></a>2. 面试流程</h3><ol><li>在线做题（一个小时左右网上完成一份试卷）  </li><li>三轮电面（2轮在线编程，1轮项目介绍）  </li><li>一天之内6轮现场面试（白板手写算法，面向对象设计，架构）</li></ol><h3 id="3-机会"><a href="#3-机会" class="headerlink" title="3. 机会"></a>3. 机会</h3><p>使用linkedin，吸引国外公司的HR，多加群</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-面试准备&quot;&gt;&lt;a href=&quot;#1-面试准备&quot; class=&quot;headerlink&quot; title=&quot;1. 面试准备&quot;&gt;&lt;/a&gt;1. 面试准备&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;英语&lt;br&gt;口语，可以找网上一对一的私教&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;算法&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180705</title>
    <link href="http://longman.kim/2018/07/04/%E5%89%A7%E6%9C%AC20180705/"/>
    <id>http://longman.kim/2018/07/04/剧本20180705/</id>
    <published>2018-07-04T14:11:05.000Z</published>
    <updated>2018-07-04T14:11:05.147Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站系统与Java中间件实践</title>
    <link href="http://longman.kim/2018/07/03/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8EJava%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5/"/>
    <id>http://longman.kim/2018/07/03/大型网站系统与Java中间件实践/</id>
    <published>2018-07-03T15:06:54.000Z</published>
    <updated>2018-07-04T14:10:27.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式系统介绍"><a href="#1-分布式系统介绍" class="headerlink" title="1. 分布式系统介绍"></a>1. 分布式系统介绍</h3><p>1.1 分布式中的控制器</p><blockquote><p>请求调用的负载均衡（硬件F5，软件LVS），也称为透明代理，服务请求方和提供方直接多了层代理。名称服务，收集服务提供方的地址信息，把这些信息提供给服务调用方，负载均衡由服务调用方做。规则服务器，不和服务提供方交互，只向调用方提供调用服务的规则。Master+Worker的方式，任务的分配和管理。</p></blockquote><p>1.2 分布式的运算器</p><blockquote><p>DNS服务器进行调度和控制，将域名解析到不同的网站服务器；DNS返回负载均衡器的地址，负载均衡器将请求分发到不同的网站服务器；采用Master控制日志处理器集群的方式，或者规则服务器协调日志处理服务器的动作。</p></blockquote><p>1.3 分布式的存储器</p><blockquote><p>单个KV存储服务器；使用代理（根据K值进行划分）的多个KV存储服务器；采用名称服务的多个KV存储服务器，一种是规则服务器配合完成固定划分的策略，一种是对等看待多台KV存储服务器，灵活的适应KV存储服务器的增加和减少（一致性哈希）；规则服务器返回如何对数据进行划分，以及具体包含KV存储服务器的地址。Master对每个请求，直接返回一个KV服务器对应的地址。</p></blockquote><p>1.4 缺乏全局时钟，采用集群进行处理</p><p>1.5 面对故障独立性，一部分有问题其他部分能正常工作</p><p>1.6 单点故障</p><blockquote><p>最直接的是将功能从单机实现变为集群；一种方法是备份，自动恢复；一种是降低单点的影响范围，例如对数据库做划分</p></blockquote><p>1.7 分布式事务的挑战</p><blockquote><p>2PC, 3PC, BASE, CAP, PAXOS</p></blockquote><h3 id="2-大型网站及其架构演进过程"><a href="#2-大型网站及其架构演进过程" class="headerlink" title="2. 大型网站及其架构演进过程"></a>2. 大型网站及其架构演进过程</h3><p>2.1 大型网站：大访问量，海量数据</p><p>2.2 架构演进</p><blockquote><p>2.2.1 单机<br>2.2.2 数据库与应用分离<br>2.2.3 应用服务器走向集群</p><blockquote><p>2.2.3.1 引入负载均衡<br>2.2.3.2 session问题（session sticky即同一个用户的所有请求被负载均衡到同一台机器，session replication所有机器都保存所有的seesion涉及session同步，session集中存储，基于cookie） </p></blockquote></blockquote><blockquote><p>2.2.4 数据库读写分离</p><blockquote><p>2.2.4.1 数据复制需要考虑数据复制时延问题，MySQL支持Master和Slave模式，异步复制，半同步服务<br>2.2.4.2 如何选择数据源<br>2.2.4.3 搜索引擎是一个读库，索引集群构建方式，全量/增量，实时/非实时<br>2.2.4.4 数据缓存，页面缓存，缓存命中率，缓存的失效，更新  </p></blockquote></blockquote><blockquote><p>2.2.5 分布式存储系统</p><blockquote><p>分布式文件系统（大小文件的存储），分布式Key-Value系统（半结构数据支持），分布式数据库系统，提供高容量，高并发访问，数据冗余容灾的支持</p></blockquote></blockquote><blockquote><p>2.2.6 读写分离后，数据库又遇到瓶颈</p><blockquote><p>2.2.6.1 专库专用，垂直拆分，将不同的表分到不同的数据库。要处理单机跨业务的事务，可以采用分布式事务。<br>2.2.6.2 水平拆分，将同一个表的数据分到不同的数据库。要解决SQL路由的问题，以及分页。</p></blockquote></blockquote><blockquote><p>2.2.7 数据库问题解决后，应用面对的新挑战</p><blockquote><p>应用拆分的方式：根据业务特性<br>走服务化的路</p></blockquote></blockquote><blockquote><p>2.2.8 消息中间件</p><blockquote><p>在分布式系统中完成消息的发送和接受，实现异步和解耦 </p></blockquote></blockquote><h3 id="3-构建Java中间件"><a href="#3-构建Java中间件" class="headerlink" title="3. 构建Java中间件"></a>3. 构建Java中间件</h3><blockquote><p>3.1 JVM, 垃圾回收与内存堆布局，并发编程（线程池，同步，锁，线程通信，异步，并发容器）<br>3.2 动态代理<br>3.3 反射<br>3.4 Java中间件，消息中间件（MOM），服务框架（RPC），软负载中心，持久配置管理，分布式数据层，数据复制/迁移</p></blockquote><h3 id="4-服务框架"><a href="#4-服务框架" class="headerlink" title="4. 服务框架"></a>4. 服务框架</h3><blockquote><p>dubbo, grpc, thrift, motan, rmi, hessian, webservice<br>rmi, rpc, soap, rest  </p></blockquote><p>4.1 服务框架的设计与实现</p><blockquote><ol><li>服务框架需要解决的问题：接口调用-&gt;寻址路由-&gt;编码-&gt;通信-&gt;解码-&gt;实例定位-&gt;服务调用</li><li>远程服务的客户端调用：获取可用服务地址列表-&gt;确定要调用服务的目标机器-&gt;建立链接-&gt;请求序列化-&gt;发送请求-&gt;接收结果-&gt;解析结果  </li><li>服务调用端具体工作：调用发起-&gt;寻址路由-&gt;协议适配/序列化-&gt;网络传输-&gt;反序列化/协议解析-&gt;得到结果返回给调用方  </li><li>配置服务：interfaceName, version, group</li><li>服务调用者与服务提供者直连（服务注册查找中心），基于接口、方法、参数的路由，多机房场景</li><li>网络通信的实现BIO，NIO（IO线程，数据队列，通信对象队列，定时任务），AIO</li><li>多种异步调用方式：Oneway方式，Callback方式，Future方式</li><li>服务提供端具体工作：反序列化/协议解析-&gt;定位服务-&gt;执行方法生成方法-&gt;协议适配/序列化-&gt;网络传输  </li><li>不同服务的线程池隔离，0-1开关，QPS的流控处理，服务升级</li></ol></blockquote><p>4.2 实战中的优化</p><blockquote><p>服务的拆分，服务的粒度，服务缓存，分布式环境中的请求合并</p></blockquote><p>4.3 服务治理</p><blockquote><ol><li><p>管理服务</p><blockquote><ol><li>服务上下线  </li><li>服务路由</li><li>服务限流降级</li><li>服务归组</li><li>服务线程池管理</li><li>机房规则</li><li>服务授权 </li></ol></blockquote></li><li><p>查看服务</p><blockquote><ol><li>服务信息（服务编码）</li><li>服务质量（出错率、响应时间）</li><li>服务容量（能支持的请求量）</li><li>服务依赖（服务之前的依赖关系）</li><li>服务分布（跨机房的分布）</li><li>服务统计（调用次数，出错次数，出错率，响应时间的排名和趋势）</li><li>服务元数据（服务方法和参数）</li><li>服务查询（名称，负责人，发布时间，服务提供者地址列表，质量，容量，依赖，组，版本）</li><li>服务报表（非实时的统计报表）</li><li>服务监视（服务运行时数据的收集和处理）</li></ol></blockquote></li></ol></blockquote><h3 id="5-数据访问层"><a href="#5-数据访问层" class="headerlink" title="5. 数据访问层"></a>5. 数据访问层</h3><ol><li>分布式事务<blockquote><ol><li>2PC  </li></ol></blockquote></li><li>3PC  </li><li>PAXOS   </li><li><p>CAP, BASE </p></li><li><p>Join</p><blockquote><ol><li>把Join操作分成多次的数据库操作</li><li>通过信息冗余变成单表查询</li><li>外部系统（例如搜索引擎）解决</li></ol></blockquote></li><li><p>外键</p></li><li><p>自增序列</p><blockquote><ol><li>UUID的生成方式</li><li></li></ol></blockquote></li><li><p>查询跨库</p></li><li><p>确定执行SQL的目标库</p><blockquote><ol><li>固定哈希算法  </li><li>一致性哈希算法</li></ol></blockquote></li></ol><h3 id="6-消息中间件"><a href="#6-消息中间件" class="headerlink" title="6. 消息中间件"></a>6. 消息中间件</h3><h3 id="7-软负载中心与集中配置管理"><a href="#7-软负载中心与集中配置管理" class="headerlink" title="7. 软负载中心与集中配置管理"></a>7. 软负载中心与集中配置管理</h3><h3 id="8-构建大型网站的其他要素"><a href="#8-构建大型网站的其他要素" class="headerlink" title="8. 构建大型网站的其他要素"></a>8. 构建大型网站的其他要素</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式系统介绍&quot;&gt;&lt;a href=&quot;#1-分布式系统介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式系统介绍&quot;&gt;&lt;/a&gt;1. 分布式系统介绍&lt;/h3&gt;&lt;p&gt;1.1 分布式中的控制器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请求调用的负载
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180703</title>
    <link href="http://longman.kim/2018/07/03/%E5%89%A7%E6%9C%AC20180703/"/>
    <id>http://longman.kim/2018/07/03/剧本20180703/</id>
    <published>2018-07-03T11:20:51.000Z</published>
    <updated>2018-07-04T11:40:16.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-如何体现技术能力？"><a href="#1-如何体现技术能力？" class="headerlink" title="1. 如何体现技术能力？"></a>1. 如何体现技术能力？</h3><blockquote><p>今天看了刘未鹏的文章《怎样花两年时间去面试一个人》，总的感触就是识别一个优秀技术候选人是非常困难的。在学校与教育严重脱节的情况下，技术人员的甄别可以通过以下方法：  </p><ol><li>学历  </li><li>读过的书  </li><li>博客  </li><li>github的提交频率，别人的点赞  </li><li>算法<br>学历方面我在国内已经读了硕士，如果要提升的话，我理解进步的空间应该是去国外的top大学读个博士。如果想往这方面发展，英语是个大关卡。在读的书方面，工作之后读书少了，而且也没有完全理解。因此，我得给自己列个书单。<br><strong>基础书单</strong><br>《深入理解计算机系统》<br>《代码大全》<br>《编程珠玑》/《编程之美》<br>《计算机程序的构造和解释》<br>《设计模式》<br>《重构》<br>《程序员修理之道》<br>《深入理解Linux内核》<br>《TCP/IP详解》<br>《鸟哥的Linux私房菜-基础学习篇》<br>《软件随想录》<br>《黑客与画家》<br>《重来》<br>《编程人生》<br>《UNIX编程艺术》<br>《算法导论》<br>《盛田昭夫》<br>《杰克韦尔奇自传》<br><strong>语言</strong><br>《Effective C++》<br>《深度探索C++对象模型》<br>《C专家编程》<br>《Lua程序设计》<br>《Java编程思想》<br>《深入理解Java虚拟机》<br>《Effective Java》<br>《Java并发编程实战》<br>《Java并发编程的艺术》<br>《Java性能优化权威指南》<br><strong>前端</strong><br>《JavaScript高级程序设计》<br>《JavaScript权威指南》<br>《锋利的jQuery》<br><strong>架构</strong><br>《大型网站系统与Java中间件实践》<br>《大型网站技术架构:核心原理与案例分析》<br>《大型分布式网站架构设计与实践》<br>《大规模分布式存储系统》<br>《深入分析Java Web技术内幕》<br>《Redis设计与实现》<br>《MySQL技术内幕 : InnoDB存储引擎》<br>《微服务设计》<br>《从Paxos到Zookeeper》<br>《Netty权威指南 第2版》<br>《Docker: 容器与容器云》<br>《Head First设计模式》<br>我的博客也开始启动了，虽然不知道能坚持多久，但我还是会努力写下去。一个人在社会中很容易迷茫，只有列出清晰的目标，才能一步一个脚印的向前走。github的确是个好东西，可以自己写些小项目练手。可以自己给自己定需求，画设计，前端开发，后台开发，数据库管理等等。项目的形式可以从小到大，然后分享问题。也可以提供一些基础组件（轮子），让别人使用，打造自己的名气。算法的话，国外很重视，国内未来也会跟着国外走。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-如何体现技术能力？&quot;&gt;&lt;a href=&quot;#1-如何体现技术能力？&quot; class=&quot;headerlink&quot; title=&quot;1. 如何体现技术能力？&quot;&gt;&lt;/a&gt;1. 如何体现技术能力？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;今天看了刘未鹏的文章《怎样花两年时间去
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180701</title>
    <link href="http://longman.kim/2018/07/01/%E5%89%A7%E6%9C%AC20180701/"/>
    <id>http://longman.kim/2018/07/01/剧本20180701/</id>
    <published>2018-07-01T15:12:57.000Z</published>
    <updated>2018-07-03T11:19:20.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Guava-Cache的原理与实现"><a href="#1-Guava-Cache的原理与实现" class="headerlink" title="1. Guava Cache的原理与实现"></a>1. Guava Cache的原理与实现</h3><blockquote><p>单机缓存，比较简单的方法是自己用ConcurrentHashMap去实现。Guava Cache实现了自动回收，如果自己采用ConcurrentHashMap需要手动显示回收。Guava Cache提供三种缓存回收方法：基于容量回收，定时回收和基于引用回收。</p></blockquote><h3 id="2-BCOS的架构，技术原理，启动流程"><a href="#2-BCOS的架构，技术原理，启动流程" class="headerlink" title="2. BCOS的架构，技术原理，启动流程"></a>2. BCOS的架构，技术原理，启动流程</h3><blockquote><p>联盟链，参与者（PKI, CA证书，记账者，观察者，白名单，黑名单），共识机制（PBFT, RAFT），多链和跨链，分布式存储leveldb。</p></blockquote><h3 id="3-分布式理论CAP-BASE"><a href="#3-分布式理论CAP-BASE" class="headerlink" title="3. 分布式理论CAP,BASE"></a>3. 分布式理论CAP,BASE</h3><blockquote><p>一致性（C），可用性（A），分区容错性（P），三者不能够被同时满足。BASE代表基本可用，软状态，最终一致性。</p></blockquote><h3 id="4-分布式一致性算法2PC-3PC-PAXOS-ZAB-RAFT-PAFT-RBFT"><a href="#4-分布式一致性算法2PC-3PC-PAXOS-ZAB-RAFT-PAFT-RBFT" class="headerlink" title="4. 分布式一致性算法2PC, 3PC, PAXOS, ZAB, RAFT, PAFT, RBFT"></a>4. 分布式一致性算法2PC, 3PC, PAXOS, ZAB, RAFT, PAFT, RBFT</h3><h3 id="5-挖矿算法POW-POS-DPOS-Leader-BFT"><a href="#5-挖矿算法POW-POS-DPOS-Leader-BFT" class="headerlink" title="5. 挖矿算法POW, POS, DPOS, Leader, BFT"></a>5. 挖矿算法POW, POS, DPOS, Leader, BFT</h3><h3 id="6-消息中间件及RocketMQ模块分解"><a href="#6-消息中间件及RocketMQ模块分解" class="headerlink" title="6. 消息中间件及RocketMQ模块分解"></a>6. 消息中间件及RocketMQ模块分解</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Guava-Cache的原理与实现&quot;&gt;&lt;a href=&quot;#1-Guava-Cache的原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. Guava Cache的原理与实现&quot;&gt;&lt;/a&gt;1. Guava Cache的原理与实现&lt;/h3&gt;&lt;bl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty</title>
    <link href="http://longman.kim/2018/07/01/netty/"/>
    <id>http://longman.kim/2018/07/01/netty/</id>
    <published>2018-07-01T09:08:31.000Z</published>
    <updated>2018-07-01T09:08:31.454Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://longman.kim/2018/07/01/Golang/"/>
    <id>http://longman.kim/2018/07/01/Golang/</id>
    <published>2018-07-01T08:51:02.000Z</published>
    <updated>2018-07-01T08:51:02.784Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://longman.kim/2018/07/01/Docker/"/>
    <id>http://longman.kim/2018/07/01/Docker/</id>
    <published>2018-07-01T08:50:44.000Z</published>
    <updated>2018-07-01T08:50:44.697Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BCOS</title>
    <link href="http://longman.kim/2018/07/01/BCOS/"/>
    <id>http://longman.kim/2018/07/01/BCOS/</id>
    <published>2018-07-01T08:50:23.000Z</published>
    <updated>2018-07-01T08:50:23.201Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>超级账本</title>
    <link href="http://longman.kim/2018/07/01/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/"/>
    <id>http://longman.kim/2018/07/01/超级账本/</id>
    <published>2018-07-01T08:50:09.000Z</published>
    <updated>2018-07-01T08:50:09.308Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>以太坊</title>
    <link href="http://longman.kim/2018/07/01/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    <id>http://longman.kim/2018/07/01/以太坊/</id>
    <published>2018-07-01T08:49:54.000Z</published>
    <updated>2018-07-01T08:49:54.152Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>比特币</title>
    <link href="http://longman.kim/2018/07/01/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://longman.kim/2018/07/01/比特币/</id>
    <published>2018-07-01T08:49:40.000Z</published>
    <updated>2018-07-01T08:49:40.763Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RPC框架Dubbo, Motan, SpringCloud</title>
    <link href="http://longman.kim/2018/07/01/RPC%E6%A1%86%E6%9E%B6Dubbo-Motan-SpringCloud/"/>
    <id>http://longman.kim/2018/07/01/RPC框架Dubbo-Motan-SpringCloud/</id>
    <published>2018-07-01T08:49:17.000Z</published>
    <updated>2018-07-01T08:49:17.814Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式协调服务zookeeper</title>
    <link href="http://longman.kim/2018/07/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper/"/>
    <id>http://longman.kim/2018/07/01/分布式协调服务zookeeper/</id>
    <published>2018-07-01T08:48:47.000Z</published>
    <updated>2018-07-01T08:48:47.113Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式消息订阅系统Kafka</title>
    <link href="http://longman.kim/2018/07/01/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9FKafka/"/>
    <id>http://longman.kim/2018/07/01/分布式消息订阅系统Kafka/</id>
    <published>2018-07-01T08:48:16.000Z</published>
    <updated>2018-07-01T08:48:16.595Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>加入开源项目nutz</title>
    <link href="http://longman.kim/2018/07/01/%E5%8A%A0%E5%85%A5%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEnutz/"/>
    <id>http://longman.kim/2018/07/01/加入开源项目nutz/</id>
    <published>2018-07-01T08:47:23.000Z</published>
    <updated>2018-07-01T08:47:23.519Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java之外的世界</title>
    <link href="http://longman.kim/2018/07/01/Java%E4%B9%8B%E5%A4%96%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://longman.kim/2018/07/01/Java之外的世界/</id>
    <published>2018-07-01T08:45:19.000Z</published>
    <updated>2018-07-01T09:12:53.138Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic"><a href="#1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic" class="headerlink" title="1. 消息中间件的两种模式：点对点的消息队列，发布/订阅的topic"></a>1. 消息中间件的两种模式：点对点的消息队列，发布/订阅的topic</h5><h5 id="2-消息中间件message消费失败怎么办？"><a href="#2-消息中间件message消费失败怎么办？" class="headerlink" title="2. 消息中间件message消费失败怎么办？"></a>2. 消息中间件message消费失败怎么办？</h5><h5 id="3-hbase与mysql的区别"><a href="#3-hbase与mysql的区别" class="headerlink" title="3. hbase与mysql的区别"></a>3. hbase与mysql的区别</h5><h5 id="4-mysql的事务隔离级别"><a href="#4-mysql的事务隔离级别" class="headerlink" title="4. mysql的事务隔离级别"></a>4. mysql的事务隔离级别</h5><h5 id="5-跨越多个数据库的事务"><a href="#5-跨越多个数据库的事务" class="headerlink" title="5. 跨越多个数据库的事务"></a>5. 跨越多个数据库的事务</h5><h5 id="6-如何保证数据一致性，缓存与DB的更新"><a href="#6-如何保证数据一致性，缓存与DB的更新" class="headerlink" title="6. 如何保证数据一致性，缓存与DB的更新"></a>6. 如何保证数据一致性，缓存与DB的更新</h5><h5 id="7-分布式发布订阅消息系统kafka"><a href="#7-分布式发布订阅消息系统kafka" class="headerlink" title="7. 分布式发布订阅消息系统kafka"></a>7. 分布式发布订阅消息系统kafka</h5><h5 id="8-分布式协调服务zookeeper"><a href="#8-分布式协调服务zookeeper" class="headerlink" title="8. 分布式协调服务zookeeper"></a>8. 分布式协调服务zookeeper</h5><h5 id="9-RPC框架dubbo-dubbox-motan-thrift-grpc-avro-SpringCloud"><a href="#9-RPC框架dubbo-dubbox-motan-thrift-grpc-avro-SpringCloud" class="headerlink" title="9. RPC框架dubbo, dubbox, motan, thrift, grpc, avro, SpringCloud"></a>9. RPC框架dubbo, dubbox, motan, thrift, grpc, avro, SpringCloud</h5><h5 id="10-消息中间件RabbitMQ-ActiveMQ-RocketMQ-Redis-Kafka-ZeroMQ"><a href="#10-消息中间件RabbitMQ-ActiveMQ-RocketMQ-Redis-Kafka-ZeroMQ" class="headerlink" title="10. 消息中间件RabbitMQ, ActiveMQ, RocketMQ, Redis, Kafka, ZeroMQ"></a>10. 消息中间件RabbitMQ, ActiveMQ, RocketMQ, Redis, Kafka, ZeroMQ</h5><h5 id="11-分布式常见问题"><a href="#11-分布式常见问题" class="headerlink" title="11. 分布式常见问题"></a>11. 分布式常见问题</h5><h5 id="12-如何做异常的监控"><a href="#12-如何做异常的监控" class="headerlink" title="12. 如何做异常的监控"></a>12. 如何做异常的监控</h5><h5 id="13-go语言的协程与c-和python的对比"><a href="#13-go语言的协程与c-和python的对比" class="headerlink" title="13. go语言的协程与c++和python的对比"></a>13. go语言的协程与c++和python的对比</h5><h5 id="14-区块链技术的介绍"><a href="#14-区块链技术的介绍" class="headerlink" title="14. 区块链技术的介绍"></a>14. 区块链技术的介绍</h5><h5 id="15-过去一年最自豪的一件事情"><a href="#15-过去一年最自豪的一件事情" class="headerlink" title="15. 过去一年最自豪的一件事情"></a>15. 过去一年最自豪的一件事情</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic&quot;&gt;&lt;a href=&quot;#1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic&quot; class=&quot;headerlink&quot; title=&quot;1. 消息中间件的两种模式：点对点的消息队列，发布/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本1</title>
    <link href="http://longman.kim/2018/06/30/%E5%89%A7%E6%9C%AC1/"/>
    <id>http://longman.kim/2018/06/30/剧本1/</id>
    <published>2018-06-30T13:33:08.000Z</published>
    <updated>2018-07-01T04:02:58.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-人生如戏"><a href="#1-人生如戏" class="headerlink" title="1. 人生如戏"></a>1. 人生如戏</h3><p>&emsp;&emsp;有人说一生很长，有人说一生很短，但长短真的那么重要吗？人终究会死，死了就什么也没有了。没有烦恼，没有快乐。衡量人生的长短是没有任何意义的，有人活着他已经死了，有人死了他还活着。关键是人的价值，在历史中的价值，那才是人应该去追求的真谛。让我们静下心想想应该怎么过完自己的一生，是庸庸碌碌，还是人生如戏。没有梦想，人和咸鱼有什么区别？但现实情况是，我们大多数人就是咸鱼。我们的梦想是赚钱，赚很多的钱，让自己买得起车买得起房。然后呢，我们没有然后。钱，成为了生存下来的唯一目标。天下熙熙皆为利来，天下攘攘皆为利往。我们有问过自己，到底自己想要什么吗？没有，时间推着我们走，走到哪里算哪里。人生本不该如此，人生如戏，我们要做自己的主宰，做设计人生的导演，做表演人生的演员。这是一场戏，没有NG，所有的镜头必须一次过。这场戏中，我们无法自欺欺人，唯有亲身示范。</p><h3 id="2-优秀的导演"><a href="#2-优秀的导演" class="headerlink" title="2. 优秀的导演"></a>2. 优秀的导演</h3><p>&emsp;&emsp;每一个人生都有自己的主题，有的是喜剧，有的是悲剧，有的是无厘头。里面的主角也各不相同，他们在各自的圈子里演绎自己的人生。在这出戏里，一个关键的人物就是导演。他要构思剧本，调整灯光，整理道具，搭建舞台。他是这出戏的总设计师，是这出戏唯一的领班人。没有其他人可以，但不能没有导演。那作为一个导演应该怎么做呢？每一出戏，导完了，导演的作用也就消失了。戏只有一部，成败在此一举。所以，导演要给自己的戏定性。剧情究竟是一波三折呢，还是全局开挂？什么时候能看到戏的高潮？戏里的每一分每一秒，导演都需要精雕细琢，容不得半点放水。导演的职责是什么呢？设计好台词，把灯光调的切合剧情氛围一些，让舞台变得更大，清除外界的干扰。<br>&emsp;&emsp;如果我是导演，我该怎么设计好人生的这场大戏呢？一个出生贫苦的乡下孩子，在少年时代享受了成绩优秀带来的快感。当他的圈子慢慢变大后，他的优秀变得不那么明显。不过在小圈子内，他还是可以自我陶醉，因为他的部分优秀。在他进入大学后，他的人生没有明确的目标，但他延续了之前的部分努力，所以在糊里糊涂中读了研究生。大学4年，研究生3年，在这7年的时间里，他始终认为自己像小学时候一样优秀。直到他在名企实习，但却没有被最终留用后，他发现了自己的落后。他想改，可以蹉跎的7年，懒惰的惯性让我总是无法走出困境。工作两年，当领导在他的评语上留下了不能胜任工作的时候，他开始恐慌。他突然发现，自己真的落后了，并且他已经30岁了，然而还是无法一技压身。他开始痛苦，开始彷徨，开始自我怀疑，以为自己的人生就这样完了。<br>&emsp;&emsp;然而，生活的挫折并没有将他打到。他改变了自己，给自己设定了明确的目标。从外在的发型，眼镜，着装，走路的姿势，说话的语气，面部的表情，待人的真诚，到内在的价值观，人生观，知识面等等。他喜欢公开表达自己对时事的观点，对政策的目的进行了分析，喜欢和别人进行深入的沟通，待人接物更加礼貌更加友善。他每天笑脸迎人，充满阳光与活力，身上散发着睿智的气息。他深知人性，能化尴尬为幽默，让他人在与他相处时，开心快乐。他精通数学与英语，能够快速心算。同时，对高等数学十分热爱，喜欢抽象生活中的小细节。他能讲一口流利的英语，在和外国人的交流时能够侃侃而谈，自然亲切。他拥有深厚的专业知识，对自己领域的每个小细节都清清楚楚。对所有的专业知识，都烂熟于心。在不断的实践过程中，他努力总结，总能做到举一反三，触类旁通。对国内外最新的专业动态，他都时刻关注，并尽早使用。同时，他在不断构建自己的技术壁垒。从参与新事物，到自己能够创造新事物。在这个自我不断改变的过程中，他收获了金钱，职称。他的心态有了明显的变化，自己在社会上有一定的地位了，生活有了保障了。但他总感觉缺少什么似的，他发现自己努力的结果，最终还是让自己过上富足的生活。而他的初衷是让自己在历史的长河中流芳千古呀，当发现自己无力改变这个现实时，他突然变得沮丧。他突然对天发问，这一切究竟是否是他想要的。时间还是不停流转，慢慢他发现人是渺小的，是否伟大也没有那么有意义。人都死了，被后人称赞伟大又有什么用呢？难道在九泉之下，就会因为后人的歌颂而复活吗？人生没有那么复杂，只是人把它想复杂了。简简单单，做自己喜欢做的事情，然后做到专业。开开心心，幸福快乐的活着。</p><h3 id="3-优秀的演员"><a href="#3-优秀的演员" class="headerlink" title="3. 优秀的演员"></a>3. 优秀的演员</h3><p>&emsp;&emsp;优秀的演员是可以练出来的，伟大的演员依靠天赋。只有十年如一日的练习，才能做到剧本台词烂熟于心，表情动作轻车熟路。有了导演的指导，演员只需要不断的修行自己。在导演构建的大框架之下，运用自己的才能在细微之处做创新。具体如何实施呢，让自己回到高三时代。拥有明确的目标，规律的作息，合理的运动，持之以恒的学习。作为一个执行者，没有捷径可走，唯一的路就是持之以恒，不断学习。</p><h3 id="4-精彩的人生"><a href="#4-精彩的人生" class="headerlink" title="4. 精彩的人生"></a>4. 精彩的人生</h3><p>&emsp;&emsp;精彩的人生应该是什么样子的，是争斗的快乐，与人争斗的快乐。是智慧的博弈，是肉体的厮杀。是对弱者的碾压，是对强者的崇拜。人性的完全释放，不在压抑，让自己的情绪改变世界。成为世界的主宰，掌握生命的权利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-人生如戏&quot;&gt;&lt;a href=&quot;#1-人生如戏&quot; class=&quot;headerlink&quot; title=&quot;1. 人生如戏&quot;&gt;&lt;/a&gt;1. 人生如戏&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有人说一生很长，有人说一生很短，但长短真的那么重要吗？人终究会死，死了就什么也没
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java基础知识点</title>
    <link href="http://longman.kim/2018/06/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://longman.kim/2018/06/28/Java基础知识点/</id>
    <published>2018-06-27T17:02:04.000Z</published>
    <updated>2018-06-30T02:53:27.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h3><h5 id="1-ThreadPoolExecutor线程池"><a href="#1-ThreadPoolExecutor线程池" class="headerlink" title="1. ThreadPoolExecutor线程池"></a>1. ThreadPoolExecutor线程池</h5><h5 id="2-HashTable-TreeMap-LinkedHashMap-HashMap-HashSet-ArraryList-CurrentHashMap"><a href="#2-HashTable-TreeMap-LinkedHashMap-HashMap-HashSet-ArraryList-CurrentHashMap" class="headerlink" title="2. HashTable, TreeMap, LinkedHashMap, HashMap, HashSet, ArraryList, CurrentHashMap"></a>2. HashTable, TreeMap, LinkedHashMap, HashMap, HashSet, ArraryList, CurrentHashMap</h5><blockquote><p>HashTable不支持null键和null值，HashMap支持<br>HashTable和HashMap都是用哈希表，采用链地址法解决冲突<br>HashTable容量扩充时2n+1,为奇数使得数据分布均匀。HashMap容量扩充时2的幂次方，采用位运算，效率高，但增加了哈希冲突。为了减少哈希冲突，在计算hashcode时，HashMap做了位运算打散数据。在JDK8中，如果链表的长度大于8，将采用红黑树来存储。<br>HashTable是线程安全的，HashMap是线程不安全的，CurrentHashMap是线程安全的，HashTable已经被淘汰了<br>ConcurrentHashMap常用于缓存，在读操作多于写操作时，更加合适<br>HashMap在并发编程中会造成链中出现环，导致死循环。HashTable用的syncronized是互斥锁，效率下降很严重。ConcurrentHashMap采用分段锁技术，不同段争抢不同的锁，充分利用volatile的可见性，get不需要锁，put需要锁。<br>LinkedHashMap是有序的，它保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时带参数，按照应用次数排序。场景，输出的顺序与输入的顺序相同。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序。默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。场景，按自然顺序或者自定义顺序遍历。<br>HashSet是Set的一个实现类，以对象作为元素，不允许相同的元素。<br>ArraryList和Vector都是通过数组实现，但Vector支持线程同步，LinkedList是通过链表实现  </p></blockquote><h5 id="3-String-StringBuilder-StringBuffer"><a href="#3-String-StringBuilder-StringBuffer" class="headerlink" title="3. String, StringBuilder, StringBuffer"></a>3. String, StringBuilder, StringBuffer</h5><blockquote><p>String类是final类，final类是不能被继承的，而且final类中的方法都是final的。String中用char数组保存字符串，String一旦被创建就是固定不变的了，任何对String的修改都将生成新的String对象。<br>静态常量池是指.class中保存的字面量，运行时常量池保存在方法区中。String a = “ok”;String b = “ok”; String c = new String(“ok”), 在这里a,b执行方法区常量池中的对象，而c指向堆中的对象，只要是new出来的，在堆中就会有一份对象，所以a = b != c。再举个例子String a = “helloworld”; String b = “helloworld”; String c = “hello” + “world”. 在这里a = b = c, 因为当一个字符串是由多个字符串常量连接而成时，它本身也是字符串常量。字面量”+”拼接在编译期间进行，拼接后的字符串放在常量池中，而字符串引用的”+”拼接在运行时创建，新创建的字符串放在堆中。<br>intern方法的使用，对于任意两个字符串s和t, 当且仅当s.equals(t)为true时，s.intern()==t.intern()才为true.当一个String实例调用intern方法时，java会在常量池中找是否有相同的字符串常量，如果有，则返回其引用。如果没有，就在常量池中创建一个，然后返回其引用。<br>==用于基本数据类型的比较，equals用于对象的比较。如果equals没有重写，比较是引用。如果equals重写了，比较的是内容。String, Double, Date, Integer都进行了重写，比较的是内容。<br>运行速度方面StringBuilder>StringBuffer>String，因为添加字符串String涉及重新分配内存及回收内存。StringBuffer是线程安全的，在操作上加了syncronized, StringBuilder不是线程安全的。<br>String适用于少量的字符串操作，StringBuilder适用于单线程下在字符缓冲区进行大量的操作，StringBuffer适用于多线程下在字符缓冲区进行大量操作。  </p></blockquote><h5 id="4-ThreadLocal"><a href="#4-ThreadLocal" class="headerlink" title="4. ThreadLocal"></a>4. ThreadLocal</h5><blockquote><p>ThreadLocal为每个线程创建变量的副本，方式是每个线程内部有一个ThreadLocal.ThreadLocalMap。使用的应用场景数据库连接，Session管理。</p></blockquote><h5 id="5-CopyOnWrite机制，线程安全，CopyOnWriteArrayList-CopyOnWriteArrarySet"><a href="#5-CopyOnWrite机制，线程安全，CopyOnWriteArrayList-CopyOnWriteArrarySet" class="headerlink" title="5. CopyOnWrite机制，线程安全，CopyOnWriteArrayList, CopyOnWriteArrarySet"></a>5. CopyOnWrite机制，线程安全，CopyOnWriteArrayList, CopyOnWriteArrarySet</h5><blockquote><p>写时复制技术，每个修改之前都加ReentrantLock使并发写互斥。读写分离，读写可能不一致，不保证实时一致性，保证最终一致性。</p></blockquote><h5 id="6-volatile-syncronized-偏向锁，自旋锁，ReentrantLock-Condition-CountDownLatch-CycliBarrier-Semaphore-ReentrantReadAndWriteLock-Timer-乐观锁，悲观锁，可重入锁"><a href="#6-volatile-syncronized-偏向锁，自旋锁，ReentrantLock-Condition-CountDownLatch-CycliBarrier-Semaphore-ReentrantReadAndWriteLock-Timer-乐观锁，悲观锁，可重入锁" class="headerlink" title="6. volatile, syncronized, 偏向锁，自旋锁，ReentrantLock, Condition, CountDownLatch, CycliBarrier, Semaphore, ReentrantReadAndWriteLock, Timer, 乐观锁，悲观锁，可重入锁"></a>6. volatile, syncronized, 偏向锁，自旋锁，ReentrantLock, Condition, CountDownLatch, CycliBarrier, Semaphore, ReentrantReadAndWriteLock, Timer, 乐观锁，悲观锁，可重入锁</h5><blockquote><ol><li>自旋锁，正常情况下，如果线程没有抢到锁，它的线程状态会变成阻塞。如果使用自旋锁，则线程不阻塞，它会一种循环等待（在另外一个核上，所以需要多核处理器）锁被其他线程释放，被称为忙等。自旋锁比较适合竞争不激烈的情况，缺点是浪费CPU资源。<strong><em>自适应自旋锁</em></strong>是指自旋等待的时间不固定，它会偏向给之前获得过该锁的线程更多的自旋等待时间。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SpinLock &#123;  </span><br><span class="line">private AutomicReference&lt;Thread&gt; sign = new AutomicReference&lt;&gt;();</span><br><span class="line">public void lock() &#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line">while (!sign.compareAndSet(null, current))&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line">sign.compareAndSet(current, null);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>重入锁  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Reentrant &#123;</span><br><span class="line">public syncronized void outer() &#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;</span><br><span class="line">public syncronized void inner() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>偏向锁，它会偏向第一个访问锁的线程。运行过程中，如果同步锁只有一个线程访问，不存在多线程争用的情况，则会给该线程一个偏向锁。如果遇到其他线程抢占锁，则偏向锁被挂起，锁被恢复为标准的轻量锁。适合只有一个线程访问同步块的场景。  </li><li>乐观锁，乐观的思想，认为读多写少。更新的时候判断下是否被别人更新过，过程是读-&gt;比较-&gt;写，一般采用版本号的方法。java中乐观锁的实现是通过CAS。  </li><li>悲观锁，认为写多，每次读写都会上锁，其他线程想读写数据会被阻塞。java中的悲观锁就是Syncronize，在使用AQS框架下的锁时，会先尝试使用CAS乐观锁去获取锁，获取不到，才会转换为悲观锁，例如ReentrantLock就是这种策略。  </li><li>重量级锁syncronized，追求吞吐量，适合同步块执行时间长的场景。  </li><li>轻量级锁</li></ol></blockquote><h5 id="7-Java的并发包current中的AQS-CAS-ArrayBlockingQueue-LinkedBlockingQueue-Unsafe-Locksupport"><a href="#7-Java的并发包current中的AQS-CAS-ArrayBlockingQueue-LinkedBlockingQueue-Unsafe-Locksupport" class="headerlink" title="7. Java的并发包current中的AQS, CAS, ArrayBlockingQueue, LinkedBlockingQueue, Unsafe, Locksupport"></a>7. Java的并发包current中的AQS, CAS, ArrayBlockingQueue, LinkedBlockingQueue, Unsafe, Locksupport</h5><blockquote><p>下面四种锁都是通过AQS实现  </p><ol><li>ReentrantLock，记录当前线程获得原子状态的次数，大于0获得了重进入的效果，其他线程被park，等于0代表释放了原子状态。ReentrantLock是可重入的。  </li><li>Semaphore记录当前还有多少次许可可以使用，为0时就需要等待了，实现了并发量的控制。  </li><li>CountDownLatch闭锁要保持其状态，在这个状态达到终止态之前，所有线程park，闭锁设置初始值，这个值就是闭锁需要被countDown()的次数。只有初始值变为0时，等待的所有线程才通过。  </li><li>FutureTask  </li></ol></blockquote><h5 id="8-线程生命周期，wait-sleep"><a href="#8-线程生命周期，wait-sleep" class="headerlink" title="8. 线程生命周期，wait(), sleep()"></a>8. 线程生命周期，wait(), sleep()</h5><h5 id="9-Java-IO-Java-NIO-NIO的底层实现-Selector-Channel-ByteBuffer"><a href="#9-Java-IO-Java-NIO-NIO的底层实现-Selector-Channel-ByteBuffer" class="headerlink" title="9. Java IO, Java NIO, NIO的底层实现, Selector, Channel, ByteBuffer"></a>9. Java IO, Java NIO, NIO的底层实现, Selector, Channel, ByteBuffer</h5><h5 id="10-Java代理Proxy-CLIB代理，ASM"><a href="#10-Java代理Proxy-CLIB代理，ASM" class="headerlink" title="10. Java代理Proxy, CLIB代理，ASM"></a>10. Java代理Proxy, CLIB代理，ASM</h5><h5 id="11-反射的作用与原理"><a href="#11-反射的作用与原理" class="headerlink" title="11. 反射的作用与原理"></a>11. 反射的作用与原理</h5><blockquote><p>Java在运行时能够动态获取类的信息并调用类的方法称为Java的反射，它的原理主要是通过分析.class文件中的字节码，得到类，类的属性和方法。使用反射主要借助下面四个类：Class, Constructor, Field, Method</p></blockquote><h5 id="12-Java异常的层次结构"><a href="#12-Java异常的层次结构" class="headerlink" title="12. Java异常的层次结构"></a>12. Java异常的层次结构</h5><h5 id="13-类的加载机制，可能出现的问题"><a href="#13-类的加载机制，可能出现的问题" class="headerlink" title="13. 类的加载机制，可能出现的问题"></a>13. 类的加载机制，可能出现的问题</h5><blockquote><ol><li>Bootstrap Classloader由C++写类加载器，它加载java核心类库以及bootclasspath指定路径下的jar包，主要是以java, javax, sun开头的类。Extension Classloader用来加载扩展类，主要是ext及ext.dirs指定路径下的jar包。Application Classloader是标准的系统加载类，它加载classpath指定路径下的jar包，也是系统默认的类加载器。  </li><li>双亲委派机制，当一个类加载器收到加载请求时，它首先会让父类去加载（父类会将请求传递到它自己的父类，直到Bootstrap Classloader），直到父类不能加载时，它才去尝试加载。好处是具备了一种带优先级的的层次关系，保证java程序的稳定运行。  </li><li>类加载器加载类的顺序：检查该类是否已经被加载了，如果没有被加载，首先调用父类加载器，如果父类加载器不能加载这个类，则尝试加载这个类  </li><li>类加载过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</li></ol></blockquote><h5 id="14-序列化与反序列化"><a href="#14-序列化与反序列化" class="headerlink" title="14. 序列化与反序列化"></a>14. 序列化与反序列化</h5><h5 id="15-hashcode-equals"><a href="#15-hashcode-equals" class="headerlink" title="15. hashcode, equals"></a>15. hashcode, equals</h5><h5 id="16-Java强引用，软引用，弱引用，虚引用"><a href="#16-Java强引用，软引用，弱引用，虚引用" class="headerlink" title="16. Java强引用，软引用，弱引用，虚引用"></a>16. Java强引用，软引用，弱引用，虚引用</h5><h5 id="17-Java垃圾回收，可达性分析，标记清除-整理，复制，分代收集，Serial-Parallel-CMS-G1"><a href="#17-Java垃圾回收，可达性分析，标记清除-整理，复制，分代收集，Serial-Parallel-CMS-G1" class="headerlink" title="17. Java垃圾回收，可达性分析，标记清除/整理，复制，分代收集，Serial, Parallel, CMS, G1"></a>17. Java垃圾回收，可达性分析，标记清除/整理，复制，分代收集，Serial, Parallel, CMS, G1</h5><h5 id="18-Callable-CompletableFuture-Future-FutureTask"><a href="#18-Callable-CompletableFuture-Future-FutureTask" class="headerlink" title="18. Callable, CompletableFuture, Future, FutureTask"></a>18. Callable, CompletableFuture, Future, FutureTask</h5><h5 id="19-分布式锁的实现"><a href="#19-分布式锁的实现" class="headerlink" title="19. 分布式锁的实现"></a>19. 分布式锁的实现</h5><h5 id="20-限流，降级"><a href="#20-限流，降级" class="headerlink" title="20. 限流，降级"></a>20. 限流，降级</h5><h5 id="21-负载均衡-全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy-Nginx"><a href="#21-负载均衡-全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy-Nginx" class="headerlink" title="21. 负载均衡(全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy/Nginx)"></a>21. 负载均衡(全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy/Nginx)</h5><h5 id="22-Spring-SpringMVC-SpringBoot原理与流程，IOC-AOP"><a href="#22-Spring-SpringMVC-SpringBoot原理与流程，IOC-AOP" class="headerlink" title="22. Spring, SpringMVC, SpringBoot原理与流程，IOC, AOP"></a>22. Spring, SpringMVC, SpringBoot原理与流程，IOC, AOP</h5><h5 id="23-netty-rocketmq"><a href="#23-netty-rocketmq" class="headerlink" title="23. netty, rocketmq"></a>23. netty, rocketmq</h5><h5 id="24-秒杀系统的设计，微信红包的社交，海量数据的分析"><a href="#24-秒杀系统的设计，微信红包的社交，海量数据的分析" class="headerlink" title="24. 秒杀系统的设计，微信红包的社交，海量数据的分析"></a>24. 秒杀系统的设计，微信红包的社交，海量数据的分析</h5><h5 id="25-redis-mysql，事务，索引，2PC-3PC，ACID，一致性哈希"><a href="#25-redis-mysql，事务，索引，2PC-3PC，ACID，一致性哈希" class="headerlink" title="25. redis, mysql，事务，索引，2PC/3PC，ACID，一致性哈希"></a>25. redis, mysql，事务，索引，2PC/3PC，ACID，一致性哈希</h5><h5 id="26-TCP三次握手四次挥手，滑动窗口"><a href="#26-TCP三次握手四次挥手，滑动窗口" class="headerlink" title="26. TCP三次握手四次挥手，滑动窗口"></a>26. TCP三次握手四次挥手，滑动窗口</h5><h5 id="27-linux命令grep-awk-sed-top-jstat-jstack-free-jmap"><a href="#27-linux命令grep-awk-sed-top-jstat-jstack-free-jmap" class="headerlink" title="27. linux命令grep, awk, sed, top, jstat, jstack, free, jmap"></a>27. linux命令grep, awk, sed, top, jstat, jstack, free, jmap</h5><h5 id="28-常用设计模式"><a href="#28-常用设计模式" class="headerlink" title="28. 常用设计模式"></a>28. 常用设计模式</h5><h5 id="29-Servlet与容器，Servlet生命周期，JSP"><a href="#29-Servlet与容器，Servlet生命周期，JSP" class="headerlink" title="29. Servlet与容器，Servlet生命周期，JSP"></a>29. Servlet与容器，Servlet生命周期，JSP</h5><h5 id="30-通用算法"><a href="#30-通用算法" class="headerlink" title="30. 通用算法"></a>30. 通用算法</h5><h5 id="31-C-对象模型，虚函数表"><a href="#31-C-对象模型，虚函数表" class="headerlink" title="31. C++对象模型，虚函数表"></a>31. C++对象模型，虚函数表</h5><h5 id="32-SimpleDateFormat线程不安全"><a href="#32-SimpleDateFormat线程不安全" class="headerlink" title="32. SimpleDateFormat线程不安全"></a>32. SimpleDateFormat线程不安全</h5><blockquote><p>当多个线程共享一个SimpleDateFormat对象时，由于SimpleDateFormat执行format, parse操作时，是使用自己的成员变量Calendar，也就意味着多个线程共享该Calendar。这个Calendar的初始化是由调用方决定的，A线程设置Calendar为1990, 在A执行parse或者format之前，B线程设置Calendar为2018，这时A再执行parse或者format会报错。</p></blockquote><h5 id="33-如何权衡可用性和一致性"><a href="#33-如何权衡可用性和一致性" class="headerlink" title="33. 如何权衡可用性和一致性"></a>33. 如何权衡可用性和一致性</h5><h5 id="34-C-中的模板和Java中泛型有何异同？"><a href="#34-C-中的模板和Java中泛型有何异同？" class="headerlink" title="34. C++中的模板和Java中泛型有何异同？"></a>34. C++中的模板和Java中泛型有何异同？</h5><h5 id="35-Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？"><a href="#35-Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？" class="headerlink" title="35. Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？"></a>35. Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？</h5><h5 id="36-SpringBoot原理机制和启动流程"><a href="#36-SpringBoot原理机制和启动流程" class="headerlink" title="36. SpringBoot原理机制和启动流程"></a>36. SpringBoot原理机制和启动流程</h5><h5 id="37-Java中的阻塞队列"><a href="#37-Java中的阻塞队列" class="headerlink" title="37. Java中的阻塞队列"></a>37. Java中的阻塞队列</h5><blockquote></blockquote><h5 id="38-select-poll-epool"><a href="#38-select-poll-epool" class="headerlink" title="38. select, poll, epool"></a>38. select, poll, epool</h5><blockquote><p>都是同步非阻塞的IO多路复用方式，都会在select操作上阻塞。select/poll会顺序扫描fd是否就绪，而且支持的fd数量有限。epool基于事件驱动的方式，不是采用顺序扫描，当fd就绪时，立即回调函数rollback。</p></blockquote><h5 id="39-BeanFactory和FactoryBean"><a href="#39-BeanFactory和FactoryBean" class="headerlink" title="39. BeanFactory和FactoryBean"></a>39. BeanFactory和FactoryBean</h5><blockquote><p>BeanFactory是一个Bean工厂，作用就是配置，新建，管理各种Bean。FactoryBean是一个Bean，类型是工厂Bean，用来管理Bean，它本身由Spring管理。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java基础知识点&quot;&gt;&lt;a href=&quot;#Java基础知识点&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识点&quot;&gt;&lt;/a&gt;Java基础知识点&lt;/h3&gt;&lt;h5 id=&quot;1-ThreadPoolExecutor线程池&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式锁的三种实现方式</title>
    <link href="http://longman.kim/2018/06/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://longman.kim/2018/06/19/分布式锁的三种实现方式/</id>
    <published>2018-06-19T14:07:51.000Z</published>
    <updated>2018-06-19T14:07:51.993Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>全局唯一序列号的生成方法</title>
    <link href="http://longman.kim/2018/06/19/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/"/>
    <id>http://longman.kim/2018/06/19/全局唯一序列号的生成方法/</id>
    <published>2018-06-19T14:07:32.000Z</published>
    <updated>2018-06-19T14:07:32.416Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的异常处理</title>
    <link href="http://longman.kim/2018/06/19/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://longman.kim/2018/06/19/Java的异常处理/</id>
    <published>2018-06-19T14:05:26.000Z</published>
    <updated>2018-06-19T14:05:26.685Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的垃圾回收算法</title>
    <link href="http://longman.kim/2018/06/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://longman.kim/2018/06/19/Java的垃圾回收算法/</id>
    <published>2018-06-19T07:14:41.000Z</published>
    <updated>2018-06-19T13:30:38.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java运行时的数据区域"><a href="#Java运行时的数据区域" class="headerlink" title="Java运行时的数据区域"></a>Java运行时的数据区域</h3><blockquote><ul><li>线程私有：jvm虚拟机栈，程序计数器，本地方法栈</li><li>线程公有：堆，方法区（常量，静态变量等），执行引擎，本地库的接口</li><li>堆外内存，利用NIO</li></ul></blockquote><h3 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h3><h5 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h5><blockquote><p>记录对象的引用次数，当对象被引用时，记录加1，当对象失效时，记录减1，当记录为0时，代表记录已死，可以被回收。<br>存在的一个问题是循环引用，例如A引用B，B又引用A。</p></blockquote><h5 id="2-可达性分析（根搜索法）"><a href="#2-可达性分析（根搜索法）" class="headerlink" title="2. 可达性分析（根搜索法）"></a>2. 可达性分析（根搜索法）</h5><blockquote><ol><li>哪些对象可以作为根  <ul><li>jvm栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象</li></ul></li><li>强引用，软引用，弱引用，虚引用<ul><li>new出来的对象是强引用</li><li>SoftReference来实现软引用，当内存不够用时，濒临逸出的情况下，gc就会把软引用的对象回收</li><li>WeakReference来实现弱引用，弱引用的对象将会在下一次的gc被回收</li><li>PhantomReference来实现虚引用，虚引用没有办法访问对象实例</li></ul></li></ol></blockquote><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h5 id="1-标记清除"><a href="#1-标记清除" class="headerlink" title="1. 标记清除"></a>1. 标记清除</h5><blockquote><p>标记已死的对象，并清除掉，缺点是效率低并造成内存碎片</p></blockquote><h5 id="2-标记整理"><a href="#2-标记整理" class="headerlink" title="2. 标记整理"></a>2. 标记整理</h5><blockquote><p>标记存活的对象，并把它们移到一端，清除掉边界以外的内存</p></blockquote><h5 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h5><blockquote><p>将内存分为相等的两块A，B。首先只在A区块分配内存给对象，当A区块满了的时候，<br>将A区块中存活的对象复制到B区块，清理到A区块。然后在B区块中分配内存给对象，当B<br>区块满了的时候，将B区块中存活的对象复制到A区块，清理到B区块，依次循环。<br>实际在HotSpot中，分为8:1:1的三块即Eden，SurvivorFrom，SurvivorTo，具体执行<br>流程如下：</p><ol><li>Eden第一次GC，将Eden中存活的对象复制到SurvivorFrom中，清空Eden</li><li>Eden第二次GC，将Eden和SurvivorFrom中存活的对象复制到SurvivorTo中，清空<br>Eden和SurvivorFrom</li><li>Eden第三次GC，将Eden和SurvivorTo中存活的对象复制到SurvivorFrom中，清空<br>Eden和SurvivorTo</li><li>后续SurvivorFrom和SurvivorTo依次交换</li></ol></blockquote><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h5 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h5><blockquote><p>单线程，暂停用户线程<br>新生代采用复制算法，老年代采用标记整理算法</p></blockquote><h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><blockquote><p>多线程，暂停用户线程<br>新生代采用复制算法，老年代采用标记整理算法</p></blockquote><h5 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h5><blockquote><p>吞吐量优先</p></blockquote><h5 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h5><blockquote><p>Serial的老年代版本</p></blockquote><h5 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h5><blockquote><p>Parallel Scavenge的老年代版本</p></blockquote><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><blockquote><p>最短回收停顿时间</p><ul><li>初始标记（耗时极短，暂停用户线程）</li><li>并发标记（耗时长，不暂停用户线程）</li><li>重新标记（耗时极短，暂停用户线程，修正并发标记期间的变化）</li><li>并发清除（耗时长，不暂停用户线程）</li></ul></blockquote><h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><blockquote><p>把堆栈分为多个域，每次仅从一个域收集垃圾，也可理解为把堆栈分成一小块一小块，每次仅对某一个块进行垃圾收集。这会造成较小的应用程序中断时间，使得用户一般不能觉察到垃圾收集器正在工作。</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记标记</li><li>筛选回收</li></ul></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h5 id="GC触发的条件"><a href="#GC触发的条件" class="headerlink" title="GC触发的条件"></a>GC触发的条件</h5><blockquote><ul><li>minor gc<ul><li>当Eden区满了的时候</li></ul></li><li>full gc<ul><li>minor gc时，Eden区和SurvivorFrom中存活的对象大于SurvivorTo，把<br>该对象转移到老年代，但是老年代的可用空间也小于这些对象</li><li>方法区空间不足</li><li>老年代空间不足</li><li>系统调用System.gc时有可能会full gc</li></ul></li></ul></blockquote><h5 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h5><blockquote><ul><li>每个对象的finalize只能被调用一次</li><li>如果在finalize中有引用该对象，则该对象被复活，但下次回收时，仍然被回收，因为finalize只能被调用一次</li><li>任何地方都可以调用finalize，但是其结果未知</li><li>System.gc可以执行垃圾回收</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java运行时的数据区域&quot;&gt;&lt;a href=&quot;#Java运行时的数据区域&quot; class=&quot;headerlink&quot; title=&quot;Java运行时的数据区域&quot;&gt;&lt;/a&gt;Java运行时的数据区域&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;线程私有：jvm虚拟机
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="http://longman.kim/2018/06/19/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://longman.kim/2018/06/19/hexo常用命令/</id>
    <published>2018-06-19T06:59:04.000Z</published>
    <updated>2018-06-19T07:06:09.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h3><p>清空缓存</p><h3 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h3><p>开启服务预览</p><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h3><p>新建文章</p><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a>hexo new page</h3><p>新建页面</p><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h3><p>生成静态文件到public</p><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><p>将.deploy部署到github</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hexo-clean&quot;&gt;&lt;a href=&quot;#hexo-clean&quot; class=&quot;headerlink&quot; title=&quot;hexo clean&quot;&gt;&lt;/a&gt;hexo clean&lt;/h3&gt;&lt;p&gt;清空缓存&lt;/p&gt;
&lt;h3 id=&quot;hexo-s&quot;&gt;&lt;a href=&quot;#hex
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于OpenResty</title>
    <link href="http://longman.kim/2018/06/18/%E5%85%B3%E4%BA%8EOpenResty/"/>
    <id>http://longman.kim/2018/06/18/关于OpenResty/</id>
    <published>2018-06-17T17:03:15.000Z</published>
    <updated>2018-06-17T17:03:15.954Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx的常见配置</title>
    <link href="http://longman.kim/2018/06/18/Nginx%E7%9A%84%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://longman.kim/2018/06/18/Nginx的常见配置/</id>
    <published>2018-06-17T17:02:55.000Z</published>
    <updated>2018-06-17T17:02:55.192Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go的协程</title>
    <link href="http://longman.kim/2018/06/18/Go%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <id>http://longman.kim/2018/06/18/Go的协程/</id>
    <published>2018-06-17T17:02:31.000Z</published>
    <updated>2018-06-17T17:02:31.799Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="http://longman.kim/2018/06/18/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://longman.kim/2018/06/18/Java动态代理/</id>
    <published>2018-06-17T17:02:04.000Z</published>
    <updated>2018-06-21T06:11:00.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring最重要的一个特点就是AOP，面向切面编程。它以织入的方式向系统中添加非业务功能的代码，例如参数检验，安全验证等。这个功能使得代码的逻辑变得更加清晰，它的底层实现方式正是Java的动态代理。举个例子，在Spring中如果我们定义了一个类，然后类中有一个@Async修饰的方法，在Spring启动时会为这个类生成一个代理类。在Spring AOP中，当拦截对象实现了接口时，使用的是JDK的Proxy类，如果没有实现接口则使用GCLIB生成拦截类的子类。<br>首先看看下面两个接口User和Client，以及实现了两个接口的CommonImpl，我们现在要实现CommonImpl的代理，在CommonImpl中某些方法的前后添加一些功能。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface User &#123;</span><br><span class="line">    void insert();</span><br><span class="line">    void update();</span><br><span class="line">    void delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Client &#123;</span><br><span class="line">    void one();</span><br><span class="line">    void two();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CommonImpl implements User, Client &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void insert() &#123;</span><br><span class="line">        System.out.println(&quot;insert&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    publid void update() &#123;</span><br><span class="line">        System.out.println(&quot;update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;delete&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void one() &#123;</span><br><span class="line">        System.out.println(&quot;one&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void two() &#123;</span><br><span class="line">        System.out.println(&quot;two&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>静态代理可以理解为设计模式中的装饰器模式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DecorateCommon implements User, Client &#123;</span><br><span class="line">    private CommonImpl common;</span><br><span class="line">    </span><br><span class="line">    public DecorateCommon(CommonImpl common) &#123;</span><br><span class="line">        this.common = common;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void insert() &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        common.insert();</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        common.update();</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;delete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override </span><br><span class="line">    public void one() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">        common.one();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void two() &#123;</span><br><span class="line">        common.two();</span><br><span class="line">        System.out.println(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DecorateCommon decorateCommon = new DecorateCommon(new CommonImpl());</span><br><span class="line">        decorateCommon.insert();</span><br><span class="line">        decorateCommon.update();</span><br><span class="line">        decorateCommon.delete();</span><br><span class="line">        decorateCommon.one();</span><br><span class="line">        decorateCommon.two();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h5 id="1-使用JDK中的Proxy和InvocationHandler"><a href="#1-使用JDK中的Proxy和InvocationHandler" class="headerlink" title="1. 使用JDK中的Proxy和InvocationHandler"></a>1. 使用JDK中的Proxy和InvocationHandler</h5><p>CommonImpl的代理类，其中CommonImpl必须实现某些接口。<br>重点关注Proxy的方法<code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code><br>loader: 被代理类的类加载器<br>interfaces: 被代理类实现的接口<br>h: 被代理类关联的handler<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyCommon implements InvocationHandler &#123;</span><br><span class="line">    private Object obj;</span><br><span class="line">    </span><br><span class="line">    public ProxyCommon(Object obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throw Throwable &#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        </span><br><span class="line">        if (&quot;insert&quot;.equalsIgnoreCase(methodName) || &quot;update&quot;.equalsIgnoreCase(methodName)) &#123;</span><br><span class="line">            System.out.println(&quot;before&quot;);</span><br><span class="line">            Object result = method.invoke(obj, args);</span><br><span class="line">            System.out.println(&quot;after&quot;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (&quot;one&quot;.equalsIgnoreCase(methodName)) &#123;</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">            Object result = method.invoke(obj, args);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (&quot;two&quot;.equalsIgnoreCase(methodName)) &#123;</span><br><span class="line">            Object result = method.invoke(obj, args);</span><br><span class="line">            System.out.println(&quot;world&quot;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return method.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InvocationHandler handler = new ProxyCommon(new CommonImpl());</span><br><span class="line">        ClassLoader classLoader = CommonImpl.class.getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = new Class[] &#123;User.class, Client.class&#125;;</span><br><span class="line">        Object object = Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line">        </span><br><span class="line">        User user = (User)object;</span><br><span class="line">        user.insert();</span><br><span class="line">        user.update();</span><br><span class="line">        user.delete();</span><br><span class="line">        </span><br><span class="line">        Client client = (Client)client;</span><br><span class="line">        client.one();</span><br><span class="line">        client.two();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-使用cglib库"><a href="#2-使用cglib库" class="headerlink" title="2. 使用cglib库"></a>2. 使用cglib库</h5><p>CommonImpl的代理类，不论CommonImpl实现接口与否</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CglibCommon implements MethodInterceptor &#123;</span><br><span class="line">    private static CglibCommon cglibCommon = new CglibCommon();</span><br><span class="line">    private CglibCommon();</span><br><span class="line">    </span><br><span class="line">    public static CglibCommon getInstance() &#123;</span><br><span class="line">        return cglibCommon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">                </span><br><span class="line">        if (&quot;insert&quot;.equalsIgnoreCase(methodName) || &quot;update&quot;.equalsIgnoreCase(methodName)) &#123;</span><br><span class="line">            System.out.println(&quot;before&quot;);</span><br><span class="line">            Object result = methodProxy.invokeSuper(obj, args);</span><br><span class="line">            System.out.println(&quot;after&quot;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        if (&quot;one&quot;.equalsIgnoreCase(methodName)) &#123;</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">            Object result = methodProxy.invokeSuper(obj, args);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        if (&quot;two&quot;.equalsIgnoreCase(methodName)) &#123;</span><br><span class="line">            Object result = methodProxy.invokeSuper(obj, args);</span><br><span class="line">            System.out.println(&quot;world&quot;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        return methodProxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CommonImpl common = (CommonImpl)Enhancer.create(CommonImpl.class, CglibCommon.getInstance());</span><br><span class="line">        common.insert();</span><br><span class="line">        common.update();</span><br><span class="line">        common.delete();</span><br><span class="line">        common.one();</span><br><span class="line">        common.two();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Spring最重要的一个特点就是AOP，面向切面编程。它以织入的方式向系统中添加非业务功能的代码，例如参数检验，安全验证等。这个功能使得代码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度优先搜索与广度优先搜索</title>
    <link href="http://longman.kim/2018/06/18/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://longman.kim/2018/06/18/深度优先搜索与广度优先搜索/</id>
    <published>2018-06-17T17:01:04.000Z</published>
    <updated>2018-06-17T17:01:04.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://longman.kim/2018/06/18/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://longman.kim/2018/06/18/线段树/</id>
    <published>2018-06-17T17:00:23.000Z</published>
    <updated>2018-06-17T17:00:23.564Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://longman.kim/2018/06/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://longman.kim/2018/06/18/动态规划/</id>
    <published>2018-06-17T17:00:11.000Z</published>
    <updated>2018-06-17T17:00:11.430Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跳跃表</title>
    <link href="http://longman.kim/2018/06/18/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>http://longman.kim/2018/06/18/跳跃表/</id>
    <published>2018-06-17T16:59:55.000Z</published>
    <updated>2018-06-17T16:59:55.129Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://longman.kim/2018/06/18/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://longman.kim/2018/06/18/查找算法/</id>
    <published>2018-06-17T16:59:29.000Z</published>
    <updated>2018-06-17T16:59:29.487Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
