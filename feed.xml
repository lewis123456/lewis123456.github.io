<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longman</title>
  <icon>https://www.gravatar.com/avatar/b7e2ba3f68bd206134b3d41535be01b0</icon>
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://longman.kim/"/>
  <updated>2018-08-16T06:46:09.404Z</updated>
  <id>http://longman.kim/</id>
  
  <author>
    <name>lewis longman</name>
    <email>2328811532@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务的难点</title>
    <link href="http://longman.kim/2018/08/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9/"/>
    <id>http://longman.kim/2018/08/16/微服务的难点/</id>
    <published>2018-08-16T04:37:07.000Z</published>
    <updated>2018-08-16T06:46:09.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-如何拆分微服务"><a href="#1-如何拆分微服务" class="headerlink" title="1. 如何拆分微服务"></a>1. 如何拆分微服务</h3><p>拆分领域数据库  </p><p>领域模型的设计概念，聚合  </p><h3 id="2-微服务和数据库"><a href="#2-微服务和数据库" class="headerlink" title="2. 微服务和数据库"></a>2. 微服务和数据库</h3><p>不同服务间跨表查询困难  </p><p>CQRS解决分布式查询问题</p><p>分布式事务，NoSQL不支持ACID，2PC  </p><p>事件驱动架构的一种技术，事件源，解决分布式事务</p><h3 id="3-DDD聚合"><a href="#3-DDD聚合" class="headerlink" title="3. DDD聚合"></a>3. DDD聚合</h3><h3 id="4-事件源"><a href="#4-事件源" class="headerlink" title="4. 事件源"></a>4. 事件源</h3><h3 id="5-CQRS命令查询责任分离"><a href="#5-CQRS命令查询责任分离" class="headerlink" title="5. CQRS命令查询责任分离"></a>5. CQRS命令查询责任分离</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-如何拆分微服务&quot;&gt;&lt;a href=&quot;#1-如何拆分微服务&quot; class=&quot;headerlink&quot; title=&quot;1. 如何拆分微服务&quot;&gt;&lt;/a&gt;1. 如何拆分微服务&lt;/h3&gt;&lt;p&gt;拆分领域数据库  &lt;/p&gt;
&lt;p&gt;领域模型的设计概念，聚合  &lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQLite</title>
    <link href="http://longman.kim/2018/08/06/SQLite/"/>
    <id>http://longman.kim/2018/08/06/SQLite/</id>
    <published>2018-08-06T13:27:17.000Z</published>
    <updated>2018-08-07T02:46:40.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-优缺点"><a href="#1-优缺点" class="headerlink" title="1. 优缺点"></a>1. 优缺点</h3><ol><li>进程内的库</li><li>自给自足，不需要任何的外部依赖</li><li>无服务器，不需要单独的服务进程或操作系统</li><li>零配置，不需要安装或管理</li><li>事务性，完全兼容ACID，允许多个进程或线程安全访问</li><li>轻量级，完全配置时小于400k，省略配置时小于250k</li><li>不支持alter table中的修改删除列，只能通过重新建表的方式迂回进行</li><li>动态的，弱类型的SQL语法，不进行类型检查</li><li>SQLite不是传统C/S架构的数据库，而是嵌入式数据库</li><li>应用程序直接通过API调用来使用SQLite的功能，相比传统数据库的进程通信，单一进程中的函数调用效率更高</li><li>SQLite将整个数据库（定义、表、索引、数据）作为一个单独的、可跨平台使用的文件存储在主机中</li><li>写数据时，对数据库文件进行加锁。多个进程或线程可以同时访问一个数据库，平行读取同一个数据库。但同一时间只能有一个进程或线程进行数据写入。</li></ol><h3 id="2-Java示例"><a href="#2-Java示例" class="headerlink" title="2. Java示例"></a>2. Java示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.sql.*;</span><br><span class="line">import org.sqlite.JDBC</span><br><span class="line"></span><br><span class="line">public TestSQLite &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;org.sqlite.JDBC&quot;);</span><br><span class="line">            Connection conn = DriverManager.getConnection(&quot;jdbc:sqlite:test.db&quot;); //test.db是SQLite数据库的名称</span><br><span class="line">            Statement stat = conn.createStatement();</span><br><span class="line">            stat.executeUpdate(&quot;create table tb1(name varchar(20), salary int);&quot;);</span><br><span class="line">            stat.executeUpdate(&quot;insert into tb1 values(&apos;Zhangsan&apos;, 8000);&quot;);</span><br><span class="line">            stat.executeUpdate(&quot;insert into tb1 values(&apos;LiSi&apos;, 7800);&quot;);</span><br><span class="line">            ResultSet rs = stat.executeQuery(&quot;select * from tb1;&quot;);</span><br><span class="line">            while(rs.next) &#123;</span><br><span class="line">                System.out.println(&quot;name = &quot; + rs.getString(&quot;name&quot;));</span><br><span class="line">                System.out.println(&quot;salary = &quot; + rs.getString(&quot;salary&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-优缺点&quot;&gt;&lt;a href=&quot;#1-优缺点&quot; class=&quot;headerlink&quot; title=&quot;1. 优缺点&quot;&gt;&lt;/a&gt;1. 优缺点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;进程内的库&lt;/li&gt;
&lt;li&gt;自给自足，不需要任何的外部依赖&lt;/li&gt;
&lt;li&gt;无服务器，不需要单独
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>未来一年的规划（2018.8——2019.8）</title>
    <link href="http://longman.kim/2018/08/02/%E6%9C%AA%E6%9D%A5%E4%B8%80%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92%EF%BC%882018-8%E2%80%94%E2%80%942019-8%EF%BC%89/"/>
    <id>http://longman.kim/2018/08/02/未来一年的规划（2018-8——2019-8）/</id>
    <published>2018-08-02T12:32:43.000Z</published>
    <updated>2018-08-07T06:33:31.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-英语"><a href="#1-英语" class="headerlink" title="1. 英语"></a>1. 英语</h3><p>雅思8分  </p><ol><li>听<br>听新闻  </li><li>说<br>注册网站，与老外视频聊天  </li><li>读<br>读短篇、长篇文章  </li><li>写<br>议论文  </li><li>练<br>做题  </li></ol><h3 id="2-数据结构与算法"><a href="#2-数据结构与算法" class="headerlink" title="2. 数据结构与算法"></a>2. 数据结构与算法</h3><p>leetcode最少2遍（Java和C++各实现一遍）<br>poj最少500题</p><ol><li><p>排序<br>冒泡排序，选择排序，插入排序，堆排序，快速排序，基数排序，桶排序， 归并排序  </p></li><li><p>查找<br>二分查找</p></li><li><p>贪心</p></li><li><p>动态规划</p></li><li><p>KMP</p></li><li><p>A*</p></li><li><p>线段树  </p></li></ol><p>树状数组</p><ol start="8"><li><p>网络流</p></li><li><p>数论</p></li><li><p>最短路径</p></li><li><p>BFS, DFS</p></li><li><p>AVL树、红黑树</p></li><li><p>B, B-, B+树</p></li></ol><h3 id="3-Java-C-源码分析"><a href="#3-Java-C-源码分析" class="headerlink" title="3. Java/C++源码分析"></a>3. Java/C++源码分析</h3><p>分析笔记  </p><ol><li>精读JDK中的util, lang, io, nio</li><li>C++ STL</li></ol><h3 id="4-架构设计"><a href="#4-架构设计" class="headerlink" title="4. 架构设计"></a>4. 架构设计</h3><p>AWS、阿里的设计方案  </p><p>给出解决方案，指出架构的优缺点，结合业务逻辑</p><h3 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h3><p>带实验的知识点笔记  </p><ol><li>架构优化</li><li>JVM优化</li><li>线程池</li><li>数据库优化</li><li>C++程序的调试和性能优化</li></ol><h3 id="6-数据库"><a href="#6-数据库" class="headerlink" title="6. 数据库"></a>6. 数据库</h3><p>画图、带实验的个人总结<br>书籍、数据结构、算法、架构、原理、源码</p><ol><li>mysql</li><li>redis</li><li>hbase</li></ol><h3 id="7-业界方案"><a href="#7-业界方案" class="headerlink" title="7. 业界方案"></a>7. 业界方案</h3><p>腾讯、阿里、百度、美团、微博、豆瓣，它们的github</p><h3 id="8-大数据"><a href="#8-大数据" class="headerlink" title="8. 大数据"></a>8. 大数据</h3><p>画图、实验<br>Hadoop生态</p><h3 id="9-源码分析"><a href="#9-源码分析" class="headerlink" title="9. 源码分析"></a>9. 源码分析</h3><p>手写，带实验的笔记  </p><ol><li>redis</li><li>mongodb</li><li>zookeeper</li><li>spring</li><li>nginx</li><li>tomcat</li><li>netty</li><li>rocketmq</li><li>dubbo</li></ol><h3 id="10-个人品牌输出"><a href="#10-个人品牌输出" class="headerlink" title="10. 个人品牌输出"></a>10. 个人品牌输出</h3><p>完整的后台服务框架需要做哪些东西-业务逻辑和服务治理（服务发现、发布、容灾、容错、扩展、链路分析、服务可降级、白名单、安全）</p><ol><li>登录注册</li><li>负载均衡</li><li>cdn加速</li><li>接入层</li><li>逻辑层</li><li>中间层</li><li>存储层</li><li>业务运营管理平台、配置管理、发布管理、监控告警上报、统计上报</li><li>项目管理、需求管理</li></ol><h3 id="11-Github"><a href="#11-Github" class="headerlink" title="11. Github"></a>11. Github</h3><p>工程实战<br>让github成为自己的名片，以项目推动自己的进步，输出代码和文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-英语&quot;&gt;&lt;a href=&quot;#1-英语&quot; class=&quot;headerlink&quot; title=&quot;1. 英语&quot;&gt;&lt;/a&gt;1. 英语&lt;/h3&gt;&lt;p&gt;雅思8分  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;听&lt;br&gt;听新闻  &lt;/li&gt;
&lt;li&gt;说&lt;br&gt;注册网站，与老外视频聊天  &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例的写法</title>
    <link href="http://longman.kim/2018/08/02/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%86%99%E6%B3%95/"/>
    <id>http://longman.kim/2018/08/02/单例的写法/</id>
    <published>2018-08-02T06:51:25.000Z</published>
    <updated>2018-08-02T08:03:28.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-懒汉"><a href="#1-懒汉" class="headerlink" title="1. 懒汉"></a>1. 懒汉</h3><p>缺点是每次都要加锁。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (null == instance) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-饿汉"><a href="#2-饿汉" class="headerlink" title="2. 饿汉"></a>2. 饿汉</h3><p>缺点是类加载的时候就创建了实例。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-双重校验锁"><a href="#3-双重校验锁" class="headerlink" title="3. 双重校验锁"></a>3. 双重校验锁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (null == instance) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (null == instance) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h3><p>优点是可以防止反序列化创建对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnumSingleton &#123;</span><br><span class="line">    private EnumSingleton()&#123;&#125;</span><br><span class="line">    public static EnumSingleton getInstance() &#123;</span><br><span class="line">        return Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    private static Enum Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        private EnumSingleton singleton;</span><br><span class="line">        private Singleton() &#123;</span><br><span class="line">            singleton = new EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        public EnumSingleton getInstance() &#123;</span><br><span class="line">            return singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>优点是可以延迟加载。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static class SingleHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static final Singleton getInstance() &#123;</span><br><span class="line">        return SingleHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-懒汉&quot;&gt;&lt;a href=&quot;#1-懒汉&quot; class=&quot;headerlink&quot; title=&quot;1. 懒汉&quot;&gt;&lt;/a&gt;1. 懒汉&lt;/h3&gt;&lt;p&gt;缺点是每次都要加锁。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Java虚拟机规范》</title>
    <link href="http://longman.kim/2018/08/01/%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B/"/>
    <id>http://longman.kim/2018/08/01/《Java虚拟机规范》/</id>
    <published>2018-08-01T12:10:25.000Z</published>
    <updated>2018-08-01T13:14:14.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><h5 id="1-1-历史简介"><a href="#1-1-历史简介" class="headerlink" title="1.1 历史简介"></a>1.1 历史简介</h5><h5 id="1-2-Java虚拟机"><a href="#1-2-Java虚拟机" class="headerlink" title="1.2 Java虚拟机"></a>1.2 Java虚拟机</h5><h5 id="1-3-规范制定的组织"><a href="#1-3-规范制定的组织" class="headerlink" title="1.3 规范制定的组织"></a>1.3 规范制定的组织</h5><h5 id="1-4-标记"><a href="#1-4-标记" class="headerlink" title="1.4 标记"></a>1.4 标记</h5><h5 id="1-5-反馈"><a href="#1-5-反馈" class="headerlink" title="1.5 反馈"></a>1.5 反馈</h5><h3 id="2-Java虚拟机的结构"><a href="#2-Java虚拟机的结构" class="headerlink" title="2. Java虚拟机的结构"></a>2. Java虚拟机的结构</h3><h5 id="2-1-class文件的格式"><a href="#2-1-class文件的格式" class="headerlink" title="2.1 class文件的格式"></a>2.1 class文件的格式</h5><h5 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h5><h5 id="2-3-基本类型和值"><a href="#2-3-基本类型和值" class="headerlink" title="2.3 基本类型和值"></a>2.3 基本类型和值</h5><h5 id="2-4-引用类型和值"><a href="#2-4-引用类型和值" class="headerlink" title="2.4 引用类型和值"></a>2.4 引用类型和值</h5><h5 id="2-5-运行时数据区域"><a href="#2-5-运行时数据区域" class="headerlink" title="2.5 运行时数据区域"></a>2.5 运行时数据区域</h5><h5 id="2-6-帧"><a href="#2-6-帧" class="headerlink" title="2.6 帧"></a>2.6 帧</h5><h5 id="2-7-对象的表示"><a href="#2-7-对象的表示" class="headerlink" title="2.7 对象的表示"></a>2.7 对象的表示</h5><h5 id="2-8-浮点类型的计算"><a href="#2-8-浮点类型的计算" class="headerlink" title="2.8 浮点类型的计算"></a>2.8 浮点类型的计算</h5><h5 id="2-9-特别的方法"><a href="#2-9-特别的方法" class="headerlink" title="2.9 特别的方法"></a>2.9 特别的方法</h5><h5 id="2-10-异常"><a href="#2-10-异常" class="headerlink" title="2.10 异常"></a>2.10 异常</h5><h5 id="2-11-命令集总结"><a href="#2-11-命令集总结" class="headerlink" title="2.11 命令集总结"></a>2.11 命令集总结</h5><h5 id="2-12-类库"><a href="#2-12-类库" class="headerlink" title="2.12 类库"></a>2.12 类库</h5><h5 id="2-13-公共、私有的实现"><a href="#2-13-公共、私有的实现" class="headerlink" title="2.13 公共、私有的实现"></a>2.13 公共、私有的实现</h5><h3 id="3-编译Java虚拟机"><a href="#3-编译Java虚拟机" class="headerlink" title="3. 编译Java虚拟机"></a>3. 编译Java虚拟机</h3><h5 id="3-1-例子的格式"><a href="#3-1-例子的格式" class="headerlink" title="3.1 例子的格式"></a>3.1 例子的格式</h5><h5 id="3-2-常量，局部变量，构造函数的使用"><a href="#3-2-常量，局部变量，构造函数的使用" class="headerlink" title="3.2 常量，局部变量，构造函数的使用"></a>3.2 常量，局部变量，构造函数的使用</h5><h5 id="3-3-算术运算"><a href="#3-3-算术运算" class="headerlink" title="3.3 算术运算"></a>3.3 算术运算</h5><h5 id="3-4-访问运行时的常量池"><a href="#3-4-访问运行时的常量池" class="headerlink" title="3.4 访问运行时的常量池"></a>3.4 访问运行时的常量池</h5><h5 id="3-5-更多控制的例子"><a href="#3-5-更多控制的例子" class="headerlink" title="3.5 更多控制的例子"></a>3.5 更多控制的例子</h5><h5 id="3-6-接收参数"><a href="#3-6-接收参数" class="headerlink" title="3.6 接收参数"></a>3.6 接收参数</h5><h5 id="3-7-调用方法"><a href="#3-7-调用方法" class="headerlink" title="3.7 调用方法"></a>3.7 调用方法</h5><h5 id="3-8-类实例的使用"><a href="#3-8-类实例的使用" class="headerlink" title="3.8 类实例的使用"></a>3.8 类实例的使用</h5><h5 id="3-9-数组"><a href="#3-9-数组" class="headerlink" title="3.9 数组"></a>3.9 数组</h5><h5 id="3-10-编译切换"><a href="#3-10-编译切换" class="headerlink" title="3.10 编译切换"></a>3.10 编译切换</h5><h5 id="3-11-栈操作符"><a href="#3-11-栈操作符" class="headerlink" title="3.11 栈操作符"></a>3.11 栈操作符</h5><h5 id="3-12-异常的抛出与处理"><a href="#3-12-异常的抛出与处理" class="headerlink" title="3.12 异常的抛出与处理"></a>3.12 异常的抛出与处理</h5><h5 id="3-13-finally的编译"><a href="#3-13-finally的编译" class="headerlink" title="3.13 finally的编译"></a>3.13 finally的编译</h5><h5 id="3-14-同步Synchronization"><a href="#3-14-同步Synchronization" class="headerlink" title="3.14 同步Synchronization"></a>3.14 同步Synchronization</h5><h5 id="3-15-注解"><a href="#3-15-注解" class="headerlink" title="3.15 注解"></a>3.15 注解</h5><h3 id="4-类class文件的格式"><a href="#4-类class文件的格式" class="headerlink" title="4. 类class文件的格式"></a>4. 类class文件的格式</h3><h5 id="4-1-类文件的结构"><a href="#4-1-类文件的结构" class="headerlink" title="4.1 类文件的结构"></a>4.1 类文件的结构</h5><h5 id="4-2-名字的内部格式"><a href="#4-2-名字的内部格式" class="headerlink" title="4.2 名字的内部格式"></a>4.2 名字的内部格式</h5><h5 id="4-3-描述符"><a href="#4-3-描述符" class="headerlink" title="4.3 描述符"></a>4.3 描述符</h5><h5 id="4-4-常量池"><a href="#4-4-常量池" class="headerlink" title="4.4 常量池"></a>4.4 常量池</h5><h5 id="4-5-域"><a href="#4-5-域" class="headerlink" title="4.5 域"></a>4.5 域</h5><h5 id="4-6-方法"><a href="#4-6-方法" class="headerlink" title="4.6 方法"></a>4.6 方法</h5><h5 id="4-7-属性"><a href="#4-7-属性" class="headerlink" title="4.7 属性"></a>4.7 属性</h5><h5 id="4-8-格式检查"><a href="#4-8-格式检查" class="headerlink" title="4.8 格式检查"></a>4.8 格式检查</h5><h5 id="4-9-Java虚拟机代码的限制"><a href="#4-9-Java虚拟机代码的限制" class="headerlink" title="4.9 Java虚拟机代码的限制"></a>4.9 Java虚拟机代码的限制</h5><h5 id="4-10-类文件的验证"><a href="#4-10-类文件的验证" class="headerlink" title="4.10 类文件的验证"></a>4.10 类文件的验证</h5><h5 id="4-11-Java虚拟机的限制"><a href="#4-11-Java虚拟机的限制" class="headerlink" title="4.11 Java虚拟机的限制"></a>4.11 Java虚拟机的限制</h5><h3 id="5-加载、链接、初始化"><a href="#5-加载、链接、初始化" class="headerlink" title="5 加载、链接、初始化"></a>5 加载、链接、初始化</h3><h5 id="5-1-运行时常量池"><a href="#5-1-运行时常量池" class="headerlink" title="5.1 运行时常量池"></a>5.1 运行时常量池</h5><h5 id="5-2-Java虚拟机的启动"><a href="#5-2-Java虚拟机的启动" class="headerlink" title="5.2 Java虚拟机的启动"></a>5.2 Java虚拟机的启动</h5><h5 id="5-3-创建和加载"><a href="#5-3-创建和加载" class="headerlink" title="5.3 创建和加载"></a>5.3 创建和加载</h5><h5 id="5-4-链接"><a href="#5-4-链接" class="headerlink" title="5.4 链接"></a>5.4 链接</h5><h5 id="5-5-初始化"><a href="#5-5-初始化" class="headerlink" title="5.5 初始化"></a>5.5 初始化</h5><h5 id="5-6-绑定本地方法的实现"><a href="#5-6-绑定本地方法的实现" class="headerlink" title="5.6 绑定本地方法的实现"></a>5.6 绑定本地方法的实现</h5><h5 id="5-7-Java虚拟机的退出"><a href="#5-7-Java虚拟机的退出" class="headerlink" title="5.7 Java虚拟机的退出"></a>5.7 Java虚拟机的退出</h5><h3 id="6-Java虚拟机指令集"><a href="#6-Java虚拟机指令集" class="headerlink" title="6. Java虚拟机指令集"></a>6. Java虚拟机指令集</h3><h5 id="6-1-假设：“必须”的意义"><a href="#6-1-假设：“必须”的意义" class="headerlink" title="6.1 假设：“必须”的意义"></a>6.1 假设：“必须”的意义</h5><h5 id="6-2-保留的Opcodes"><a href="#6-2-保留的Opcodes" class="headerlink" title="6.2 保留的Opcodes"></a>6.2 保留的Opcodes</h5><h5 id="6-3-虚拟机错误"><a href="#6-3-虚拟机错误" class="headerlink" title="6.3 虚拟机错误"></a>6.3 虚拟机错误</h5><h5 id="6-4-指令描述的格式"><a href="#6-4-指令描述的格式" class="headerlink" title="6.4 指令描述的格式"></a>6.4 指令描述的格式</h5><h5 id="6-5-指令集"><a href="#6-5-指令集" class="headerlink" title="6.5 指令集"></a>6.5 指令集</h5><h3 id="7-Opcode"><a href="#7-Opcode" class="headerlink" title="7. Opcode"></a>7. Opcode</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;h5 id=&quot;1-1-历史简介&quot;&gt;&lt;a href=&quot;#1-1-历史简介&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>openjdk-8浏览总结</title>
    <link href="http://longman.kim/2018/08/01/openjdk-8%E6%B5%8F%E8%A7%88%E6%80%BB%E7%BB%93/"/>
    <id>http://longman.kim/2018/08/01/openjdk-8浏览总结/</id>
    <published>2018-08-01T08:22:22.000Z</published>
    <updated>2018-08-09T12:29:54.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块介绍"><a href="#1-模块介绍" class="headerlink" title="1. 模块介绍"></a>1. 模块介绍</h3><ul><li><p>common  </p></li><li><p>corba<br>Common Object Request Broker Architecture(通用对象请求代理架构), 基于对象-服务机制设计，类似于JavaBean和微软的COM技术。  </p><blockquote><ol><li>RPC<br>支持xml和json两种格式的消息，使用http作为其传输协议。  </li><li>CORBA<br>使用IDL作为消息，使用tcp作为传输协议，使用JNDI查找服务。CORBA是OMG(Object Management Group)对象管理组织提出的方案，解决分布式环境中软硬件系统的互联。现在已经用的比较少了，基本被Web Service替代，只有一些大型的电信项目还在用CORBA。</li><li>Web Service<br>包含AXIS, XFire, CFX   </li><li>SOAP<br>使用xml作为消息，使用http作为传输协议。  </li><li>RMI<br>使用JRMP作为消息，可以使用http, tcp等作为传输协议，使用JNDI查找服务。</li></ol></blockquote></li><li><p>hotspot<br>JVM的实现之一</p><blockquote><ol><li>cms</li><li>g1</li><li>parallel scavenge</li></ol></blockquote></li><li><p>jaxp<br>Java API for XML Processing, 解析与校验xml文件，提供了3种接口来处理XML文档。</p><blockquote><p>DOM接口(文档对象模型解析)<br>SAX接口(XML简单API解析)<br>StAX接口(XML流API)</p></blockquote></li><li><p>jaxws<br>XML Web Services的Java API, 全称Java API for Web Services，允许开发者选择面向RPC(RPC-oriented)或是面向消息(Message-oriented)的方式来实现自己的Web Services。</p></li><li><p>jdk<br>JDK的实现  </p><blockquote><ol><li>ThreadLocal</li><li>BlockingQueue</li><li>EnumMap</li><li>EnumSet</li><li>HashMap</li><li>CurrentHashMap</li><li>ArraryList</li><li>HashSet</li><li>TreeSet</li><li>LinkedHashMap</li><li>TreeMap</li><li>LinkedList</li><li>HashTable</li><li>Vector</li></ol></blockquote></li><li><p>langtools<br>Java语言工具，包含javac, javap等实用程序的源码。</p></li><li><p>make</p></li><li><p>nashorn<br>JVM上的JavaScript运行时</p></li><li><p>test</p></li></ul><h3 id="2-辅助书籍"><a href="#2-辅助书籍" class="headerlink" title="2. 辅助书籍"></a>2. 辅助书籍</h3><ol><li>《Java虚拟机规范》</li><li>《深入理解Java虚拟机》</li><li>《Hotspot实战》</li></ol><h3 id="3-其他建议"><a href="#3-其他建议" class="headerlink" title="3. 其他建议"></a>3. 其他建议</h3><ol><li><p>精读源码<br>java.util<br>java.lang<br>java.io  </p></li><li><p>深刻理解<br>java.lang.reflect<br>java.net<br>java.net.<em><br>java.nio<br>java.util.concurrent.</em></p></li><li><p>会用即可<br>java.lang.annotation<br>javax.annotation.<em><br>java.lang.ref<br>java.math<br>java.rmi.</em><br>javax.rmi.<em><br>java.security.</em><br>javax.security.<em><br>java.sql<br>javax.sql.</em><br>javax.transaction.<em><br>java.text<br>javax.xml.</em><br>org.w3c.dom.<em><br>org.xml.sax.</em><br>javax.crypto.<em><br>javax.imageio.</em><br>javax.jws.*<br>java.util.jar<br>java.util.logging<br>java.util.prefs<br>java.util.regex<br>java.util.zip  </p></li></ol><h3 id="4-java-util"><a href="#4-java-util" class="headerlink" title="4. java.util"></a>4. java.util</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-模块介绍&quot;&gt;&lt;a href=&quot;#1-模块介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 模块介绍&quot;&gt;&lt;/a&gt;1. 模块介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;common  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;corba&lt;br&gt;Common O
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>临时</title>
    <link href="http://longman.kim/2018/08/01/%E4%B8%B4%E6%97%B6/"/>
    <id>http://longman.kim/2018/08/01/临时/</id>
    <published>2018-08-01T01:37:48.000Z</published>
    <updated>2018-08-01T01:45:30.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-零拷贝"><a href="#1-零拷贝" class="headerlink" title="1. 零拷贝"></a>1. 零拷贝</h3><h3 id="2-Netty的ChannelPipeline"><a href="#2-Netty的ChannelPipeline" class="headerlink" title="2. Netty的ChannelPipeline"></a>2. Netty的ChannelPipeline</h3><h3 id="3-2PC，3PC"><a href="#3-2PC，3PC" class="headerlink" title="3. 2PC，3PC"></a>3. 2PC，3PC</h3><h3 id="4-redis选举"><a href="#4-redis选举" class="headerlink" title="4. redis选举"></a>4. redis选举</h3><h3 id="5-CAP中的P"><a href="#5-CAP中的P" class="headerlink" title="5. CAP中的P"></a>5. CAP中的P</h3><h3 id="6-HBase与MySQL的对比"><a href="#6-HBase与MySQL的对比" class="headerlink" title="6. HBase与MySQL的对比"></a>6. HBase与MySQL的对比</h3><h3 id="7-POW挖矿，POF-DPOF-RAFT"><a href="#7-POW挖矿，POF-DPOF-RAFT" class="headerlink" title="7. POW挖矿，POF, DPOF, RAFT"></a>7. POW挖矿，POF, DPOF, RAFT</h3><h3 id="8-行内的架构"><a href="#8-行内的架构" class="headerlink" title="8. 行内的架构"></a>8. 行内的架构</h3><h3 id="9-消息中间件需要解决的问题"><a href="#9-消息中间件需要解决的问题" class="headerlink" title="9. 消息中间件需要解决的问题"></a>9. 消息中间件需要解决的问题</h3><h3 id="10-BloomFilter-布隆过滤器"><a href="#10-BloomFilter-布隆过滤器" class="headerlink" title="10. BloomFilter 布隆过滤器"></a>10. BloomFilter 布隆过滤器</h3><h3 id="11-MySQL-流式查询"><a href="#11-MySQL-流式查询" class="headerlink" title="11. MySQL 流式查询"></a>11. MySQL 流式查询</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-零拷贝&quot;&gt;&lt;a href=&quot;#1-零拷贝&quot; class=&quot;headerlink&quot; title=&quot;1. 零拷贝&quot;&gt;&lt;/a&gt;1. 零拷贝&lt;/h3&gt;&lt;h3 id=&quot;2-Netty的ChannelPipeline&quot;&gt;&lt;a href=&quot;#2-Netty的ChannelP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一致性算法</title>
    <link href="http://longman.kim/2018/07/26/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    <id>http://longman.kim/2018/07/26/一致性算法/</id>
    <published>2018-07-26T14:09:06.000Z</published>
    <updated>2018-07-31T04:52:15.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-2PC"><a href="#1-2PC" class="headerlink" title="1. 2PC"></a>1. 2PC</h3><ol><li>投票阶段<blockquote><p>协调者向所有参与者发送事务内容，等待参与者的响应；<br>参与者执行事务，并将undo和redo信息记入事务日志；<br>参与者向协调者反馈事务的响应YES或者NO；  </p></blockquote></li></ol><ol start="2"><li><p>提交阶段</p><blockquote><p>如果所有参与者都反馈YES，则协调者向所有参与者发出提交请求，参与者完成事务提交后，向协调者发送ACK信息，协调者收到所有参与者的ACK信息后，完成事务。<br>任何一个参与者反馈NO，或者等待超时后，协调者会中断事务。协调者向所有参与者发送回滚请求，参与者收到回滚请求后，会利用undo信息进行事务回滚，并在完成回滚之后释放整个事务执行期间所占用的资源。参与者完成事务回滚之后，答复ACK信息。协调者收到所有的ACK信息后，完成事务中断。</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：原理简单、实现方便<br>确定：同步阻塞（执行2PC过程中所有参与该事务操作的逻辑都是阻塞状态）、单点问题（如果协调者挂了，2PC将无法运转，如果在提交阶段挂了，参与者将一直处于锁定事务资源的状态）、数据不一致（在提交阶段如果由于网络等问题导致commit请求没有到达部分参与者，则会出现数据不一致）、太过保守（如果参与者出现故障，协调者只能通过超时来判断是否需要中断事务）。</p></blockquote></li></ol><h3 id="2-3PC（解决2PC的阻塞，但数据还可能不一致）"><a href="#2-3PC（解决2PC的阻塞，但数据还可能不一致）" class="headerlink" title="2. 3PC（解决2PC的阻塞，但数据还可能不一致）"></a>2. 3PC（解决2PC的阻塞，但数据还可能不一致）</h3><ol><li><p>询问阶段</p><blockquote><p>协调者向参与者发送询问是否能执行该事务的请求，并等待。<br>参与者收到询问后，正常情况下，反馈YES，否则反馈NO。  </p></blockquote></li><li><p>预提交阶段</p><blockquote><p>如果询问阶段协调者收到的响应都是YES，那么事务进入预提交。<br>协调者向所有参与者发送预提交请求。<br>参与者收到预提交请求后，执行该事务，并记录undo和redo到事务日记中。<br>参与者向协调者反馈预提交的结果，并等待最终指令，提交commit或者终止abort。<br>如果询问阶段任何一个参与者反馈了No，或者协调者等待超时，那么就会执行中断事务。<br>协调者向所有参与者发送中断请求。<br>无论是收到协调者的中断请求还是等待超时，参与者都执行中断事务。  </p></blockquote></li><li><p>提交阶段</p><blockquote><p>假设协调者正常工作，接收到了所有参与者的ACK响应，它将从预提交阶段进入提交状态，并向所有参与者发送提交请求。<br>参与者收到提交请求后，正式提交事务，在事务完成后释放资源<br>参与者完成事务提交后，向协调者发送ACK<br>协调者收到所有ACK信息，完成事务<br>假设协调者正常工作，任一参与者反馈No，或者等待超时后，协调者都会中断事务。<br>协调者向所有参与者发送中断请求<br>参与者接收到中断请求后，利用undo日志执行事务回滚，并在完成事务回滚后释放资源。<br>参与者在完成事务回滚后，向协调者发送ACK信息。<br>协调者收到所有参与者的ACK信息后，中断事务。  </p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：降低参与者阻塞范围，能够在出现单点故障后继续达成一致。解决了2PC的阻塞问题，引入了预提交阶段，当所有参与者收到预提交请求后，不执行动作，直到收到提交请求或者超时。<br>缺点：引入预提交阶段，在这个阶段如果出现网络分区，协调者无法与参与者正常通信，参与者依然会进行事务提交，造成数据不一致。  </p></blockquote></li></ol><h3 id="3-拜占庭问题"><a href="#3-拜占庭问题" class="headerlink" title="3. 拜占庭问题"></a>3. 拜占庭问题</h3><p>消息不完整或者被篡改。  </p><h3 id="4-PAXOS（解决单点问题）"><a href="#4-PAXOS（解决单点问题）" class="headerlink" title="4. PAXOS（解决单点问题）"></a>4. PAXOS（解决单点问题）</h3><ol><li>Prepare阶段<blockquote><p>提案号，任何结点在Prepare阶段时都会拒绝其值小于当前提案号的请求。如果接收结点收到的提案号n大于其他结点发过来的提案号，这个结点会回应YES（本结点上最新的被批准提案号），并保证不接收其他&lt;n的提案号。</p></blockquote></li></ol><ol start="2"><li>Accept阶段<blockquote><p>如果提案者收到了超过半数的结点返回YES，它就会向所有的结点发布Accept Request，如果没有半数的话，那就返回失败。<br>当结点收到的Accept Request后，如果对于该结点来说n是最大的，它就通过request。如果发现自己有一个更大的提案号，结点就会拒绝request。</p></blockquote></li></ol><h3 id="5-RAFT"><a href="#5-RAFT" class="headerlink" title="5. RAFT"></a>5. RAFT</h3><p>follower、candidate、leader三个角色。<br>最开始大家都是follower，当follower监听不到leader时，自己成为candidate，并发起投票。</p><ol><li><p>leader的选举</p><blockquote><p>选举的timeout。follower随机等待一定时间成为candidate，看谁先成为candidate，它会先投自己一票，然后向其他结点发起投票邀请。如果得到大多数的投票就成为leader，之后定期向follower发送心跳。如果两个follower同时成为candidate，并且最后的投票相同，则等待其他的follower的选择超时后，开始新一轮的选举。</p></blockquote></li><li><p>log复制</p><blockquote><p>leader把变动的log借助心跳同步给follower，过半回复之后才成功提交，之后再下一次心跳之后，follower也commit变动，在自己的node上生效。  </p></blockquote></li></ol><h3 id="6-ZAB"><a href="#6-ZAB" class="headerlink" title="6. ZAB"></a>6. ZAB</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-2PC&quot;&gt;&lt;a href=&quot;#1-2PC&quot; class=&quot;headerlink&quot; title=&quot;1. 2PC&quot;&gt;&lt;/a&gt;1. 2PC&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;投票阶段&lt;blockquote&gt;
&lt;p&gt;协调者向所有参与者发送事务内容，等待参与者的响应；&lt;br&gt;参
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《代码的未来》</title>
    <link href="http://longman.kim/2018/07/26/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%AA%E6%9D%A5%E3%80%8B/"/>
    <id>http://longman.kim/2018/07/26/《代码的未来》/</id>
    <published>2018-07-26T12:22:43.000Z</published>
    <updated>2018-07-26T14:02:26.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-编程的时间和空间"><a href="#1-编程的时间和空间" class="headerlink" title="1. 编程的时间和空间"></a>1. 编程的时间和空间</h3><h3 id="2-编程语言的过去、现在和未来"><a href="#2-编程语言的过去、现在和未来" class="headerlink" title="2. 编程语言的过去、现在和未来"></a>2. 编程语言的过去、现在和未来</h3><h3 id="3-编程语言的新潮流"><a href="#3-编程语言的新潮流" class="headerlink" title="3. 编程语言的新潮流"></a>3. 编程语言的新潮流</h3><h3 id="4-云计算时代的编程"><a href="#4-云计算时代的编程" class="headerlink" title="4. 云计算时代的编程"></a>4. 云计算时代的编程</h3><h3 id="5-支撑大数据的数据存储技术"><a href="#5-支撑大数据的数据存储技术" class="headerlink" title="5. 支撑大数据的数据存储技术"></a>5. 支撑大数据的数据存储技术</h3><h3 id="6-多核时代的编程"><a href="#6-多核时代的编程" class="headerlink" title="6. 多核时代的编程"></a>6. 多核时代的编程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-编程的时间和空间&quot;&gt;&lt;a href=&quot;#1-编程的时间和空间&quot; class=&quot;headerlink&quot; title=&quot;1. 编程的时间和空间&quot;&gt;&lt;/a&gt;1. 编程的时间和空间&lt;/h3&gt;&lt;h3 id=&quot;2-编程语言的过去、现在和未来&quot;&gt;&lt;a href=&quot;#2-编程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring中的事务（传播机制、隔离级别、回滚、超时）</title>
    <link href="http://longman.kim/2018/07/24/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E5%9B%9E%E6%BB%9A%E3%80%81%E8%B6%85%E6%97%B6%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/24/Spring中的事务（传播机制、隔离级别、回滚、超时）/</id>
    <published>2018-07-24T03:21:55.000Z</published>
    <updated>2018-07-24T03:30:15.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-传播机制"><a href="#1-传播机制" class="headerlink" title="1. 传播机制"></a>1. 传播机制</h3><h3 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2. 隔离级别"></a>2. 隔离级别</h3><h3 id="3-回滚"><a href="#3-回滚" class="headerlink" title="3. 回滚"></a>3. 回滚</h3><h3 id="4-超时"><a href="#4-超时" class="headerlink" title="4. 超时"></a>4. 超时</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-传播机制&quot;&gt;&lt;a href=&quot;#1-传播机制&quot; class=&quot;headerlink&quot; title=&quot;1. 传播机制&quot;&gt;&lt;/a&gt;1. 传播机制&lt;/h3&gt;&lt;h3 id=&quot;2-隔离级别&quot;&gt;&lt;a href=&quot;#2-隔离级别&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ELK搭建网站监控系统</title>
    <link href="http://longman.kim/2018/07/23/ELK%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>http://longman.kim/2018/07/23/ELK搭建网站监控系统/</id>
    <published>2018-07-23T12:36:53.000Z</published>
    <updated>2018-08-01T12:53:46.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网站流量监控系统"><a href="#网站流量监控系统" class="headerlink" title=". 网站流量监控系统"></a>. 网站流量监控系统</h3><h3 id="1-Logstash-JRuby编写"><a href="#1-Logstash-JRuby编写" class="headerlink" title="1. Logstash(JRuby编写)"></a>1. Logstash(JRuby编写)</h3><p>矿工，日志收集，日志来自于业务系统，业务系统由不同的语言编写，过滤日志格式。Logstash采用Ruby语法，自定义日志格式过滤器，将格式化后的数据输出到ElasticSearch。它的可靠性低，占用CPU和内存的比率很高。</p><h3 id="2-ElasticSearch-Java编写"><a href="#2-ElasticSearch-Java编写" class="headerlink" title="2. ElasticSearch(Java编写)"></a>2. ElasticSearch(Java编写)</h3><p>日志仓库，提供全文检索，快速检索，分布式存储。ElasticSearch采用主备部署。<br>插件elasticsearch-head。</p><h3 id="3-Kibana-javascript编写"><a href="#3-Kibana-javascript编写" class="headerlink" title="3. Kibana(javascript编写)"></a>3. Kibana(javascript编写)</h3><p>可视化，数据来源于ES，实时读取数据变化。</p><h3 id="4-Filebeat"><a href="#4-Filebeat" class="headerlink" title="4. Filebeat"></a>4. Filebeat</h3><p>承担数据采集的角色</p><h3 id="6-ELK海量日志监控的部署"><a href="#6-ELK海量日志监控的部署" class="headerlink" title="6. ELK海量日志监控的部署"></a>6. ELK海量日志监控的部署</h3><p>利用Kafka将同步改成异步</p><h3 id="7-场景"><a href="#7-场景" class="headerlink" title="7. 场景"></a>7. 场景</h3><p>监控、统计、分析、检索</p><hr><h3 id="8-咕泡学院"><a href="#8-咕泡学院" class="headerlink" title="8. 咕泡学院"></a>8. 咕泡学院</h3><h5 id="8-1-日志的级别"><a href="#8-1-日志的级别" class="headerlink" title="8.1 日志的级别"></a>8.1 日志的级别</h5><p>DEBUG, INFO, WARN, ERROR</p><h5 id="8-2-系统监控"><a href="#8-2-系统监控" class="headerlink" title="8.2 系统监控"></a>8.2 系统监控</h5><p>日志、APO、心跳监控、数据库监控、Filter、Trace</p><h5 id="8-3-集中式监控"><a href="#8-3-集中式监控" class="headerlink" title="8.3 集中式监控"></a>8.3 集中式监控</h5><h5 id="8-4-ELK"><a href="#8-4-ELK" class="headerlink" title="8.4 ELK"></a>8.4 ELK</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网站流量监控系统&quot;&gt;&lt;a href=&quot;#网站流量监控系统&quot; class=&quot;headerlink&quot; title=&quot;. 网站流量监控系统&quot;&gt;&lt;/a&gt;. 网站流量监控系统&lt;/h3&gt;&lt;h3 id=&quot;1-Logstash-JRuby编写&quot;&gt;&lt;a href=&quot;#1-Logst
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://longman.kim/2018/07/23/MongoDB/"/>
    <id>http://longman.kim/2018/07/23/MongoDB/</id>
    <published>2018-07-23T12:10:52.000Z</published>
    <updated>2018-07-23T12:10:52.249Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Netty实战</title>
    <link href="http://longman.kim/2018/07/20/Netty%E5%AE%9E%E6%88%98/"/>
    <id>http://longman.kim/2018/07/20/Netty实战/</id>
    <published>2018-07-20T08:08:46.000Z</published>
    <updated>2018-07-23T14:12:39.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Netty——异步和事件驱动"><a href="#1-Netty——异步和事件驱动" class="headerlink" title="1. Netty——异步和事件驱动"></a>1. Netty——异步和事件驱动</h3><ol><li>Java网络编程</li></ol><blockquote><ol><li>阻塞I/O<br>例如accept会一直阻塞到一个连接的建立，readLine会一直阻塞到换行符或者回车结尾的字符被读取。进一步，可以采用线程池处理多个请求，但存在大量的线程因为等待I/O数据就绪而处于休眠状态，并且需要为每个线程分配调用栈并切换上下文，同时虚拟机支持的线程数量有限。    </li><li>Java NIO, 非阻塞I/O<br>用setsocketopt()配置套接字，在读写调用没有数据时立即返回，当有任何套接字已经有数据可供读写时，使用操作系统的事件通知主线程。主线程中有一个selector，它可以监控多个Buffer相连，每个Buffer和一个Socket相连，当任何Buffer中有数据可读写时，selector就会选择该Buffer进行读写，即和该Buffer对应的Socket通信。  </li></ol></blockquote><ol start="2"><li>Netty简介<blockquote><p>Netty的特点  </p><ol><li>设计<br>统一的API，支持多种传输类型，阻塞和非阻塞，简单而强大的线程模型，真正的无连接数据报套接字支持，链接逻辑组件以支持复用  </li><li>易于使用  </li><li>性能<br>比Java核心API更高的吞吐量以及更低的延迟，得益于池化和复用，拥有更低的资源消耗，最少的内存复制  </li><li>健壮性<br>不会因为慢速、快速或者超载的连接而导致OutOfMemoryError，消除在高速网络中NIO应用程序常见的不公平读/写比率  </li><li>安全性<br>完整的SSL/TLS以及StartTLS支持，可用于受限环境下  </li><li>社区驱动<br>发布快速而且频繁  </li></ol><p>Netty常用来做HTTP长连接，或者各种推送通知  </p><p>异步和事件驱动  </p></blockquote></li></ol><ol start="3"><li>Netty的核心组件</li></ol><blockquote><ol><li>Channel<br>Channel是Java NIO的一个基本构造，代表一个到实体的开放连接，如读写操作。可以把Channel看作是传入（入站）和传出（出站）数据的载体，它可以被打开，被关闭，连接或者断开连接。  </li><li>回调<br>回调是一个方法，其他系统在某个操作完成后通知该系统时，就是调用的回调方法。  </li><li>Future<br>异步操作的结果的占位符，它将在未来的某个时候完成，并提供对其结果的访问。在JDK中只允许手动检测对应的操作是否已经完成，或者一直阻塞直到它完成。Netty中自己实现了ChannelFuture,用于异步操作。ChannelFuture能够注册一个或多个监听器ChannelFutureListener, 在操作完成时会调用监听器的operationComplete()方法，ChannelFutureListener提供的通知机制消除了手动检查对应操作是否完成的必要。每个Netty的传出I/O操作都将返回一个ChannelFuture，即它们不会阻塞，Netty是完成异步和事件驱动的。</li><li>事件和ChannelHandler<br>入站事件：连接已被激活或者连接失活，数据读取，用户事件，错误事件。<br>出站事件：打开或者关闭到远程节点的连接，将数据写到或者冲刷到套接字。<br>入站事件-&gt;入站处理器，出站-&gt;出站处理器<br>拦截操作以及高速地转换入站和出站数据，都只需要你提供回调函数或者利用操作返回的Future。Netty为每个Channel分配一个EventLoop来处理所有事件，包括注册感兴趣的事件，将事件派发给ChannelHandler, 安排进一步的动作。Netty的EventLoop是一个线程驱动，处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会变。      </li></ol></blockquote><h3 id="2-你的第一款Netty应用程序"><a href="#2-你的第一款Netty应用程序" class="headerlink" title="2. 你的第一款Netty应用程序"></a>2. 你的第一款Netty应用程序</h3><ol><li><p>Echo服务器</p><blockquote><ol><li>至少一个ChannelHandler，处理从客户端接收到的数据，即业务处理。  </li><li>引导，配置服务器的启动代码，绑定端口，配置Channel。</li><li>ChannelHandler继承ChannelInboundHandlerAdapter，ChannelInboundHandlerAdapter实现ChannelInboundHandler接口，响应入站事件。我们感兴趣的方法有channelRead()对于每个传入的消息要调用，channelReadComplete()通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息。exeptionCaught()在读取操作期间，有异常抛出时会调用。</li><li>针对不同类型的事件来调用ChannelHandler。  </li><li>应用程序通过实现或者扩展ChannelHandler来挂钩到事件的生命周期，并且提供自定义的应用程序逻辑。  </li><li>在架构上，ChannelHandler有助于保持业务逻辑与网络处理代码的分离。   </li><li>服务器的大致流程，其中EchoServerHandler实现业务逻辑，main方法引导服务器<br>7.1 创建一个ServerBootstrap的实例以引导和绑定服务器<br>7.2 创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接收连接以及读写数据<br>7.3 指定服务器绑定本地的InetSocketAddress<br>7.4 使用一个EchoServerHandler的实例初始化每个新的Channel<br>7.5 调用ServerBootstrap.bind()绑定服务器  </li></ol></blockquote></li><li><p>Echo客户端</p><blockquote><ol><li>客户端的流程<br>1.1 连接到服务器<br>1.2 发送一个或者多个消息<br>1.3 对于每个消息，等待并接收从服务器发回的相同的消息<br>1.4 关闭连接  </li><li>ChannelHandler继承SimpleChannelInboundHandler实现ChannelInboundHandler，主要重写三个方法，channelActive()在到服务器的连接已经建立之后将被调用，channelRead0()当从服务器接收到一条消息时被调用，exceptionCaught()在处理过程中引发异常时被调用。  </li><li>SimpleChannelInboundHandler和ChannelInboundHandlerAdapter  </li></ol></blockquote></li></ol><h3 id="3-Netty的组件和设计"><a href="#3-Netty的组件和设计" class="headerlink" title="3. Netty的组件和设计"></a>3. Netty的组件和设计</h3><h3 id="4-传输"><a href="#4-传输" class="headerlink" title="4. 传输"></a>4. 传输</h3><h3 id="5-ByteBuf"><a href="#5-ByteBuf" class="headerlink" title="5. ByteBuf"></a>5. ByteBuf</h3><h3 id="6-ChannelHandler和ChannelPipeline"><a href="#6-ChannelHandler和ChannelPipeline" class="headerlink" title="6. ChannelHandler和ChannelPipeline"></a>6. ChannelHandler和ChannelPipeline</h3><h3 id="7-Eventloop和线程模型"><a href="#7-Eventloop和线程模型" class="headerlink" title="7. Eventloop和线程模型"></a>7. Eventloop和线程模型</h3><h3 id="8-引导"><a href="#8-引导" class="headerlink" title="8. 引导"></a>8. 引导</h3><h3 id="9-单元测试"><a href="#9-单元测试" class="headerlink" title="9. 单元测试"></a>9. 单元测试</h3><h3 id="10-编解码器框架"><a href="#10-编解码器框架" class="headerlink" title="10. 编解码器框架"></a>10. 编解码器框架</h3><h3 id="11-预置的ChannelHandler和编解码器"><a href="#11-预置的ChannelHandler和编解码器" class="headerlink" title="11. 预置的ChannelHandler和编解码器"></a>11. 预置的ChannelHandler和编解码器</h3><h3 id="12-WebSocket"><a href="#12-WebSocket" class="headerlink" title="12. WebSocket"></a>12. WebSocket</h3><h3 id="13-使用UDP广播事件"><a href="#13-使用UDP广播事件" class="headerlink" title="13. 使用UDP广播事件"></a>13. 使用UDP广播事件</h3><h3 id="14-案例研究，第一部分"><a href="#14-案例研究，第一部分" class="headerlink" title="14. 案例研究，第一部分"></a>14. 案例研究，第一部分</h3><h3 id="15-案例研究，第二部分"><a href="#15-案例研究，第二部分" class="headerlink" title="15. 案例研究，第二部分"></a>15. 案例研究，第二部分</h3><h3 id="附录-Maven介绍"><a href="#附录-Maven介绍" class="headerlink" title="附录 Maven介绍"></a>附录 Maven介绍</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Netty——异步和事件驱动&quot;&gt;&lt;a href=&quot;#1-Netty——异步和事件驱动&quot; class=&quot;headerlink&quot; title=&quot;1. Netty——异步和事件驱动&quot;&gt;&lt;/a&gt;1. Netty——异步和事件驱动&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Java网络
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式事务与秒杀技巧</title>
    <link href="http://longman.kim/2018/07/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E7%A7%92%E6%9D%80%E6%8A%80%E5%B7%A7/"/>
    <id>http://longman.kim/2018/07/20/分布式事务与秒杀技巧/</id>
    <published>2018-07-20T08:07:51.000Z</published>
    <updated>2018-07-20T08:08:21.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式事务的解法"><a href="#1-分布式事务的解法" class="headerlink" title="1. 分布式事务的解法"></a>1. 分布式事务的解法</h3><ol><li><p>一个系统操作多个数据库</p><blockquote><p>XA协议（数据库要支持XA协议）<br>基本功能：数据库功能+开源组件（atomikos）实现</p></blockquote></li><li><p>多系统操作多数据库</p><blockquote><p>MQ消息队列（生产者消费者模型），优点是解耦，缺点是不能保证实时性（需要结合业务场景进行规避）  </p></blockquote></li><li><p>TCC补偿机制</p><blockquote><p>可逆操作，编程式分布式事务，一种解决方案<br>atomikos的论文《Tcc For Rest》<br>TCC三要素try(预留资源，临时状态), canfirm(确认操作), cancel(操作回滚)<br>bytetcc</p></blockquote></li><li><p>TOC</p><blockquote><p>未知异常：人工干预</p></blockquote></li><li><p>CAP,BASE</p><blockquote><p>取舍一致性和可用性</p></blockquote></li></ol><h3 id="2-秒杀系统架构分析与实现"><a href="#2-秒杀系统架构分析与实现" class="headerlink" title="2. 秒杀系统架构分析与实现"></a>2. 秒杀系统架构分析与实现</h3><ol><li><p>超卖，解决方案是使用数据库的乐观锁</p></li><li><p>用户重复提交，前端控制防止重复提交，后台限流</p></li><li><p>超过服务器单台机器承受能力，解决方案nginx负载均衡多台机器</p></li><li><p>码农通过脚本攻击，redis(性能每秒10w，用pipeline每秒55w)针对userId限制操作频率</p></li><li><p>超过数据库最大连接数，采用令牌机制，预先生成令牌放在reids中，拿到令牌的可以操作数据库</p></li><li><p>其他方法</p><blockquote><p>采用消息队列，异步执行SQL<br>数据库分库分表<br>微服务架构独立秒杀系统，Docker实现快速扩容</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式事务的解法&quot;&gt;&lt;a href=&quot;#1-分布式事务的解法&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式事务的解法&quot;&gt;&lt;/a&gt;1. 分布式事务的解法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个系统操作多个数据库&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法工程师</title>
    <link href="http://longman.kim/2018/07/19/%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://longman.kim/2018/07/19/算法工程师/</id>
    <published>2018-07-18T17:37:27.000Z</published>
    <updated>2018-07-18T17:48:25.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><h3 id="2-回归"><a href="#2-回归" class="headerlink" title="2. 回归"></a>2. 回归</h3><h3 id="3-推荐"><a href="#3-推荐" class="headerlink" title="3. 推荐"></a>3. 推荐</h3><h3 id="4-深度学习"><a href="#4-深度学习" class="headerlink" title="4. 深度学习"></a>4. 深度学习</h3><h3 id="5-强化学习"><a href="#5-强化学习" class="headerlink" title="5. 强化学习"></a>5. 强化学习</h3><h3 id="6-NLP自然语言处理"><a href="#6-NLP自然语言处理" class="headerlink" title="6. NLP自然语言处理"></a>6. NLP自然语言处理</h3><h3 id="7-机器人定位算法"><a href="#7-机器人定位算法" class="headerlink" title="7. 机器人定位算法"></a>7. 机器人定位算法</h3><h3 id="8-多传感器融合算法"><a href="#8-多传感器融合算法" class="headerlink" title="8. 多传感器融合算法"></a>8. 多传感器融合算法</h3><h3 id="9-SLAM地图构建算法"><a href="#9-SLAM地图构建算法" class="headerlink" title="9. SLAM地图构建算法"></a>9. SLAM地图构建算法</h3><h3 id="10-路径规划算法"><a href="#10-路径规划算法" class="headerlink" title="10. 路径规划算法"></a>10. 路径规划算法</h3><h3 id="11-视觉算法（检测，跟踪）"><a href="#11-视觉算法（检测，跟踪）" class="headerlink" title="11. 视觉算法（检测，跟踪）"></a>11. 视觉算法（检测，跟踪）</h3><h3 id="12-TensorFlow"><a href="#12-TensorFlow" class="headerlink" title="12. TensorFlow"></a>12. TensorFlow</h3><h3 id="13-Caffe"><a href="#13-Caffe" class="headerlink" title="13. Caffe"></a>13. Caffe</h3><h3 id="14-有监督学习"><a href="#14-有监督学习" class="headerlink" title="14. 有监督学习"></a>14. 有监督学习</h3><h3 id="15-无监督学习"><a href="#15-无监督学习" class="headerlink" title="15. 无监督学习"></a>15. 无监督学习</h3><h3 id="16-卡尔曼滤波、粒子滤波"><a href="#16-卡尔曼滤波、粒子滤波" class="headerlink" title="16. 卡尔曼滤波、粒子滤波"></a>16. 卡尔曼滤波、粒子滤波</h3><h3 id="17-马尔科夫决策过程"><a href="#17-马尔科夫决策过程" class="headerlink" title="17. 马尔科夫决策过程"></a>17. 马尔科夫决策过程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分类&quot;&gt;&lt;a href=&quot;#1-分类&quot; class=&quot;headerlink&quot; title=&quot;1. 分类&quot;&gt;&lt;/a&gt;1. 分类&lt;/h3&gt;&lt;h3 id=&quot;2-回归&quot;&gt;&lt;a href=&quot;#2-回归&quot; class=&quot;headerlink&quot; title=&quot;2. 回归&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大数据开发工程师</title>
    <link href="http://longman.kim/2018/07/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://longman.kim/2018/07/19/大数据开发工程师/</id>
    <published>2018-07-18T17:00:07.000Z</published>
    <updated>2018-07-18T17:35:23.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Hadoop生态"><a href="#1-Hadoop生态" class="headerlink" title="1. Hadoop生态"></a>1. Hadoop生态</h3><h5 id="1-对大量数据进行分布式处理的软件框架Hadoop"><a href="#1-对大量数据进行分布式处理的软件框架Hadoop" class="headerlink" title="1. 对大量数据进行分布式处理的软件框架Hadoop"></a>1. 对大量数据进行分布式处理的软件框架Hadoop</h5><h5 id="2-分布式存储系统HDFS"><a href="#2-分布式存储系统HDFS" class="headerlink" title="2. 分布式存储系统HDFS"></a>2. 分布式存储系统HDFS</h5><h5 id="3-分布式计算框架MapReduce"><a href="#3-分布式计算框架MapReduce" class="headerlink" title="3. 分布式计算框架MapReduce"></a>3. 分布式计算框架MapReduce</h5><h5 id="4-分布式计算框架YARN"><a href="#4-分布式计算框架YARN" class="headerlink" title="4. 分布式计算框架YARN"></a>4. 分布式计算框架YARN</h5><h5 id="5-分布式数据库Hbase"><a href="#5-分布式数据库Hbase" class="headerlink" title="5. 分布式数据库Hbase"></a>5. 分布式数据库Hbase</h5><h5 id="6-分布式协调服务Zookeeper"><a href="#6-分布式协调服务Zookeeper" class="headerlink" title="6. 分布式协调服务Zookeeper"></a>6. 分布式协调服务Zookeeper</h5><h5 id="7-工作流引擎Pig-Pig2"><a href="#7-工作流引擎Pig-Pig2" class="headerlink" title="7. 工作流引擎Pig, Pig2"></a>7. 工作流引擎Pig, Pig2</h5><h5 id="8-数据仓库Hive-Hive2"><a href="#8-数据仓库Hive-Hive2" class="headerlink" title="8. 数据仓库Hive, Hive2"></a>8. 数据仓库Hive, Hive2</h5><h5 id="9-日志收集Flume"><a href="#9-日志收集Flume" class="headerlink" title="9. 日志收集Flume"></a>9. 日志收集Flume</h5><h5 id="10-作业流调度系统Oozie"><a href="#10-作业流调度系统Oozie" class="headerlink" title="10. 作业流调度系统Oozie"></a>10. 作业流调度系统Oozie</h5><h5 id="11-数据库TEL工具Sqoop"><a href="#11-数据库TEL工具Sqoop" class="headerlink" title="11. 数据库TEL工具Sqoop"></a>11. 数据库TEL工具Sqoop</h5><h5 id="12-安装部署工具Ambari"><a href="#12-安装部署工具Ambari" class="headerlink" title="12. 安装部署工具Ambari"></a>12. 安装部署工具Ambari</h5><h3 id="2-大数据处理框架Spark"><a href="#2-大数据处理框架Spark" class="headerlink" title="2. 大数据处理框架Spark"></a>2. 大数据处理框架Spark</h3><h3 id="3-基于数据流的实时处理系统Storm"><a href="#3-基于数据流的实时处理系统Storm" class="headerlink" title="3. 基于数据流的实时处理系统Storm"></a>3. 基于数据流的实时处理系统Storm</h3><h3 id="4-开源流处理平台Kafka"><a href="#4-开源流处理平台Kafka" class="headerlink" title="4. 开源流处理平台Kafka"></a>4. 开源流处理平台Kafka</h3><h3 id="5-面向分布式数据流处理和批量数据处理的开源计算平台Flink"><a href="#5-面向分布式数据流处理和批量数据处理的开源计算平台Flink" class="headerlink" title="5. 面向分布式数据流处理和批量数据处理的开源计算平台Flink"></a>5. 面向分布式数据流处理和批量数据处理的开源计算平台Flink</h3><h3 id="6-基于Lucence的搜索服务器Elasticsearch"><a href="#6-基于Lucence的搜索服务器Elasticsearch" class="headerlink" title="6. 基于Lucence的搜索服务器Elasticsearch"></a>6. 基于Lucence的搜索服务器Elasticsearch</h3><h3 id="7-MapReduce"><a href="#7-MapReduce" class="headerlink" title="7. MapReduce"></a>7. MapReduce</h3><h3 id="8-系统Debug-Profiling能力和经验"><a href="#8-系统Debug-Profiling能力和经验" class="headerlink" title="8. 系统Debug/Profiling能力和经验"></a>8. 系统Debug/Profiling能力和经验</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Hadoop生态&quot;&gt;&lt;a href=&quot;#1-Hadoop生态&quot; class=&quot;headerlink&quot; title=&quot;1. Hadoop生态&quot;&gt;&lt;/a&gt;1. Hadoop生态&lt;/h3&gt;&lt;h5 id=&quot;1-对大量数据进行分布式处理的软件框架Hadoop&quot;&gt;&lt;a h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂味</title>
    <link href="http://longman.kim/2018/07/18/%E6%9D%82%E5%91%B3/"/>
    <id>http://longman.kim/2018/07/18/杂味/</id>
    <published>2018-07-18T13:49:13.000Z</published>
    <updated>2018-07-18T16:55:27.424Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-MySQL主从同步的实现方式"><a href="#1-MySQL主从同步的实现方式" class="headerlink" title="1. MySQL主从同步的实现方式"></a>1. MySQL主从同步的实现方式</h5><blockquote><p>MySQL的复制是异步实时，具体步骤是：主服务器把数据更改记录写到binlog中，从服务器把binlog复制到自己的中继日志relay log中，然后重做中继日志，把更改应用到自己的数据库。</p></blockquote><h5 id="2-MySQL存储引擎的对比"><a href="#2-MySQL存储引擎的对比" class="headerlink" title="2. MySQL存储引擎的对比"></a>2. MySQL存储引擎的对比</h5><ol><li><p>Innodb</p><blockquote><p>支持事务、OLTP、行锁、支持外键、缓存索引缓存数据、MVCC(多版本并发控制)</p></blockquote></li><li><p>MyISAM</p><blockquote><p>不支持事务、OLAP、表锁、只缓存索引不缓存数据</p></blockquote></li></ol><h5 id="3-MySQL索引的实现"><a href="#3-MySQL索引的实现" class="headerlink" title="3. MySQL索引的实现"></a>3. MySQL索引的实现</h5><ol><li><p>B+树索引  </p><blockquote><p>记录节点按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。B树中的关键字分布在整棵树中，叶子节点不包含任何关键字信息，而B+树关键字集合分布在叶子节点中，非叶子节点只是叶子节点中关键字的索引。B树中任何一个关键字只出现在一个节点中，而B+树中的关键字必须出现在叶节点中，也可能在非叶节点中重复出现。<br>B+树比B树更适合做文件索引和数据库索引。B树只适合随机检索，B+树同时支持随机检索和顺序检索。B+树的磁盘读写代价更低。B+树的查询效率更加稳定。数据库中基于范围的查询是非常频繁的。<br>B+树索引支持 like ‘xxx%’和 like ‘%xxx’</p></blockquote></li><li><p>全文检索  </p><blockquote><p>倒排索引<br>全文索引支持 like ‘%xxx%’</p></blockquote></li></ol><h5 id="4-处理内存泄漏的经验"><a href="#4-处理内存泄漏的经验" class="headerlink" title="4. 处理内存泄漏的经验"></a>4. 处理内存泄漏的经验</h5><h5 id="5-长连接，离线推送，在线推送，及时通信IM，直播"><a href="#5-长连接，离线推送，在线推送，及时通信IM，直播" class="headerlink" title="5. 长连接，离线推送，在线推送，及时通信IM，直播"></a>5. 长连接，离线推送，在线推送，及时通信IM，直播</h5><ol><li><p>长连接</p><blockquote><p> HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP/1.0默认使用短连接，一次HTTP操作，就建立一次连接，任务结束就中断连接。HTTP/1.1默认使用长连接Connection:keep-alive，保持一定的时间，没有请求再断开。TCP长连接的保活功能主要由服务器应用提供，在给定的连接两个小时内没有任何动作，服务器就会向客户端发送一个探测报文。长连接多用户操作频繁，点对点的通讯，而且连接数不能太多。</p></blockquote></li><li><p>即时通讯IM</p><blockquote><p>C1,C2登录时即时服务IM验证用户名和密码，并登记各自的IP和PORT，并从服务器上拉取好友列表（包括好友的IP和PORT）给C1,C2。C1和C2通讯的方式有两种，一种是C1和C2之间采用TCP连接通讯。一种是C1和Server, C2和Server进行TCP连接，即使用Server中转通讯。<br>如果C1,C2都在内网，需要进行路由器进行NAT才能出去。使用STUN隧道技术，完成透明NAT，受限NAT，端口受限圆锥型NAT，对称型NAT（双向NAT，大公司使用）。<br>同时需要客户端给服务器发送心跳，如果没有响应，就断开长连接。还需要考虑重连机制、双向PingPong机制（ping对方，如果没有在约定的时间内返回就断开socket）、QOS机制（服务质量保证通讯延迟和阻塞）。<br>聊天协议：原生Socket(代表框架CocoAsyncSocket)、WebSocket(代表框架SocketRocket)、MQTT(代表框架MQTTKit)、XMPP(代表框架XMPPFramework)</p></blockquote></li></ol><h5 id="6-https的步骤"><a href="#6-https的步骤" class="headerlink" title="6. https的步骤"></a>6. https的步骤</h5><ol><li>client发送连接请求给server</li><li>server返回服务端证书给client</li><li>client通过浏览器内置根证书对服务端证书CA进行校验</li><li>client通过证书中的公钥加密对称密钥发送给server</li><li>双方通过对称密钥加密数据开始通信</li></ol><h5 id="7-ACCS-阿里云通道服务"><a href="#7-ACCS-阿里云通道服务" class="headerlink" title="7. ACCS(阿里云通道服务)"></a>7. ACCS(阿里云通道服务)</h5><h5 id="8-构建高性能的分布式系统"><a href="#8-构建高性能的分布式系统" class="headerlink" title="8. 构建高性能的分布式系统"></a>8. 构建高性能的分布式系统</h5><ol><li>分布式服务治理框架Dubbo</li><li>分布式消息中间件RocketMQ</li><li>数据库连接池Druid和JSON库Fastjson</li><li>云数据库Redis分支ApasaraCache</li><li>自研富容器技术Pouch和文件分发系统Dragonfly</li><li>开源数据看看AliSQL</li><li>分布式文件系统FastDFS</li><li>分布式数据库OceanBase</li><li>Web服务器Tengine</li><li>Redis缓存服务器AliRedis</li><li>分布式数据库同步系统otter</li><li>系统信息采集和监控工具Tsar</li><li>非侵入式运行期AOP框架Dexposed</li></ol><h5 id="9-互联网时代的用户端"><a href="#9-互联网时代的用户端" class="headerlink" title="9. 互联网时代的用户端"></a>9. 互联网时代的用户端</h5><ol><li>Ant Design，前端的美好呈现</li><li>企业级Web基础框架Egg</li><li>灵活的Android开发框架Atlas</li><li>跨平台移动开发工具Weex </li></ol><h5 id="10-源自最佳实践的参考规范"><a href="#10-源自最佳实践的参考规范" class="headerlink" title="10. 源自最佳实践的参考规范"></a>10. 源自最佳实践的参考规范</h5><ol><li>阿里巴巴Java开发规范</li><li>分布式消息领域的国际标准OpenMessaging</li></ol><h5 id="11-物联网时代"><a href="#11-物联网时代" class="headerlink" title="11. 物联网时代"></a>11. 物联网时代</h5><ol><li>新一代物联网操作系统AliOS Things</li><li>轻量化操作系统AliOS Lite</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-MySQL主从同步的实现方式&quot;&gt;&lt;a href=&quot;#1-MySQL主从同步的实现方式&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL主从同步的实现方式&quot;&gt;&lt;/a&gt;1. MySQL主从同步的实现方式&lt;/h5&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java程序性能优化</title>
    <link href="http://longman.kim/2018/07/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://longman.kim/2018/07/17/Java程序性能优化/</id>
    <published>2018-07-17T14:25:03.000Z</published>
    <updated>2018-07-17T14:25:03.362Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java架构师技术图谱</title>
    <link href="http://longman.kim/2018/07/17/Java%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <id>http://longman.kim/2018/07/17/Java架构师技术图谱/</id>
    <published>2018-07-16T16:23:31.000Z</published>
    <updated>2018-07-17T13:19:25.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1. 源码分析"></a>1. 源码分析</h3><h5 id="1-常用设计模式"><a href="#1-常用设计模式" class="headerlink" title="1. 常用设计模式"></a>1. 常用设计模式</h5><ol><li><p>Proxy代理模式</p><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问，例如Spring AOP。</p></blockquote></li><li><p>Factory工厂模式</p><blockquote><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，例如数据库访问。</p></blockquote></li><li><p>Singleton单例模式</p><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote></li></ol><ol start="4"><li><p>Delegate委派模式</p><blockquote></blockquote></li><li><p>Strategy策略模式</p><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换。</p></blockquote></li><li><p>Prototype原型模式</p><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote></li><li><p>Template模板模式</p><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote></li></ol><h5 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2. Spring"></a>2. Spring</h5><ol><li>Beans<blockquote><p>1 接口实例化<br>构造函数、静态工厂、实例工厂<br>BeanFactory getBean() -&gt; 默认构造函数 -&gt; 属性值注入 -&gt; 实现了InitializingBean接口调用afterPropertiesSet() -&gt; init-method</p></blockquote></li></ol><blockquote><p>2 代理Bean操作<br>JDK的Proxy代理类，CGLIB</p></blockquote><ol start="2"><li>Context<blockquote><p>1 IOC容器设计原理及高级特性<br>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。反射（reflection）允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p></blockquote></li></ol><blockquote><p>2 AOP设计原理<br>JDK的Proxy代理类，CGLIB</p></blockquote><blockquote><p>3 FactoryBean与BeanFactory<br>BeanFactory是IOC最基本的容器，负责生产和管理bean，例如DefaultListableBeanFactory。<br>FactoryBean是一个接口，当容器实现了FactoryBean之后，通过getBean获取到的Bean对象，是实现类中的getObject方法返回的对象。</p></blockquote><ol start="3"><li>Transaction<blockquote><p>1 声明式事务底层原理<br>@Transaction注解，传播行为，隔离级别，是否只读，事务超时，回滚规则。事务管理的切面属于<a href="aop:around" target="_blank" rel="noopener">aop:around</a>即AOP环绕类型的切面。</p></blockquote></li></ol><blockquote><p>2 Spring事务处理机制</p></blockquote><blockquote><p>3 事务的传播与监控<br>PROPAGATION_REQUIRED<br>默认传播机制，支持当前事务，如果没有，则新建一个事务。<br>PROPAGATION_REQUIRED_NEW<br>新建事务，如果当前存在事务，把当前事务挂起。新建的事务与被挂起的事务没有任何关系，是独立的两个事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作。<br>PROPAGATION_SUPPORTS<br>支持当前事务，如果没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY<br>支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_NOT_SUPPORTED<br>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER<br>以非事务方式执行操作，如果当前存在事务，则抛出异常。<br>PROPAGATION_NESTED<br>如果一个事务存在，则运行在一个嵌套的事务中。</p></blockquote><blockquote><p>4 基于Springjdbc手写orm框架</p></blockquote><ol start="4"><li>MVC<blockquote><p>1 MVC原理<br>模型，视图，控制器。</p></blockquote></li></ol><blockquote><p>2 与IOC容器整合的原理</p></blockquote><blockquote><p>3 HandlerMapping实现原理<br>负责定位</p></blockquote><blockquote><p>4 HandlerAdapter实现原理<br>负责调用</p></blockquote><blockquote><p>5 ViewResolver实现原理<br>视图解析</p></blockquote><blockquote><p>6 Controller调用原理</p></blockquote><blockquote><p>7 动态参数匹配原理</p></blockquote><blockquote><p>8 手写实现SpringMVC框架<br>请求-&gt;DispatcherServlet-&gt;处理器映射-&gt;控制器-&gt;模式及逻辑视图名-&gt;视图解析器-&gt;视图-&gt;响应</p></blockquote><h5 id="3-Mybatis"><a href="#3-Mybatis" class="headerlink" title="3. Mybatis"></a>3. Mybatis</h5><ol><li>代码自动生成器：Generator</li><li><p>Mybatis下1对多、多对多嵌套结果、嵌套查询</p></li><li><p>一级缓存、二级缓存使用场景及选择策略</p><blockquote><p>在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认开启一级缓存。二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存。二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个Mapper的二级缓存区域。</p></blockquote></li><li><p>Mybatis与Spring集成Spring-Mybatis分析</p></li><li><p>Spring集成下的SqlSession与Mapper</p></li><li><p>Mybatis的事务</p></li><li><p>分析Mybatis的动态代理的真正实现</p></li><li><p>一步一步手写实现Mybatis1.0到2.0</p></li></ol><p>###2. 并发编程</p><h5 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h5><ol><li>线程通信<blockquote><ol><li>共享内存<br>线程之间通过写-读内存中的公共状态  </li><li>消息传递</li></ol></blockquote></li></ol><h5 id="2-内存模型"><a href="#2-内存模型" class="headerlink" title="2. 内存模型"></a>2. 内存模型</h5><ol><li><p>重排序</p><blockquote><ol><li>编译器优化的重排序</li><li>处理器重排序，指令级并行技术ILP</li><li>内存系统的重排序</li></ol></blockquote></li><li><p>顺序一致性</p></li></ol><ol start="3"><li><p>Happen-Before</p><blockquote><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p></blockquote></li><li><p>As-If-Serial</p><blockquote><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会改变。</p></blockquote></li></ol><h5 id="3-Synchronized"><a href="#3-Synchronized" class="headerlink" title="3. Synchronized"></a>3. Synchronized</h5><ol><li>同步、重量级锁</li><li>Syncronized原理</li><li>锁优化<blockquote><ol><li>自旋锁</li><li>轻量级锁</li><li>重量级锁</li><li>偏向锁</li></ol></blockquote></li></ol><h5 id="4-Volatile"><a href="#4-Volatile" class="headerlink" title="4. Volatile"></a>4. Volatile</h5><ol><li>Volatile实现机制</li><li>内存语义</li><li>内存模型</li></ol><h5 id="5-DCL"><a href="#5-DCL" class="headerlink" title="5. DCL"></a>5. DCL</h5><ol><li>单例模式</li><li>DCL</li><li>解决方案</li></ol><h5 id="6-并发基础"><a href="#6-并发基础" class="headerlink" title="6. 并发基础"></a>6. 并发基础</h5><ol><li><p>AQS</p><blockquote><ol><li>AbstractQueuedSyncronizer同步器</li><li>CLH同步队列</li><li>同步状态的获取与释放</li><li>线程阻塞与唤醒</li></ol></blockquote></li><li><p>CAS</p><blockquote><ol><li>Compare And Swap</li><li>缺陷</li></ol></blockquote></li></ol><h5 id="7-锁"><a href="#7-锁" class="headerlink" title="7. 锁"></a>7. 锁</h5><ol><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>Condition</li></ol><h5 id="8-并发工具类"><a href="#8-并发工具类" class="headerlink" title="8. 并发工具类"></a>8. 并发工具类</h5><ol><li>CyclicBarrier</li><li>CountdownLatch</li><li>Semphore</li></ol><h5 id="9-并发集合"><a href="#9-并发集合" class="headerlink" title="9. 并发集合"></a>9. 并发集合</h5><ol><li>ConcurrentHashMap</li><li>ConcurrentLinkedQueue</li></ol><h5 id="10-原子操作"><a href="#10-原子操作" class="headerlink" title="10. 原子操作"></a>10. 原子操作</h5><ol><li><p>基本类型</p><blockquote><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ol></blockquote></li><li><p>数组</p><blockquote><ol><li>AtomicIntegerArrary</li><li>AtomicLongArrary</li><li>AtomicReferenceArrary</li></ol></blockquote></li><li><p>引用类型</p><blockquote><ol><li>AtomicReference</li><li>AtomicReferenceFieldUpdater</li></ol></blockquote></li></ol><h5 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11. 线程池"></a>11. 线程池</h5><ol><li>Executor</li><li>ThreadPoolExecutor</li><li>Callable和Future</li><li>ScheduledExecutorService</li></ol><h5 id="12-其他"><a href="#12-其他" class="headerlink" title="12. 其他"></a>12. 其他</h5><ol><li>ThreadLocal</li><li>Fork/Join</li></ol><p>###3. 性能调优</p><p>###4. 分布式架构</p><h5 id="1-漫谈分布式架构"><a href="#1-漫谈分布式架构" class="headerlink" title="1. 漫谈分布式架构"></a>1. 漫谈分布式架构</h5><ol><li>初识分布式架构及意义</li><li>如何把应用从单机扩展到分布式</li><li><p>构建分布式架构最重要因素</p><blockquote><ol><li>CDN加速静态文件访问</li><li>分布式存储</li><li>分布式搜索引擎</li><li>应用发布与监控</li><li>应用容灾及机房规划</li><li>系统动态扩容</li></ol></blockquote></li><li><p>分布式架构设计</p><blockquote><ol><li>主流架构模型-SOA架构与微服务架构</li><li>领域驱动设计及业务驱动划分</li><li>分布式架构的基本理论CAP,BASE及其应用</li><li>什么是分布式架构下的高可用设计</li><li>分布式架构下的可伸缩设计</li><li>构建高性能的分布式架构</li></ol></blockquote></li></ol><h5 id="2-分布式架构策略-分而治之"><a href="#2-分布式架构策略-分而治之" class="headerlink" title="2. 分布式架构策略-分而治之"></a>2. 分布式架构策略-分而治之</h5><ol><li>从简到难，从网络通信探究分布式通信的原理</li><li>基于消息方式的系统间通信</li><li>理解通信协议传输过程中的序列化与反序列化机制</li><li><p>基于框架的RPC通信技术</p><blockquote><ol><li>Webservice/Apache Cxf</li><li>RMI/Spring RMI</li><li>Hessian</li></ol></blockquote></li><li><p>传统RPC技术在大型分布式架构下面临的问题</p></li><li>分布式架构下的RPC解决方案</li><li><p>分布式系统的基石-Zookeeper</p><blockquote><ol><li>从0开始搭建3个节点的Zookeeper集群</li><li>深入分析Zookeeper在Discon配置中心的应用</li><li>基于Zookeeper的分布式锁解决方案</li><li>Zookeeper集群升级、迁移</li><li>基于Zookeeper实现分布式服务器动态上线感知</li><li>深入分析Zookeeper ZAB协议及选举机制源码解读</li></ol></blockquote></li><li><p>使用Dubbo对单一应用服务改造</p><blockquote><ol><li>Dubbo管理中心及监控平台安装部署</li><li>Dubbo分布式服务模块划分（领域驱动）</li><li>基于Dubbo的分布式系统架构实战</li><li>Dubbo负载均衡策略分析</li><li>Dubbo服务调试之服务只订阅及服务只注册配置</li><li>Dubbo服务接口的设计原则（实战经验分享）</li><li>Dubbo设计原理及源码分析</li><li>基于Dubbo构建大型分布式电商平台实战雏形</li><li>Dubbo容器机制及高扩展分析</li></ol></blockquote></li></ol><h5 id="3-分布式架构-中间件"><a href="#3-分布式架构-中间件" class="headerlink" title="3. 分布式架构-中间件"></a>3. 分布式架构-中间件</h5><ol><li><p>分布式消息通信</p><blockquote><ol><li>消息中间件在分布式架构中的作用</li><li>ActiveMQ高可用集群企业级部署方案</li><li>ActiveMQ P2P及Pub/Sub模型详解</li><li>ActiveMQ消息确认及重发策略</li><li>ActiveMQ基于Spring完全分布式消息队列实战</li><li>Kafka基于Zookeeper搭建高可用集群实战</li><li>Kafka消息处理过程剖析</li><li>Java客户端实现Kafka生产者与消费者实例</li><li>Kafka的副本机制及选举原理剖析</li><li>基于Kafka实现应用日志实时上报统计分析</li><li>初步认识RabbitMQ及高可用集群部署</li><li>了解RabbitMQ消息分发机制及主题消息分发</li><li>RabbitMQ消息路由机制分析</li><li>RabbitMQ消息确认机制</li></ol></blockquote></li><li><p>分布式缓存</p><blockquote><ol><li>从入门到精通，Redis的数据结构分析</li><li>Redis主从复制原理及无磁盘复制分析</li><li>Redis管道模式详解</li><li>Redis缓存与数据库一致性问题解决方案</li><li>基于Redis实现分布式锁实战</li><li>图解Redis中aof和rdb持久化策略的原理</li><li>Redis读写分离架构实践</li><li>Redis哨兵架构及数据丢失问题分析</li><li>Redis Cluster数据分布算法之Hash Slot</li><li>Redis使用常见问题及性能优化思路</li><li>Redis高可用及高伸缩架构实战</li><li>缓存击穿、缓存雪崩预防策略</li><li>Redis批量查询优化</li><li>Redis高性能集群之Twemproxy or Codis</li></ol></blockquote></li></ol><ol start="3"><li>数据存储<blockquote><ol><li>NoSQL简介及Mongodb基本概念</li><li>Mongodb支持的数据类型分析</li><li>Mongodb可视化客户端及Java API实践</li><li>手写基于Mongodb的orm框架</li><li>Mongodb企业级集群解决方案</li><li>Mongodb聚合、索引及基本执行命令</li><li>Mongodb数据分片、转存及恢复策略</li><li>MySQL主从复制及读写分离</li><li>MySQL+Keepalived实现双主高可用方案实践</li><li>MySQL高性能解决方案之分库分表</li><li>数据库中间件初识Mycat</li><li>基于Mycat实现MySQL数据库读写分离</li><li>基于Mycat实战之数据库切分策略剖析</li><li>Mycat全局表、E表、分片策略分析</li></ol></blockquote></li></ol><ol start="4"><li>后台服务<blockquote><ol><li>基于Openretry部署应用层Nginx以及Nginx+Lua实践</li><li>Nginx反向代理服务器及负载均衡服务配置实战</li><li>利用Keepalived+Nginx实践Nginx高可用方案</li><li>基于Nginx实现访问控制、连接限制</li><li>Nginx动静分离实战</li><li>Nginx Location，Rewrite等语法配置及原理分析</li><li>Nginx提供Https服务</li><li>基于Nginx+Lua完成访问流量实时上报Kafka的实战</li></ol></blockquote></li></ol><ol start="5"><li>高性能NIO框架<blockquote><ol><li>IO的基本概念、NIO、AIO、BIO深入分析</li><li>NIO的核心设计思想</li><li>Netty产生的背景及应用场景分析</li><li>基于Netty实现高性能lm聊天</li><li>基于Netty实现Dubbo多协议通信支持</li><li>Netty无锁串行化及高并发处理机制</li><li>手写实现多协议RPC框架</li></ol></blockquote></li></ol><h5 id="4-分布式解决方案"><a href="#4-分布式解决方案" class="headerlink" title="4. 分布式解决方案"></a>4. 分布式解决方案</h5><ol><li>分布式全局ID生成方案</li><li>Session跨域共享及企业级单点登录解决方案实战</li><li>分布式事务解决方案实战</li><li>高并发下的服务降级、限流实战</li><li>基于分布式架构下分布式锁的解决方案实战</li><li>分布式架构下实现分布式定时调度</li></ol><p>###5. 微服务架构</p><h5 id="1-微框架"><a href="#1-微框架" class="headerlink" title="1. 微框架"></a>1. 微框架</h5><ol><li>Spring Boot与微服务之间的关系</li><li>Spring Boot热部署实战</li><li>核心组件之Starter、Actuator、Auto-Configuration、Cli</li><li>Spring Boot集成Mybatis实现多数据源路由实战</li><li>Spring Boot集成Dubbo实战</li><li>Spring Boot集成Redis实战</li><li>Spring Boot集成Swagger2构建API管理及测试体系</li><li>Spring Boot实现多环境配置动态解析</li></ol><h5 id="2-SpringCloud"><a href="#2-SpringCloud" class="headerlink" title="2. SpringCloud"></a>2. SpringCloud</h5><ol><li>Eureka注册中心</li><li>Ribbon集成Rest实现负载均衡</li><li>Fegion声明式服务调用</li><li>Hystrix服务熔断降级方式</li><li>Zuul实现微服务网关</li><li>Config分布式统一配置中心</li><li>Sleuth调用链路跟踪</li><li>Blus消息总线</li><li>基于Hystrix实现接口降级实战</li><li>Spring Boot集成Spring Cloud实现统一整合方案</li></ol><h5 id="3-Docker虚拟化"><a href="#3-Docker虚拟化" class="headerlink" title="3. Docker虚拟化"></a>3. Docker虚拟化</h5><ol><li>了解Docker的镜像、仓库、容器</li><li>Dockerfile构建lnmp环境部署个人博客wordpress</li><li>Docker Compose构建lnmp环境部署个人博客wordpress</li><li>Docker网络组成、路由互联、Openvswitch</li><li>基于Swarm构建Docker集群实战</li><li>Kubernetes简介</li></ol><h5 id="4-漫谈微服务架构"><a href="#4-漫谈微服务架构" class="headerlink" title="4. 漫谈微服务架构"></a>4. 漫谈微服务架构</h5><ol><li>SOA架构和微服务架构之间的区别和联系</li><li>如何设计微服务及其设计原则</li><li>解惑Spring Boot流行因素及能够解决什么问题</li><li>什么事Spring Cloud，为何选择Spring Cloud</li><li>基于全局分析Spring Cloud各个组件所解决的问题</li></ol><p>###6. 电商项目实战</p><h5 id="1-用户认证系统（Passport）"><a href="#1-用户认证系统（Passport）" class="headerlink" title="1. 用户认证系统（Passport）"></a>1. 用户认证系统（Passport）</h5><ol><li><p>用户注册</p></li><li><p>用户登录</p><blockquote><ol><li>Sso单点登录</li><li>第三方登录</li></ol></blockquote></li><li><p>用户权限控制</p><blockquote><ol><li>UI页面拦截</li><li>业务方法拦截</li></ol></blockquote></li></ol><h5 id="2-搜索模块（大数据）"><a href="#2-搜索模块（大数据）" class="headerlink" title="2. 搜索模块（大数据）"></a>2. 搜索模块（大数据）</h5><h5 id="3-商品管理系统（Item）"><a href="#3-商品管理系统（Item）" class="headerlink" title="3. 商品管理系统（Item）"></a>3. 商品管理系统（Item）</h5><h5 id="4-订单系统（Order）"><a href="#4-订单系统（Order）" class="headerlink" title="4. 订单系统（Order）"></a>4. 订单系统（Order）</h5><h5 id="5-支付系统（Pay）"><a href="#5-支付系统（Pay）" class="headerlink" title="5. 支付系统（Pay）"></a>5. 支付系统（Pay）</h5><h5 id="6-数据统计分析系统（Anal）"><a href="#6-数据统计分析系统（Anal）" class="headerlink" title="6. 数据统计分析系统（Anal）"></a>6. 数据统计分析系统（Anal）</h5><h5 id="7-通知推送系统"><a href="#7-通知推送系统" class="headerlink" title="7. 通知推送系统"></a>7. 通知推送系统</h5><ol><li><p>融云推送</p><blockquote><ol><li>活动推送</li><li>交易信息推送</li><li>异常提醒</li></ol></blockquote></li><li><p>消息中间件</p><blockquote><ol><li>消息同步</li><li>消息处理</li></ol></blockquote></li></ol><h5 id="8-聊天系统"><a href="#8-聊天系统" class="headerlink" title="8. 聊天系统"></a>8. 聊天系统</h5><ol><li>用户群聊</li><li>点对点聊天</li><li>文件断点续传</li></ol><p>###7. 团队协作效率</p><h5 id="1-Maven-Gradle"><a href="#1-Maven-Gradle" class="headerlink" title="1. Maven/Gradle"></a>1. Maven/Gradle</h5><h5 id="2-Jenkins"><a href="#2-Jenkins" class="headerlink" title="2. Jenkins"></a>2. Jenkins</h5><h5 id="3-Sonar"><a href="#3-Sonar" class="headerlink" title="3. Sonar"></a>3. Sonar</h5><h5 id="4-Git"><a href="#4-Git" class="headerlink" title="4. Git"></a>4. Git</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-源码分析&quot;&gt;&lt;a href=&quot;#1-源码分析&quot; class=&quot;headerlink&quot; title=&quot;1. 源码分析&quot;&gt;&lt;/a&gt;1. 源码分析&lt;/h3&gt;&lt;h5 id=&quot;1-常用设计模式&quot;&gt;&lt;a href=&quot;#1-常用设计模式&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从Paxos到Zookeeper分布式一致性原理与实践</title>
    <link href="http://longman.kim/2018/07/15/%E4%BB%8EPaxos%E5%88%B0Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://longman.kim/2018/07/15/从Paxos到Zookeeper分布式一致性原理与实践/</id>
    <published>2018-07-15T10:27:30.000Z</published>
    <updated>2018-07-16T16:22:28.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式架构"><a href="#1-分布式架构" class="headerlink" title="1. 分布式架构"></a>1. 分布式架构</h3><ol><li>从集中式到分布式<blockquote><ol><li>集中式的特点<br>IBM的System/360系列大型主机是集中式计算机系统架构的代表，部署结构简单，单机性能卓越。  </li><li>分布式的特点<br>分布性，多台计算机在空间上随意分布，且机器的分布情况也会随时变动。<br>对等性，计算机之间没有主从之分，都是对等的。副本是分布式系统对数据和服务提供的一种冗余方式，数据副本解决数据丢失问题，服务副本使每个节点都能处理请求。<br>并发性，并发操作共享资源。缺乏全局时钟，很难定义两个事件究竟谁先谁后。故障总是会发生，一条黄金定理是设计时考虑到的异常情况一定会发生。    </li><li>分布式环境的各种问题<br>通信异常，网络光纤、路由器和DNS等硬件设备不可用导致通信异常，系统之间存在延时等。<br>网络分区，分布式系统中只有部分节点能够正常通信，而另一些节点不能，俗称脑裂，存在分布式一致性问题。<br>三态，成功、失败与超时，其中超时情况下无法确定请求是否成功。<br>节点故障，组成分布式系统的服务器节点出现的宕机或者僵死现象。</li></ol></blockquote></li></ol><ol start="2"><li>从ACID到CAP/BASE  <blockquote><ol><li>ACID<br>事务的四个特性。原子性，要么全部成功执行，要么全部不执行。一致性，数据库必须从一个一致性状态转变到另一个一致性状态，不存在事务对数据库的修改一部分已写入另一部没有。隔离性，并发的事务不能相互干扰。持久性，即事务一旦提交，对数据库中对于数据的状态变更就应该是永久性的。</li><li>事务的隔离性<br>未授权读取，最低级别，允许脏读。A事务对数据做了一系列修改但未提交，B事务可以看到数据这一系列的中间值。<br>授权读取，与未授权读取的区别是只允许获取已经被提交的数据，授权读取允许不可重复读。<br>可重复读取，保证在事务的处理过程中，多次读取同一个数据，其值都和事务开始时刻一致的，禁止了不可重复读取(一个事务中多次读取的数据不一样)和脏读（提交前读取，读取后发生回滚），但会出现幻读（读取之后另个一事务插入了新数据）。<br>串行化，要求所有的事务都被串行化执行，不能并发。<br>一般的做法是设置成授权读取，加上乐观锁或者悲观锁。    </li><li>分布式事务<br>事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。  </li><li>CAP和BASE理论<br>CAP理论告诉我们一个分布式系统不可能同时满足一致性（所有的数据都能都得到最新的值）、可用性（在有限时间内返回结果）和分区容错性（任何网络分区有故障仍然能提供一致性和可用性服务），最多只能同时满足其中的两项，其中分区容错性是必须保证的，只需要在一致性和可用性之间寻求平衡。<br>BASE，基本可用（损失部分功能，损失响应时间），弱状态（存在中间状态），最终一致性（经过一段时间后数据一致）。最终一致性的5类变体，因果一致性、读己之所写、会话一致性、单调读一致性、单调写一致性。</li></ol></blockquote></li></ol><h3 id="2-一致性协议"><a href="#2-一致性协议" class="headerlink" title="2. 一致性协议"></a>2. 一致性协议</h3><ol><li><p>2PC与3PC</p><blockquote><ol><li>2PC<br>提交事务请求，事务询问-&gt;执行事务-&gt;各参与者向协调者反馈事务询问的响应<br>执行事务提交，发送提交请求-&gt;事务提交-&gt;反馈事务提交结果-&gt;完成事务，发送回滚请求-&gt;事务回滚-&gt;反馈事务回滚结果-&gt;中断事务<br>原理简单，实现方便。同步阻塞，协调者的单点问题，脑裂，太过保守。  </li><li>3PC<br>阶段一CanCommit，事务询问-&gt;各参与者向协调者反馈事务询问的响应<br>阶段二PreCommit，执行事务预提交，发送预提交请求-&gt;事务预提交-&gt;各参与者向协调者反馈事务执行的响应。中断事务，发送中断请求-&gt;中断事务<br>阶段三doCommit，执行提交，发送提交请求-&gt;事务提交-&gt;反馈事务提交结果-&gt;完成事务。中断事务，发送中断请求-&gt;事务回滚-&gt;反馈事务回滚结果-&gt;中断事务。<br>存在数据不一致情况</li></ol></blockquote></li><li><p>Paxos算法</p><blockquote><ol><li>假设不存在拜占庭将军问题，即消息都是完整的，没有被篡改，在这种情况下提出了Paxos算法。Paxos小岛采用议会的形式通过法令，通过信使传递消息。  </li><li>问题描述，提案的选定，推导过程，数学归纳法证明，Proposer生成提案，Acceptor批准提案，算法优化，算法陈述</li></ol></blockquote></li></ol><h3 id="3-Paxos的工程实践"><a href="#3-Paxos的工程实践" class="headerlink" title="3. Paxos的工程实践"></a>3. Paxos的工程实践</h3><ol><li>Chubby</li><li>Hypertable</li></ol><h3 id="4-Zookeeper与Paxos"><a href="#4-Zookeeper与Paxos" class="headerlink" title="4. Zookeeper与Paxos"></a>4. Zookeeper与Paxos</h3><ol><li>初识Zookeeper</li><li>Zookeeper的ZAB协议</li></ol><h3 id="5-使用Zookeeper"><a href="#5-使用Zookeeper" class="headerlink" title="5. 使用Zookeeper"></a>5. 使用Zookeeper</h3><h3 id="6-Zookeeper的典型应用场景"><a href="#6-Zookeeper的典型应用场景" class="headerlink" title="6. Zookeeper的典型应用场景"></a>6. Zookeeper的典型应用场景</h3><h3 id="7-Zookeeper技术内幕"><a href="#7-Zookeeper技术内幕" class="headerlink" title="7. Zookeeper技术内幕"></a>7. Zookeeper技术内幕</h3><ol><li>系统模型  </li><li>序列化与协议</li><li>客户端</li><li>会话</li><li>服务器启动</li><li>Leader选举<blockquote><ol><li>Leader  </li><li>Follower  </li><li>Observer  </li><li>集群间消息通信  </li></ol></blockquote></li><li>各服务器角色介绍</li><li>请求处理</li><li>数据与存储</li></ol><h3 id="8-Zookeeper运维"><a href="#8-Zookeeper运维" class="headerlink" title="8. Zookeeper运维"></a>8. Zookeeper运维</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式架构&quot;&gt;&lt;a href=&quot;#1-分布式架构&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式架构&quot;&gt;&lt;/a&gt;1. 分布式架构&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;从集中式到分布式&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;集中式的特点&lt;br&gt;IB
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机行业职业发展路线的一些思考</title>
    <link href="http://longman.kim/2018/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://longman.kim/2018/07/15/计算机行业职业发展路线的一些思考/</id>
    <published>2018-07-15T01:54:54.000Z</published>
    <updated>2018-07-15T09:02:04.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>想想自己在计算机行业待了快9年了（本科4年，研究生3年，工作2年），对这个行业却只能说是初步了解。读书期间很抵触做网站，但自己却一个网站都没有搭起来过。那时候很崇拜算法，但没有深入学习，算法也是普通人的水平。现在我工作2年了，从事网站后台开发，却依然是菜鸟级别。技术水平菜，为人处世又不成熟，所以过得让自己不开心，也让身边的人不开心。自命清高，眼高手低，也许说的就是我这种人吧。努力想改变这种状态，却依然在网络上寻找灵丹妙药。其实网上有很多建议，但可能只针对部分人有用，因为每个人自身的情况，所处的环境都不相同。小人常立志，圣人立长志，这句话是从亲人身上学到的。人应该有个目标，然后有自制力的执行自己的目标。有志者，事竟成，破釜沉舟，百二秦关终属楚，苦心人，天不负，卧薪尝胆，三千越甲可吞吴。</p><h3 id="2-行业的预见"><a href="#2-行业的预见" class="headerlink" title="2. 行业的预见"></a>2. 行业的预见</h3><p>我预见计算机行业未来将只会存在设计师、全栈开发工程师、算法工程师、硬件工程师。  </p><ol><li><strong><em>设计师</em></strong><br>人，希望自己独一无二，希望自己美丽漂亮。对美的追求植根于所有人的心中，设计师是将思想化为现实的桥梁，他们需要灵感。设计师就是艺术家，艺术家是为了洗涤人的精神世界，无形而威力巨大。  </li><li><strong><em>全栈开发</em></strong><br>随着技术的不断发展，网站开发的需求量会逐渐减少。到最后，会被云计算公司，类似于亚马逊、微软、阿里巴巴这样的公司所垄断。普通的前端后端开发工程师将会非常被动，因为普通公司的网站都交给那些大型巨头做了，中小型公司不需要自己的IT部门。以后对于普通网站开发的需求，应该是中大型公司，他们要求全栈开发并且对某个行业业务深入了解的人，即会IT技能的业务专家。  </li><li><strong><em>算法工程师</em></strong><br>程序=算法+数据结构，算法是计算机的精髓。从通用的算法（排序，查找等），到AI算法（推荐、学习），算法一直阐述着计算机科学的未来发展之路。  </li><li><strong><em>硬件工程师</em></strong><br>软硬结合，传感器，物联网。从芯片，到外围电路，未来是软硬结合的世界。</li></ol><h3 id="3-个人的发展之路"><a href="#3-个人的发展之路" class="headerlink" title="3. 个人的发展之路"></a>3. 个人的发展之路</h3><ol><li>初级开发工程师  </li><li>中级开发工程师</li><li>高级开发工程师  </li><li>组长  </li><li>室经理  </li><li>部门经理</li><li>CTO  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;想想自己在计算机行业待了快9年了（本科4年，研究生3年，工作2年），对这个行业却只能说是初步了解。读书期间很抵触做网站，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>国内主流互联网公司的RPC和MOM</title>
    <link href="http://longman.kim/2018/07/12/%E5%9B%BD%E5%86%85%E4%B8%BB%E6%B5%81%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84RPC%E5%92%8CMOM/"/>
    <id>http://longman.kim/2018/07/12/国内主流互联网公司的RPC和MOM/</id>
    <published>2018-07-12T09:48:59.000Z</published>
    <updated>2018-07-23T12:14:16.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-RPC服务框架"><a href="#1-RPC服务框架" class="headerlink" title="1. RPC服务框架"></a>1. RPC服务框架</h3><ol><li><p>Dubbo(阿里)</p><blockquote><ol><li>架构<br>Provider(Container), Conumer, Registry, Monitor</li><li>通讯协议<br>2.1 dubbo的特性是连接个数单连接，连接方式长连接，传输协议TCP，传输方式NIO异步通讯，序列化Hessian二进制序列化，适用范围数据包小，消费者比提供者个数多，dubbo不适合传输大数据量的服务。<br>2.2 rmi的特性是多连接，短连接，TCP，同步传输，Java标准二进制序列化，数据包大小混合，消费者和提供者个数差不多。<br>2.3 hessian的特性是多连接，短连接，http，同步传输，hessian二进制序列化，数据包较大，提供者比消费者个数多，可传文件。<br>2.4 http的特性是多连接，短连接，http，同步传输，表单序列化，数据包大小混合，提供者比消费者个数多，不支持传文件。<br>2.5 webservice的特性是多连接，短连接，http，同步传输，SOAP文本序列化。<br>2.6 其他协议thrift、memcached、redis、rest</li><li>注册中心<br>3.1 Zookeeper,临时节点原理<br>3.2 Multicast<br>3.3 Redis<br>3.4 Simple</li><li>集群容错<br>4.1 FailOver<br>读操作的默认方式，失败自动切换，重试其他服务。<br>4.2 FailFast<br>写操作的默认方法，快速失败，只发起一次调用，失败立即报错。<br>4.3 FailBack<br>消息通知，失败自动恢复，记录失败请求，定时重发。<br>4.4 Forking<br>并行调用多个服务器，只要一个成功即可。<br>4.5 Broadcast<br>广播调用所有提供者，任意一台报错则报错。<br>4.6 Failsafe<br>失败安全，出现异常时，直接忽略，常用在写审计日志。</li><li>其他特点<br>5.1 使用微内核+插件技术，利用SPI(ServiceProviderInterface)技术+策略模式，使得Dubbo扩展性极强。<br>5.2 常用配置<br>dubbo:application, dubbo:registry, dubbo:protocol, dubbo:service, dubbo:reference  </li><li>启动流程<br>6.1 服务容器负责启动，加载，运行服务提供者。<br>6.2 服务提供者在启动时，向注册中心注册自己提供的服务。<br>6.3 服务消费者在启动时，向注册中心订阅自己所需的服务。<br>6.4 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>6.5 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者调用，如果调用失败，再选另一台。<br>6.6 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发一次统计数据到监控中心。  </li></ol></blockquote></li><li><p>HSF(阿里)</p></li><li>pigeon(美团点评)</li><li>rdsn(小米)</li><li>motan(微博)</li><li>gRPC(谷歌)</li><li>thrift(脸书)</li><li>tars(腾讯)</li><li>brpc(百度)</li><li>SpringCloud</li></ol><h3 id="2-MOM消息中间件"><a href="#2-MOM消息中间件" class="headerlink" title="2. MOM消息中间件"></a>2. MOM消息中间件</h3><ol><li><p>RocketMQ(阿里)</p><blockquote><ol><li></li></ol></blockquote></li><li><p>QService(微博)</p></li><li>Kafka</li><li><p>RabbitMQ</p><blockquote><ol><li></li></ol></blockquote></li><li><p>ActiveMQ</p></li><li>ZeroMQ</li><li>Redis</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-RPC服务框架&quot;&gt;&lt;a href=&quot;#1-RPC服务框架&quot; class=&quot;headerlink&quot; title=&quot;1. RPC服务框架&quot;&gt;&lt;/a&gt;1. RPC服务框架&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Dubbo(阿里)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站技术架构-核心原理与案例分析</title>
    <link href="http://longman.kim/2018/07/11/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://longman.kim/2018/07/11/大型网站技术架构-核心原理与案例分析/</id>
    <published>2018-07-11T12:02:57.000Z</published>
    <updated>2018-07-13T04:17:49.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-大型网站架构演进"><a href="#1-大型网站架构演进" class="headerlink" title="1. 大型网站架构演进"></a>1. 大型网站架构演进</h3><ol><li><p>大型网站软件系统的特点</p><blockquote><p>高并发，大流量，高可用，海量数据，用户分布广泛，网络情况复杂，安全环境恶劣，需求快速变更，发布频繁，渐进式发展  </p></blockquote></li><li><p>大型网站架构演化发展历程</p><blockquote><ol><li>初始阶段<br>LAMP单机</li><li>应用服务和数据服务分离  </li><li>使用缓存改善网站性能  </li><li>使用应用服务器集群改善网站的并发处理能力</li><li>数据库读写分离</li><li>使用反向代理和CDN加速网站响应  </li><li>使用分布式文件系统和分布式数据库系统</li><li>使用NoSQL和搜索引擎</li><li>业务拆分</li><li>分布式服务</li></ol></blockquote></li><li><p>大型网站架构演化的价值观</p><blockquote><ol><li>网站所需灵活应对</li><li>业务发展是驱动力</li></ol></blockquote></li><li><p>网站架构设计误区</p><blockquote><ol><li>一味追求大公司的解决方案</li><li>为了技术而技术</li><li>企图用技术解决所有问题</li></ol></blockquote></li></ol><h3 id="2-大型网站结构模式"><a href="#2-大型网站结构模式" class="headerlink" title="2. 大型网站结构模式"></a>2. 大型网站结构模式</h3><ol><li><p>网站架构模式</p><blockquote><ol><li>分层<br>应用层，服务层，数据层  </li><li>分割  </li><li>分布式<br>分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算，分布式配置，分布式锁，分布式文件系统</li><li>集群</li><li>缓存<br>CDN，反向代理，本地缓存，分布式缓存</li><li>异步<br>解耦，异步模式，生产者消费者，提高可用性，加快响应速度，消除并发访问高峰</li><li>冗余<br>冷备份，热备份，灾备数据中心</li><li>自动化<br>发布过程自动化，自动化代码管理，自动化测试，自动化安全检测，自动化部署，自动化监控，自动化报警，自动化失效转移，自动化失效恢复，自动化降级，自动化资源分配</li><li>安全<br>密码，手机校验码，加密，XSS攻击，SQL注入，信息过滤，风险控制</li></ol></blockquote></li><li><p>架构模式在新浪微博的应用</p><blockquote><ol><li>LAMP</li><li>基础服务层：数据库，缓存，存储，搜索</li><li>平台服务和应用服务</li><li>API和业务层</li><li>分布式部署，集群，异步推拉结合，多级缓存，冗余，自动化，安全</li></ol></blockquote></li></ol><h3 id="3-大型网站核心架构要素"><a href="#3-大型网站核心架构要素" class="headerlink" title="3. 大型网站核心架构要素"></a>3. 大型网站核心架构要素</h3><p>最高层次的规划，难以改变的决定</p><ol><li>性能<blockquote><ol><li>浏览器端，浏览器缓存，页面压缩，合理布局，减少cookie传输</li><li>CDN，动静分离，部署反向代理，缓存热点文件</li><li>服务端，本地缓存，分布式缓存，异步消息队列，集群，多线程，改善内存管理</li><li>数据库，索引，缓存，SQL优化，NoSQL</li><li>响应时间，TPS</li></ol></blockquote></li><li>可用性<blockquote><ol><li>7*24小时可用，4个9即99.99%可用</li><li>主要是手段是冗余</li><li>应用服务器，负载均衡，集群</li><li>存储服务器，实时备份</li></ol></blockquote></li><li>伸缩性<blockquote><ol><li>应用服务器用合适的负载均衡器向集群中加机器</li><li>缓存服务器，改进缓存路由算法，保证缓存的可访问性</li><li>关系数据库支持数据复制，主从热备等机制，但很难保证大规模的伸缩性。主要通过路由分区将多个数据库的服务器组成一个集群。NoSQL比较好扩展。</li></ol></blockquote></li><li>扩展性<blockquote><p>如何设计网站的架构使其能够快速响应需求的变化。</p><ol><li>事件驱动架构<br>消息队列</li><li>分布式服务<br>将业务和可复用服务分离，通过分布式服务框架调用。</li></ol></blockquote></li><li>安全性<blockquote><p>保护数据</p></blockquote></li></ol><h3 id="4-瞬时响应：网站的高性能架构"><a href="#4-瞬时响应：网站的高性能架构" class="headerlink" title="4. 瞬时响应：网站的高性能架构"></a>4. 瞬时响应：网站的高性能架构</h3><ol><li>网站性能测试<blockquote><ol><li>响应时间，请求开始到收到响应所需的时间</li><li>并发数，系统能够同时处理请求的数目</li><li>吞吐量，TPS（每秒事务数），QPS（每秒查询数），HPS（每秒HTTP请求数）</li><li>性能技术器<br>系统负载，对象与线程数，内存使用，CPU使用，磁盘与网络I/O</li><li>性能测试方法<br>性能测试，负载测试（直到处理能力下降），压力测试（直到系统崩溃或不能处理任何请求），稳定性测试（不同环境）</li></ol></blockquote></li><li>Web前端性能优化<blockquote><ol><li>减少http请求</li><li>使用浏览器缓存</li><li>启用压缩</li><li>css放在页面最上面，javasript放在页面最下面</li><li>减少cookie传输</li><li>CDN缓存静态资源</li><li>反向代理缓存</li></ol></blockquote></li><li>应用服务器性能优化<blockquote><ol><li>分布式缓存<br>Hash表，读多写少，二八定律</li><li>合理使用缓存<br>频繁修改的数据不适合缓存，非热点数据不适合缓存，可能存在数据不一致和脏读，缓存的可用性，缓存利用LRU(最近最久未用算法)，缓存预热，缓存穿透</li><li>分布式缓存架构<br>更新同步的缓存（与应用部署在一起），互不通信的缓存（与应用部署在不同的服务器，采用Hash一致性算法可伸缩）。Memcached采用TCP通信，序列化协议基于文本的自定义，网络通信基于libevent，内存管理使用固定空间分配，存储时根据数据的size寻找一个大于size的最小的chunk，互不通信的服务器集群架构。</li><li>异步操作<br>使用消息队列</li><li>使用集群<br>负载均衡</li><li>代码优化<br>多线程，线程安全（将对象设计为无状态对象，使用局部对象，并发访问资源时使用锁），资源复用（单例模式，线程池），数据结构，垃圾回收</li></ol></blockquote></li><li>存储性能优化<blockquote><ol><li>机械硬盘和固态硬盘</li><li>B+树和LSM树</li><li>RAID（廉价磁盘冗余阵列）和HDFS（MapReduce）</li></ol></blockquote></li></ol><h3 id="5-网站的高可用架构"><a href="#5-网站的高可用架构" class="headerlink" title="5. 网站的高可用架构"></a>5. 网站的高可用架构</h3><ol><li>网站可用性的度量与考核<blockquote><p>网站不可用时间，网站年度可用性指标（多少个9）</p></blockquote></li><li>高可用的网站架构<blockquote><p>保证服务器硬件故障时服务依然可用、数据依然保存并能够被访问，手段主要是数据和服务的冗余备份及失效转移。应用层使用负载均衡应对高并发，心跳机制将问题服务器从集群中剔除。服务层使用RPC框架，在客户端使用软负载均衡，服务注册中心剔除不可用服务器。数据层需要写入数据时同步复制，实现数据冗余。</p></blockquote></li><li>高可用的应用<blockquote><ol><li>无状态应用</li><li>使用负载均衡进行失效转移</li><li>session管理的发展，seesion复制-&gt;session绑定(hash)-&gt;利用cookie记录session-&gt;session服务器</li></ol></blockquote></li><li>高可用的服务<blockquote><ol><li>服务器分级管理，物理机&gt;虚拟机，线程隔离</li><li>超时设置</li><li>异步调用</li><li>服务降级，拒绝服务，关闭功能</li><li>幂等设计</li></ol></blockquote></li><li>高可用的数据<blockquote><ol><li>数据多备份，实现持久化，并在失效时，快速切换访问数据的副本。</li><li>整个网站共享同一个分布式缓存集群</li><li>CAP原理，优先保证AP，数据一致性保证最终一致性</li><li>数据冷备采用定期备份，不能保证最终一致性，不能保证数据可用性。数据热备分为异步热备（成功写一份，异步写其他副本）和同步热备（多份数据副本同步写入）。关系数据库热备使用master，slave同步机制。读写分离，只写master，只读slave。</li><li>失效转移（将宕机服务器的读写请求路由到其他服务器）。失效确认，应用程序访问失败报告和控制中心的心跳检测。访问转移，重新路由，需要考虑存储不对等的情况。数据恢复，数据复制。</li></ol></blockquote></li><li>高可用网站的软件质量保证<blockquote><ol><li>网站发布<br>发布过程中，每次关闭集群中的一小部分服务器，发布完后可以立即访问，不影响用户</li><li>自动化测试<br>自动化测试工具Selenium</li><li>预发布验证<br>预发布服务器没有配置在负载均衡器上，只运行开发和测试访问。处理错误的一个理念是快速失败。</li><li>代码控制<br>分支开发，主干发布</li><li>自动化发布<br>固定发布日期</li><li>灰度发布<br>每天发布一部分服务器</li></ol></blockquote></li><li>网站运行监控<blockquote><p>不允许没有监控的服务上下</p><ol><li>监控数据采集<br>服务器端日志收集，客户端浏览器日志收集，实时计算框架storm的日志统计与分析，服务器性能监控（系统load、内存占用、磁盘IO、网络IO）Ganglia，运行数据报告（缓存命中率、平均响应延迟时间、待处理任务总数）</li><li>监控管理<br>系统报警，失效转移，自动优雅降级</li></ol></blockquote></li></ol><h3 id="6-永无止境：网站的伸缩性架构"><a href="#6-永无止境：网站的伸缩性架构" class="headerlink" title="6. 永无止境：网站的伸缩性架构"></a>6. 永无止境：网站的伸缩性架构</h3><ol><li><p>网站架构的伸缩性设计</p><blockquote><ol><li>不同功能进行物理分隔实现伸缩<br>纵向分离（分层后分离），横向分离（业务分隔后分离）</li><li>单一功能通过集群规模实现伸缩</li></ol></blockquote></li><li><p>应用服务器集群的伸缩性设计</p><blockquote><ol><li>HTTP重定向负载均衡，返回浏览器302</li><li>DNS域名解析负载均衡，一个域名多个IP</li><li>反向代理负载均衡，应用层（HTTP）负载均衡</li><li>IP负载均衡，修改目的地址的IP</li><li>数据链路层负载均衡，直接路由方式（DR），不修改IP修改MAC，LVS工作在这层</li><li>负载均衡算法<br>轮训（Round Robin, RR），加权轮训（Weighted Round Robin, WRR），随机，最少连接，源地址散列（hash）</li></ol></blockquote></li><li>分布式缓存集群的伸缩性设计<blockquote><p>新加入缓存服务器后使整个缓存服务器集群中已经缓存的数据尽可能还被访问到。</p><ol><li>Memcached分布式缓存集群的访问机制</li><li>分布式缓存的一致性Hash算法，虚拟节点</li></ol></blockquote></li><li>数据存储服务器集群的伸缩性设计<blockquote><ol><li>关系数据库集群的伸缩性设计<br>数据分库，跨库的表不能进行Join操作。进行了分库和主从复制后，单表数据仍很大，需要将一张表拆开分别存储在多个数据库中，即分片。支持数据分片的分布式数据库产品主要有Amoeba和Cobar。Cobar做负载均衡，MySQL做数据迁移。避免事务或者利用补偿机制代替数据库事务，分解数据访问逻辑避免JOIN操作。</li><li>NoSQL数据库的伸缩性设计<br>HBase的架构，HBase依赖可分裂的HRegion以及可伸缩的分布式文件系统HDFS。Zookeeper，HMaster，HRegionServer，HRegion。</li></ol></blockquote></li></ol><h3 id="7-随需应变：网站的可扩展架构"><a href="#7-随需应变：网站的可扩展架构" class="headerlink" title="7. 随需应变：网站的可扩展架构"></a>7. 随需应变：网站的可扩展架构</h3><ol><li>构建可扩展的网站架构<blockquote><p>扩展性（开闭原则，对扩展开放，对修改关闭），伸缩性（增加资源规模提高系统处理能力），模块化，降低模块之间的耦合</p></blockquote></li><li>利用分布式消息队列降低系统耦合性<blockquote><ol><li>事件驱动架构<br>生成者消费者模式就是常见的事件驱动模式，分布式消息队列。</li><li>分布式消息队列<br>FIFO，通过消息对象分解系统耦合性</li></ol></blockquote></li><li>利用分布式服务打造可复用的业务平台<blockquote><p>通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用</p><ol><li>WebService与企业级分布式服务</li><li>大型网站分布式服务的需求与特点<br>负载均衡，失效转移，高效的远程通信，整合异构系统，对应用最少侵入，版本管理，实时监控</li><li>分布式服务框架设计<br>Dubbo，服务框架客户端，服务注册中心，负载均衡策略，服务提供者</li></ol></blockquote></li><li>可扩展的数据结构<blockquote><p>关系数据库的schema，NoSQL的ColumnFamily</p></blockquote></li><li>利用开放平台建设网站生态圈<blockquote><ol><li>API接口</li><li>协议转换</li><li>安全</li><li>审计</li><li>路由</li><li>流程</li></ol></blockquote></li></ol><h3 id="8-固若金汤：网站的安全架构"><a href="#8-固若金汤：网站的安全架构" class="headerlink" title="8. 固若金汤：网站的安全架构"></a>8. 固若金汤：网站的安全架构</h3><ol><li>网站应用攻击与防御<blockquote><ol><li>XSS攻击<br>反射型，嵌入恶意脚本的链接，持久型，黑客提交恶意脚本到正常页面。防护手段有消毒，即对危险字符进行转义。HttpOnly，禁止访问cookie。</li><li>注入攻击<br>SLQ注入攻击，在请求中注入恶意SQL命令。黑客获取数据库结构的手段，开源，错误回显，盲注。防护手段有消毒，正则匹配过滤SQL。参数绑定，预编译。</li><li>CSRF攻击<br>通过跨站请求，以合法身份进行非法操作，其核心是利用了浏览器的cookie或者服务器的session策略，盗用用户身份。防御手段有表单token，验证码，referer check。</li><li>其他攻击和漏洞<br>error code，HTML注释，文件上传，路径遍历</li><li>Web应用防火墙<br>ModSecurity</li><li>网站安全漏洞扫描</li></ol></blockquote></li><li>信息加密技术及密钥安全管理<blockquote><ol><li>单向散列加密<br>密码保存与验证，加盐salt增加破解难度，MD5，SHA</li><li>对称加密<br>DES算法，RC算法</li><li>非对称加密算法<br>RSA算法，HTTPS里面的数字证书</li><li>密钥安全管理<br>密钥和算法放在独立的服务器上甚至做出专用硬件，加解密算法放在应用中，密钥放在独立的服务器中，密钥分片存储</li></ol></blockquote></li><li>信息过滤与反垃圾<blockquote><ol><li>文本匹配<br>正则匹配，Tri树，多级Hash表</li><li>分类算法<br>朴素贝叶斯分类，聚类挖掘</li><li>黑名单</li></ol></blockquote></li><li>电子商务风险控制<blockquote><ol><li>风险<br>账户风险，买家风险，卖家风险，交易风险</li><li>风控<br>规则引擎，统计模型</li></ol></blockquote></li></ol><h3 id="9-淘宝网的架构演化案例分析"><a href="#9-淘宝网的架构演化案例分析" class="headerlink" title="9. 淘宝网的架构演化案例分析"></a>9. 淘宝网的架构演化案例分析</h3><h3 id="10-维基百科的高性能架构设计分析"><a href="#10-维基百科的高性能架构设计分析" class="headerlink" title="10. 维基百科的高性能架构设计分析"></a>10. 维基百科的高性能架构设计分析</h3><h3 id="11-海量分布式存储系统Doris的高可用架构设计分析"><a href="#11-海量分布式存储系统Doris的高可用架构设计分析" class="headerlink" title="11. 海量分布式存储系统Doris的高可用架构设计分析"></a>11. 海量分布式存储系统Doris的高可用架构设计分析</h3><h3 id="12-网购秒杀系统架构设计案例分析"><a href="#12-网购秒杀系统架构设计案例分析" class="headerlink" title="12. 网购秒杀系统架构设计案例分析"></a>12. 网购秒杀系统架构设计案例分析</h3><h3 id="13-大型网站典型故障案例分析"><a href="#13-大型网站典型故障案例分析" class="headerlink" title="13. 大型网站典型故障案例分析"></a>13. 大型网站典型故障案例分析</h3><h3 id="14-架构师领导艺术"><a href="#14-架构师领导艺术" class="headerlink" title="14. 架构师领导艺术"></a>14. 架构师领导艺术</h3><h3 id="15-网站架构师职场攻略"><a href="#15-网站架构师职场攻略" class="headerlink" title="15. 网站架构师职场攻略"></a>15. 网站架构师职场攻略</h3><h3 id="16-漫话网站架构师"><a href="#16-漫话网站架构师" class="headerlink" title="16. 漫话网站架构师"></a>16. 漫话网站架构师</h3><h3 id="附录A-大型网站架构技术一览"><a href="#附录A-大型网站架构技术一览" class="headerlink" title="附录A 大型网站架构技术一览"></a>附录A 大型网站架构技术一览</h3><h3 id="附录B-Web开发技术发展历程"><a href="#附录B-Web开发技术发展历程" class="headerlink" title="附录B Web开发技术发展历程"></a>附录B Web开发技术发展历程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-大型网站架构演进&quot;&gt;&lt;a href=&quot;#1-大型网站架构演进&quot; class=&quot;headerlink&quot; title=&quot;1. 大型网站架构演进&quot;&gt;&lt;/a&gt;1. 大型网站架构演进&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;大型网站软件系统的特点&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七周七并发模型</title>
    <link href="http://longman.kim/2018/07/09/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://longman.kim/2018/07/09/七周七并发模型/</id>
    <published>2018-07-08T17:24:59.000Z</published>
    <updated>2018-07-08T17:24:59.670Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七周七数据库</title>
    <link href="http://longman.kim/2018/07/09/%E4%B8%83%E5%91%A8%E4%B8%83%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://longman.kim/2018/07/09/七周七数据库/</id>
    <published>2018-07-08T17:23:10.000Z</published>
    <updated>2018-07-08T17:24:21.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-PostgreSQL"><a href="#1-PostgreSQL" class="headerlink" title="1. PostgreSQL"></a>1. PostgreSQL</h3><h3 id="2-Riak"><a href="#2-Riak" class="headerlink" title="2. Riak"></a>2. Riak</h3><h3 id="3-Hbase"><a href="#3-Hbase" class="headerlink" title="3. Hbase"></a>3. Hbase</h3><h3 id="4-mongodb"><a href="#4-mongodb" class="headerlink" title="4. mongodb"></a>4. mongodb</h3><h3 id="5-CouchDB"><a href="#5-CouchDB" class="headerlink" title="5. CouchDB"></a>5. CouchDB</h3><h3 id="6-Neo4j"><a href="#6-Neo4j" class="headerlink" title="6. Neo4j"></a>6. Neo4j</h3><h3 id="7-Redis"><a href="#7-Redis" class="headerlink" title="7. Redis"></a>7. Redis</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-PostgreSQL&quot;&gt;&lt;a href=&quot;#1-PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;1. PostgreSQL&quot;&gt;&lt;/a&gt;1. PostgreSQL&lt;/h3&gt;&lt;h3 id=&quot;2-Riak&quot;&gt;&lt;a href=&quot;#2-Ria
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AWS认证考试（云技术架构师）</title>
    <link href="http://longman.kim/2018/07/09/AWS%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%EF%BC%88%E4%BA%91%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%B8%88%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/09/AWS认证考试（云技术架构师）/</id>
    <published>2018-07-08T17:03:18.000Z</published>
    <updated>2018-07-08T17:03:18.590Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://longman.kim/2018/07/08/Zookeeper/"/>
    <id>http://longman.kim/2018/07/08/Zookeeper/</id>
    <published>2018-07-08T13:55:34.000Z</published>
    <updated>2018-07-11T11:15:39.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Zookeeper是什么？"><a href="#1-Zookeeper是什么？" class="headerlink" title="1. Zookeeper是什么？"></a>1. Zookeeper是什么？</h3><p>Zookeeper是一个分布式的分布式应用程序协调服务，它为分布式应用提供一致性服务，功能包括：配置维护、域名服务、分布式同步、组服务等，提供的接口主要有分布式独享锁、选举、队列。</p><h3 id="2-Zookeeper的架构与组成"><a href="#2-Zookeeper的架构与组成" class="headerlink" title="2. Zookeeper的架构与组成"></a>2. Zookeeper的架构与组成</h3><ol><li>类似于文件系统，多叉树的结构，每个节点znode的大小&lt;1M。Zookeeper服务由多个互相通信的Server构成，其中有一个Server是leader。当leader挂了之后，会重新选择一个新的leader。</li><li>普通的Server能处理read和watch请求，只有leader能处理write请求。因此，当普通Server收到write请求时，它会将请求重定向到leader。Client配置所有Server的列表，但只会选择其中的一个Server进行连接。</li><li>当Client连接的Server挂了之后，Client会重新选择一个Server，建立新的会话。</li><li>update操作必须严格有序执行，对每一个操作都有对应的交易ID。</li><li>Zookeeper中的数据保存在内存，写操作先写磁盘再写内存，更新操作先写更新记录到磁盘再更新内存。</li><li>读写比是10:1时，zookeeper表现最好。  </li><li>zookeeper中不使用相对路径。</li><li>znode中有修改的版本号，ACL的版本号，时间戳等。修改znode时，要对版本号进行核对。</li><li>Zookeeper中ACL控制不是递归的，能访问父节点不一定能访问子节点。<h3 id="3-Fast-Paxos算法，ZAB算法"><a href="#3-Fast-Paxos算法，ZAB算法" class="headerlink" title="3. Fast Paxos算法，ZAB算法"></a>3. Fast Paxos算法，ZAB算法</h3></li><li><strong><em>数据修改</em></strong><br>ZAB(Zookeeper Atomic Broadcast)原子广播协议，是2PC(两阶段提交)协议的变体。<br>1.1  follower收到write请求后，将请求重定向到leader。<br>1.2  leader将write请求（携带序列号64位，前32位SID（服务器的唯一标识）和后32位ZXID（事务ID））广播给follower。<br>1.3  follower将write请求放在history队列里面，然后回复ACK给leader。<br>1.4  leader收到一半的ACK后，广播commit给follower。<br>1.5  follower收到commit请求后，如果发现这个交易的序列号在history队列里面是最小的，就执行该请求。如果发现这个交易的序列号不是最小的，需要等待小的序列号执行commmit后，才执行这个大序列号的交易。</li><li><strong><em>leader挂了后的选举</em></strong><br>服务器如果无法和leader连接时进入leader选举状态，称为looking状态。looking状态的机器会向集群中所有的机器发起投票。投票包含该服务器最近的序列号(sid, zxid)和选举轮次。最开始都投自己，然后比较接收到的序列号（先比较zxid，再比较sid），投给最大序列号对应的服务器，两轮就能确定。</li><li><strong><em>初始化数据恢复</em></strong><br>确保那些在leader服务器上提交的事务最终被执行，丢弃那些只在leader服务器被提出的事务。选择leader完成后，followers发送自己接收的最大zxid的epoch给leader。leader从接收到的epoch中，选择最大的并加1，发送给follower。follower接收到epoch之后，更新自己的epoch。然后将自己的history历史事务集反馈给leader。leader在收到过半的反馈后，从收到的反馈中选择epoch最大，同时zxid最大的follower的事务集合作为初始化事务集合。leader将初始化集合发给follower，follower接收并处理事务集，反馈给leader，leader收到反馈后发送commit。</li><li><strong><em>client挂了后的处理</em></strong><br>zookeeper允许client创建两种类型的节点：persistent, ephemeral，ephemeral类型的节点与client一起共存亡。客户端与follower连接时，会创建一个session, follower和leader都保存了session信息。client定期向follower发送ping包，证明自己活着。leader定期向follower发送ping包，检查是否有超过一半的follower还活着，同时follower会返回session，告诉leader哪些client还活着，这样leader就可以删除不错在客户端的ephemeral节点，ephemeral不允许有children。</li></ol><h3 id="4-动物园管理员（Zookeeper）的故事"><a href="#4-动物园管理员（Zookeeper）的故事" class="headerlink" title="4. 动物园管理员（Zookeeper）的故事"></a>4. 动物园管理员（Zookeeper）的故事</h3><h3 id="5-优点与缺点"><a href="#5-优点与缺点" class="headerlink" title="5. 优点与缺点"></a>5. 优点与缺点</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Zookeeper是什么？&quot;&gt;&lt;a href=&quot;#1-Zookeeper是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Zookeeper是什么？&quot;&gt;&lt;/a&gt;1. Zookeeper是什么？&lt;/h3&gt;&lt;p&gt;Zookeeper是一个分布式的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://longman.kim/2018/07/08/Kafka/"/>
    <id>http://longman.kim/2018/07/08/Kafka/</id>
    <published>2018-07-08T13:32:30.000Z</published>
    <updated>2018-07-13T16:21:42.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Kalfka？"><a href="#1-什么是Kalfka？" class="headerlink" title="1. 什么是Kalfka？"></a>1. 什么是Kalfka？</h3><p>由Scala和Java编写，开源流处理平台，高吞吐量的分布式发布订阅消息系统。</p><h3 id="2-Kalka的各种组件"><a href="#2-Kalka的各种组件" class="headerlink" title="2. Kalka的各种组件"></a>2. Kalka的各种组件</h3><p>Broker，Kafka集群中包含的服务器。<br>Topic,每条发布到Kafka集群中的消息都有一个类别即Topic。不同Topic物理上分开存储，逻辑上一个Topic的消息虽然保存于一个或多个Broker上，但用户只需要指定消息的Topic即可生产或消费。<br>Partition，物理上每个Topic包含一个或多个Partition。<br>Producer，发布消息到Kafka的broker。<br>Consumer，向Kafka读取消息的客户端。<br>Consumer Group，每个Consumer属于一个特定的Consumer Group。<br>Offset，kafka的存储文件按照offset.kafka来命名，方便查找。例如1025的位置只要找到1024.kafka的文件即可，第一个文件是0000000.kafka。</p><h3 id="3-offset的角色"><a href="#3-offset的角色" class="headerlink" title="3. offset的角色"></a>3. offset的角色</h3><h3 id="4-consumer-group是什么"><a href="#4-consumer-group是什么" class="headerlink" title="4. consumer group是什么"></a>4. consumer group是什么</h3><h3 id="5-Zookeeper的角色"><a href="#5-Zookeeper的角色" class="headerlink" title="5. Zookeeper的角色"></a>5. Zookeeper的角色</h3><p>通过Zookeeper来协调broker，例如broker的新增或者失效，Zookeeper将通知生成者和消费者</p><h3 id="6-Kalka可以不使用Zookeeper吗"><a href="#6-Kalka可以不使用Zookeeper吗" class="headerlink" title="6. Kalka可以不使用Zookeeper吗"></a>6. Kalka可以不使用Zookeeper吗</h3><h3 id="7-leader和follower的概念"><a href="#7-leader和follower的概念" class="headerlink" title="7. leader和follower的概念"></a>7. leader和follower的概念</h3><h3 id="8-复制和ISR的角色"><a href="#8-复制和ISR的角色" class="headerlink" title="8. 复制和ISR的角色"></a>8. 复制和ISR的角色</h3><h3 id="9-复制在Kafka中的重要性"><a href="#9-复制在Kafka中的重要性" class="headerlink" title="9. 复制在Kafka中的重要性"></a>9. 复制在Kafka中的重要性</h3><h3 id="10-Kafka启动流程"><a href="#10-Kafka启动流程" class="headerlink" title="10. Kafka启动流程"></a>10. Kafka启动流程</h3><h3 id="11-如何定义一个Partitioning-key"><a href="#11-如何定义一个Partitioning-key" class="headerlink" title="11. 如何定义一个Partitioning key?"></a>11. 如何定义一个Partitioning key?</h3><h3 id="12-生产者的队列什么时候会变满了？"><a href="#12-生产者的队列什么时候会变满了？" class="headerlink" title="12. 生产者的队列什么时候会变满了？"></a>12. 生产者的队列什么时候会变满了？</h3><h3 id="13-介绍下Kafka中Production的API"><a href="#13-介绍下Kafka中Production的API" class="headerlink" title="13. 介绍下Kafka中Production的API"></a>13. 介绍下Kafka中Production的API</h3><h3 id="14-介绍下Kafka中Consumer的API"><a href="#14-介绍下Kafka中Consumer的API" class="headerlink" title="14. 介绍下Kafka中Consumer的API"></a>14. 介绍下Kafka中Consumer的API</h3><h3 id="15-介绍下Kafka中Stream的API"><a href="#15-介绍下Kafka中Stream的API" class="headerlink" title="15. 介绍下Kafka中Stream的API"></a>15. 介绍下Kafka中Stream的API</h3><h3 id="16-介绍下Kafka中Connector的API"><a href="#16-介绍下Kafka中Connector的API" class="headerlink" title="16. 介绍下Kafka中Connector的API"></a>16. 介绍下Kafka中Connector的API</h3><h3 id="17-Kafka和Flume的区别"><a href="#17-Kafka和Flume的区别" class="headerlink" title="17. Kafka和Flume的区别"></a>17. Kafka和Flume的区别</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是Kalfka？&quot;&gt;&lt;a href=&quot;#1-什么是Kalfka？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Kalfka？&quot;&gt;&lt;/a&gt;1. 什么是Kalfka？&lt;/h3&gt;&lt;p&gt;由Scala和Java编写，开源流处理平台，高吞吐量的分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员国外面试流程（同事口述）</title>
    <link href="http://longman.kim/2018/07/06/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9B%BD%E5%A4%96%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B%EF%BC%88%E5%90%8C%E4%BA%8B%E5%8F%A3%E8%BF%B0%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/06/程序员国外面试流程（同事口述）/</id>
    <published>2018-07-06T12:54:55.000Z</published>
    <updated>2018-07-06T13:06:06.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-面试准备"><a href="#1-面试准备" class="headerlink" title="1. 面试准备"></a>1. 面试准备</h3><ol><li><p>英语<br>口语，可以找网上一对一的私教</p></li><li><p>算法<br>ACM类型的算法题目，刷leetcode，打比赛</p></li><li><p>项目  </p></li></ol><ol start="4"><li><p>面向对象设计，设计模式<br>面向对象的思想，设计模式</p></li><li><p>架构<br>AWS的一些架构</p></li></ol><h3 id="2-面试流程"><a href="#2-面试流程" class="headerlink" title="2. 面试流程"></a>2. 面试流程</h3><ol><li>在线做题（一个小时左右网上完成一份试卷）  </li><li>三轮电面（2轮在线编程，1轮项目介绍）  </li><li>一天之内6轮现场面试（白板手写算法，面向对象设计，架构）</li></ol><h3 id="3-机会"><a href="#3-机会" class="headerlink" title="3. 机会"></a>3. 机会</h3><p>使用linkedin，吸引国外公司的HR，多加群</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-面试准备&quot;&gt;&lt;a href=&quot;#1-面试准备&quot; class=&quot;headerlink&quot; title=&quot;1. 面试准备&quot;&gt;&lt;/a&gt;1. 面试准备&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;英语&lt;br&gt;口语，可以找网上一对一的私教&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;算法&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180705</title>
    <link href="http://longman.kim/2018/07/04/%E5%89%A7%E6%9C%AC20180705/"/>
    <id>http://longman.kim/2018/07/04/剧本20180705/</id>
    <published>2018-07-04T14:11:05.000Z</published>
    <updated>2018-07-04T14:11:05.147Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站系统与Java中间件实践</title>
    <link href="http://longman.kim/2018/07/03/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8EJava%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5/"/>
    <id>http://longman.kim/2018/07/03/大型网站系统与Java中间件实践/</id>
    <published>2018-07-03T15:06:54.000Z</published>
    <updated>2018-07-04T14:10:27.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式系统介绍"><a href="#1-分布式系统介绍" class="headerlink" title="1. 分布式系统介绍"></a>1. 分布式系统介绍</h3><p>1.1 分布式中的控制器</p><blockquote><p>请求调用的负载均衡（硬件F5，软件LVS），也称为透明代理，服务请求方和提供方直接多了层代理。名称服务，收集服务提供方的地址信息，把这些信息提供给服务调用方，负载均衡由服务调用方做。规则服务器，不和服务提供方交互，只向调用方提供调用服务的规则。Master+Worker的方式，任务的分配和管理。</p></blockquote><p>1.2 分布式的运算器</p><blockquote><p>DNS服务器进行调度和控制，将域名解析到不同的网站服务器；DNS返回负载均衡器的地址，负载均衡器将请求分发到不同的网站服务器；采用Master控制日志处理器集群的方式，或者规则服务器协调日志处理服务器的动作。</p></blockquote><p>1.3 分布式的存储器</p><blockquote><p>单个KV存储服务器；使用代理（根据K值进行划分）的多个KV存储服务器；采用名称服务的多个KV存储服务器，一种是规则服务器配合完成固定划分的策略，一种是对等看待多台KV存储服务器，灵活的适应KV存储服务器的增加和减少（一致性哈希）；规则服务器返回如何对数据进行划分，以及具体包含KV存储服务器的地址。Master对每个请求，直接返回一个KV服务器对应的地址。</p></blockquote><p>1.4 缺乏全局时钟，采用集群进行处理</p><p>1.5 面对故障独立性，一部分有问题其他部分能正常工作</p><p>1.6 单点故障</p><blockquote><p>最直接的是将功能从单机实现变为集群；一种方法是备份，自动恢复；一种是降低单点的影响范围，例如对数据库做划分</p></blockquote><p>1.7 分布式事务的挑战</p><blockquote><p>2PC, 3PC, BASE, CAP, PAXOS</p></blockquote><h3 id="2-大型网站及其架构演进过程"><a href="#2-大型网站及其架构演进过程" class="headerlink" title="2. 大型网站及其架构演进过程"></a>2. 大型网站及其架构演进过程</h3><p>2.1 大型网站：大访问量，海量数据</p><p>2.2 架构演进</p><blockquote><p>2.2.1 单机<br>2.2.2 数据库与应用分离<br>2.2.3 应用服务器走向集群</p><blockquote><p>2.2.3.1 引入负载均衡<br>2.2.3.2 session问题（session sticky即同一个用户的所有请求被负载均衡到同一台机器，session replication所有机器都保存所有的seesion涉及session同步，session集中存储，基于cookie） </p></blockquote></blockquote><blockquote><p>2.2.4 数据库读写分离</p><blockquote><p>2.2.4.1 数据复制需要考虑数据复制时延问题，MySQL支持Master和Slave模式，异步复制，半同步服务<br>2.2.4.2 如何选择数据源<br>2.2.4.3 搜索引擎是一个读库，索引集群构建方式，全量/增量，实时/非实时<br>2.2.4.4 数据缓存，页面缓存，缓存命中率，缓存的失效，更新  </p></blockquote></blockquote><blockquote><p>2.2.5 分布式存储系统</p><blockquote><p>分布式文件系统（大小文件的存储），分布式Key-Value系统（半结构数据支持），分布式数据库系统，提供高容量，高并发访问，数据冗余容灾的支持</p></blockquote></blockquote><blockquote><p>2.2.6 读写分离后，数据库又遇到瓶颈</p><blockquote><p>2.2.6.1 专库专用，垂直拆分，将不同的表分到不同的数据库。要处理单机跨业务的事务，可以采用分布式事务。<br>2.2.6.2 水平拆分，将同一个表的数据分到不同的数据库。要解决SQL路由的问题，以及分页。</p></blockquote></blockquote><blockquote><p>2.2.7 数据库问题解决后，应用面对的新挑战</p><blockquote><p>应用拆分的方式：根据业务特性<br>走服务化的路</p></blockquote></blockquote><blockquote><p>2.2.8 消息中间件</p><blockquote><p>在分布式系统中完成消息的发送和接受，实现异步和解耦 </p></blockquote></blockquote><h3 id="3-构建Java中间件"><a href="#3-构建Java中间件" class="headerlink" title="3. 构建Java中间件"></a>3. 构建Java中间件</h3><blockquote><p>3.1 JVM, 垃圾回收与内存堆布局，并发编程（线程池，同步，锁，线程通信，异步，并发容器）<br>3.2 动态代理<br>3.3 反射<br>3.4 Java中间件，消息中间件（MOM），服务框架（RPC），软负载中心，持久配置管理，分布式数据层，数据复制/迁移</p></blockquote><h3 id="4-服务框架"><a href="#4-服务框架" class="headerlink" title="4. 服务框架"></a>4. 服务框架</h3><blockquote><p>dubbo, grpc, thrift, motan, rmi, hessian, webservice<br>rmi, rpc, soap, rest  </p></blockquote><p>4.1 服务框架的设计与实现</p><blockquote><ol><li>服务框架需要解决的问题：接口调用-&gt;寻址路由-&gt;编码-&gt;通信-&gt;解码-&gt;实例定位-&gt;服务调用</li><li>远程服务的客户端调用：获取可用服务地址列表-&gt;确定要调用服务的目标机器-&gt;建立链接-&gt;请求序列化-&gt;发送请求-&gt;接收结果-&gt;解析结果  </li><li>服务调用端具体工作：调用发起-&gt;寻址路由-&gt;协议适配/序列化-&gt;网络传输-&gt;反序列化/协议解析-&gt;得到结果返回给调用方  </li><li>配置服务：interfaceName, version, group</li><li>服务调用者与服务提供者直连（服务注册查找中心），基于接口、方法、参数的路由，多机房场景</li><li>网络通信的实现BIO，NIO（IO线程，数据队列，通信对象队列，定时任务），AIO</li><li>多种异步调用方式：Oneway方式，Callback方式，Future方式</li><li>服务提供端具体工作：反序列化/协议解析-&gt;定位服务-&gt;执行方法生成方法-&gt;协议适配/序列化-&gt;网络传输  </li><li>不同服务的线程池隔离，0-1开关，QPS的流控处理，服务升级</li></ol></blockquote><p>4.2 实战中的优化</p><blockquote><p>服务的拆分，服务的粒度，服务缓存，分布式环境中的请求合并</p></blockquote><p>4.3 服务治理</p><blockquote><ol><li><p>管理服务</p><blockquote><ol><li>服务上下线  </li><li>服务路由</li><li>服务限流降级</li><li>服务归组</li><li>服务线程池管理</li><li>机房规则</li><li>服务授权 </li></ol></blockquote></li><li><p>查看服务</p><blockquote><ol><li>服务信息（服务编码）</li><li>服务质量（出错率、响应时间）</li><li>服务容量（能支持的请求量）</li><li>服务依赖（服务之前的依赖关系）</li><li>服务分布（跨机房的分布）</li><li>服务统计（调用次数，出错次数，出错率，响应时间的排名和趋势）</li><li>服务元数据（服务方法和参数）</li><li>服务查询（名称，负责人，发布时间，服务提供者地址列表，质量，容量，依赖，组，版本）</li><li>服务报表（非实时的统计报表）</li><li>服务监视（服务运行时数据的收集和处理）</li></ol></blockquote></li></ol></blockquote><h3 id="5-数据访问层"><a href="#5-数据访问层" class="headerlink" title="5. 数据访问层"></a>5. 数据访问层</h3><ol><li>分布式事务<blockquote><ol><li>2PC  </li></ol></blockquote></li><li>3PC  </li><li>PAXOS   </li><li><p>CAP, BASE </p></li><li><p>Join</p><blockquote><ol><li>把Join操作分成多次的数据库操作</li><li>通过信息冗余变成单表查询</li><li>外部系统（例如搜索引擎）解决</li></ol></blockquote></li><li><p>外键</p></li><li><p>自增序列</p><blockquote><ol><li>UUID的生成方式</li><li></li></ol></blockquote></li><li><p>查询跨库</p></li><li><p>确定执行SQL的目标库</p><blockquote><ol><li>固定哈希算法  </li><li>一致性哈希算法</li></ol></blockquote></li></ol><h3 id="6-消息中间件"><a href="#6-消息中间件" class="headerlink" title="6. 消息中间件"></a>6. 消息中间件</h3><h3 id="7-软负载中心与集中配置管理"><a href="#7-软负载中心与集中配置管理" class="headerlink" title="7. 软负载中心与集中配置管理"></a>7. 软负载中心与集中配置管理</h3><h3 id="8-构建大型网站的其他要素"><a href="#8-构建大型网站的其他要素" class="headerlink" title="8. 构建大型网站的其他要素"></a>8. 构建大型网站的其他要素</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式系统介绍&quot;&gt;&lt;a href=&quot;#1-分布式系统介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式系统介绍&quot;&gt;&lt;/a&gt;1. 分布式系统介绍&lt;/h3&gt;&lt;p&gt;1.1 分布式中的控制器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请求调用的负载
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180703</title>
    <link href="http://longman.kim/2018/07/03/%E5%89%A7%E6%9C%AC20180703/"/>
    <id>http://longman.kim/2018/07/03/剧本20180703/</id>
    <published>2018-07-03T11:20:51.000Z</published>
    <updated>2018-07-04T11:40:16.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-如何体现技术能力？"><a href="#1-如何体现技术能力？" class="headerlink" title="1. 如何体现技术能力？"></a>1. 如何体现技术能力？</h3><blockquote><p>今天看了刘未鹏的文章《怎样花两年时间去面试一个人》，总的感触就是识别一个优秀技术候选人是非常困难的。在学校与教育严重脱节的情况下，技术人员的甄别可以通过以下方法：  </p><ol><li>学历  </li><li>读过的书  </li><li>博客  </li><li>github的提交频率，别人的点赞  </li><li>算法<br>学历方面我在国内已经读了硕士，如果要提升的话，我理解进步的空间应该是去国外的top大学读个博士。如果想往这方面发展，英语是个大关卡。在读的书方面，工作之后读书少了，而且也没有完全理解。因此，我得给自己列个书单。<br><strong>基础书单</strong><br>《深入理解计算机系统》<br>《代码大全》<br>《编程珠玑》/《编程之美》<br>《计算机程序的构造和解释》<br>《设计模式》<br>《重构》<br>《程序员修理之道》<br>《深入理解Linux内核》<br>《TCP/IP详解》<br>《鸟哥的Linux私房菜-基础学习篇》<br>《软件随想录》<br>《黑客与画家》<br>《重来》<br>《编程人生》<br>《UNIX编程艺术》<br>《算法导论》<br>《盛田昭夫》<br>《杰克韦尔奇自传》<br><strong>语言</strong><br>《Effective C++》<br>《深度探索C++对象模型》<br>《C专家编程》<br>《Lua程序设计》<br>《Java编程思想》<br>《深入理解Java虚拟机》<br>《Effective Java》<br>《Java并发编程实战》<br>《Java并发编程的艺术》<br>《Java性能优化权威指南》<br><strong>前端</strong><br>《JavaScript高级程序设计》<br>《JavaScript权威指南》<br>《锋利的jQuery》<br><strong>架构</strong><br>《大型网站系统与Java中间件实践》<br>《大型网站技术架构:核心原理与案例分析》<br>《大型分布式网站架构设计与实践》<br>《大规模分布式存储系统》<br>《深入分析Java Web技术内幕》<br>《Redis设计与实现》<br>《MySQL技术内幕 : InnoDB存储引擎》<br>《微服务设计》<br>《从Paxos到Zookeeper》<br>《Netty权威指南 第2版》<br>《Docker: 容器与容器云》<br>《Head First设计模式》<br>我的博客也开始启动了，虽然不知道能坚持多久，但我还是会努力写下去。一个人在社会中很容易迷茫，只有列出清晰的目标，才能一步一个脚印的向前走。github的确是个好东西，可以自己写些小项目练手。可以自己给自己定需求，画设计，前端开发，后台开发，数据库管理等等。项目的形式可以从小到大，然后分享问题。也可以提供一些基础组件（轮子），让别人使用，打造自己的名气。算法的话，国外很重视，国内未来也会跟着国外走。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-如何体现技术能力？&quot;&gt;&lt;a href=&quot;#1-如何体现技术能力？&quot; class=&quot;headerlink&quot; title=&quot;1. 如何体现技术能力？&quot;&gt;&lt;/a&gt;1. 如何体现技术能力？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;今天看了刘未鹏的文章《怎样花两年时间去
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180701</title>
    <link href="http://longman.kim/2018/07/01/%E5%89%A7%E6%9C%AC20180701/"/>
    <id>http://longman.kim/2018/07/01/剧本20180701/</id>
    <published>2018-07-01T15:12:57.000Z</published>
    <updated>2018-08-02T01:45:03.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Guava-Cache的原理与实现"><a href="#1-Guava-Cache的原理与实现" class="headerlink" title="1. Guava Cache的原理与实现"></a>1. Guava Cache的原理与实现</h3><blockquote><p>单机缓存，比较简单的方法是自己用ConcurrentHashMap去实现。Guava Cache实现了自动回收，如果自己采用ConcurrentHashMap需要手动显示回收。Guava Cache提供三种缓存回收方法：基于容量回收，定时回收和基于引用回收。</p></blockquote><h3 id="2-BCOS的架构，技术原理，启动流程"><a href="#2-BCOS的架构，技术原理，启动流程" class="headerlink" title="2. BCOS的架构，技术原理，启动流程"></a>2. BCOS的架构，技术原理，启动流程</h3><blockquote><p>联盟链，参与者（PKI, CA证书，记账者，观察者，白名单，黑名单），共识机制（PBFT, RAFT），多链和跨链，分布式存储leveldb。</p></blockquote><h3 id="3-分布式理论CAP-BASE"><a href="#3-分布式理论CAP-BASE" class="headerlink" title="3. 分布式理论CAP,BASE"></a>3. 分布式理论CAP,BASE</h3><blockquote><p>一致性（C），可用性（A），分区容错性（P），三者不能够被同时满足。<br>一致性指更新操作成功并返回客户端完成后，分布式的所有节点在同一时间的数据完全一致。<br>可用性指读和写操作都能成功。<br>分区容错性指在出现网络故障导致分布式节点不能通信时，系统能否继续服务。<br>BASE代表基本可用，软状态，最终一致性。</p></blockquote><h3 id="4-分布式一致性算法2PC-3PC-PAXOS-ZAB-RAFT-PAFT-RBFT"><a href="#4-分布式一致性算法2PC-3PC-PAXOS-ZAB-RAFT-PAFT-RBFT" class="headerlink" title="4. 分布式一致性算法2PC, 3PC, PAXOS, ZAB, RAFT, PAFT, RBFT"></a>4. 分布式一致性算法2PC, 3PC, PAXOS, ZAB, RAFT, PAFT, RBFT</h3><h3 id="5-挖矿算法POW-POS-DPOS-Leader-BFT"><a href="#5-挖矿算法POW-POS-DPOS-Leader-BFT" class="headerlink" title="5. 挖矿算法POW, POS, DPOS, Leader, BFT"></a>5. 挖矿算法POW, POS, DPOS, Leader, BFT</h3><h3 id="6-消息中间件及RocketMQ模块分解"><a href="#6-消息中间件及RocketMQ模块分解" class="headerlink" title="6. 消息中间件及RocketMQ模块分解"></a>6. 消息中间件及RocketMQ模块分解</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Guava-Cache的原理与实现&quot;&gt;&lt;a href=&quot;#1-Guava-Cache的原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. Guava Cache的原理与实现&quot;&gt;&lt;/a&gt;1. Guava Cache的原理与实现&lt;/h3&gt;&lt;bl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty</title>
    <link href="http://longman.kim/2018/07/01/netty/"/>
    <id>http://longman.kim/2018/07/01/netty/</id>
    <published>2018-07-01T09:08:31.000Z</published>
    <updated>2018-07-01T09:08:31.454Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://longman.kim/2018/07/01/Golang/"/>
    <id>http://longman.kim/2018/07/01/Golang/</id>
    <published>2018-07-01T08:51:02.000Z</published>
    <updated>2018-07-25T09:31:53.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-GO命令"><a href="#1-GO命令" class="headerlink" title="1. GO命令"></a>1. GO命令</h3><ol><li>go build</li></ol><ol start="2"><li>go install</li></ol><ol start="3"><li>go get</li></ol><ol start="4"><li>go clean</li></ol><ol start="5"><li>go doc与godoc</li></ol><ol start="6"><li>go run</li></ol><ol start="7"><li>go test</li></ol><ol start="8"><li>go list</li></ol><ol start="9"><li>go fix与go tool fix</li></ol><ol start="10"><li>go vet与go tool vet</li></ol><ol start="11"><li>go tool pprof</li></ol><ol start="12"><li>go tool cgo</li></ol><ol start="13"><li>go env </li></ol><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-GO命令&quot;&gt;&lt;a href=&quot;#1-GO命令&quot; class=&quot;headerlink&quot; title=&quot;1. GO命令&quot;&gt;&lt;/a&gt;1. GO命令&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;go build&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;go inst
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://longman.kim/2018/07/01/Docker/"/>
    <id>http://longman.kim/2018/07/01/Docker/</id>
    <published>2018-07-01T08:50:44.000Z</published>
    <updated>2018-07-01T08:50:44.697Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BCOS</title>
    <link href="http://longman.kim/2018/07/01/BCOS/"/>
    <id>http://longman.kim/2018/07/01/BCOS/</id>
    <published>2018-07-01T08:50:23.000Z</published>
    <updated>2018-07-01T08:50:23.201Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>超级账本</title>
    <link href="http://longman.kim/2018/07/01/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/"/>
    <id>http://longman.kim/2018/07/01/超级账本/</id>
    <published>2018-07-01T08:50:09.000Z</published>
    <updated>2018-07-01T08:50:09.308Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>以太坊</title>
    <link href="http://longman.kim/2018/07/01/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    <id>http://longman.kim/2018/07/01/以太坊/</id>
    <published>2018-07-01T08:49:54.000Z</published>
    <updated>2018-07-01T08:49:54.152Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>比特币</title>
    <link href="http://longman.kim/2018/07/01/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://longman.kim/2018/07/01/比特币/</id>
    <published>2018-07-01T08:49:40.000Z</published>
    <updated>2018-07-01T08:49:40.763Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
