<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>longman</title>
  <icon>https://www.gravatar.com/avatar/b7e2ba3f68bd206134b3d41535be01b0</icon>
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://longman.kim/"/>
  <updated>2018-07-23T13:46:58.650Z</updated>
  <id>http://longman.kim/</id>
  
  <author>
    <name>lewis longman</name>
    <email>2328811532@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ELK搭建网站监控系统</title>
    <link href="http://longman.kim/2018/07/23/ELK%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>http://longman.kim/2018/07/23/ELK搭建网站监控系统/</id>
    <published>2018-07-23T12:36:53.000Z</published>
    <updated>2018-07-23T13:46:58.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网站流量监控系统"><a href="#网站流量监控系统" class="headerlink" title=". 网站流量监控系统"></a>. 网站流量监控系统</h3><h3 id="1-Logstash"><a href="#1-Logstash" class="headerlink" title="1. Logstash"></a>1. Logstash</h3><p>矿工，日志收集，日志来自于业务系统，业务系统由不同的语言编写，过滤日志格式。Logstash采用Ruby语法，自定义日志格式过滤器，将格式化后的数据输出到ElasticSearch。它的可靠性低，占用CPU和内存的比率很高。</p><h3 id="2-ElasticSearch"><a href="#2-ElasticSearch" class="headerlink" title="2. ElasticSearch"></a>2. ElasticSearch</h3><p>日志仓库，提供全文检索，快速检索，分布式存储。ElasticSearch采用主备部署。</p><h3 id="3-Kibana"><a href="#3-Kibana" class="headerlink" title="3. Kibana"></a>3. Kibana</h3><p>可视化，数据来源于ES，实时读取数据变化。</p><h3 id="4-Filebeat"><a href="#4-Filebeat" class="headerlink" title="4. Filebeat"></a>4. Filebeat</h3><p>承担数据采集的角色</p><h3 id="6-ELK海量日志监控的部署"><a href="#6-ELK海量日志监控的部署" class="headerlink" title="6. ELK海量日志监控的部署"></a>6. ELK海量日志监控的部署</h3><p>利用Kafka将同步改成异步</p><h3 id="7-场景"><a href="#7-场景" class="headerlink" title="7. 场景"></a>7. 场景</h3><p>监控、统计、分析、检索</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网站流量监控系统&quot;&gt;&lt;a href=&quot;#网站流量监控系统&quot; class=&quot;headerlink&quot; title=&quot;. 网站流量监控系统&quot;&gt;&lt;/a&gt;. 网站流量监控系统&lt;/h3&gt;&lt;h3 id=&quot;1-Logstash&quot;&gt;&lt;a href=&quot;#1-Logstash&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://longman.kim/2018/07/23/MongoDB/"/>
    <id>http://longman.kim/2018/07/23/MongoDB/</id>
    <published>2018-07-23T12:10:52.000Z</published>
    <updated>2018-07-23T12:10:52.249Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Netty实战</title>
    <link href="http://longman.kim/2018/07/20/Netty%E5%AE%9E%E6%88%98/"/>
    <id>http://longman.kim/2018/07/20/Netty实战/</id>
    <published>2018-07-20T08:08:46.000Z</published>
    <updated>2018-07-23T14:12:39.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Netty——异步和事件驱动"><a href="#1-Netty——异步和事件驱动" class="headerlink" title="1. Netty——异步和事件驱动"></a>1. Netty——异步和事件驱动</h3><ol><li>Java网络编程</li></ol><blockquote><ol><li>阻塞I/O<br>例如accept会一直阻塞到一个连接的建立，readLine会一直阻塞到换行符或者回车结尾的字符被读取。进一步，可以采用线程池处理多个请求，但存在大量的线程因为等待I/O数据就绪而处于休眠状态，并且需要为每个线程分配调用栈并切换上下文，同时虚拟机支持的线程数量有限。    </li><li>Java NIO, 非阻塞I/O<br>用setsocketopt()配置套接字，在读写调用没有数据时立即返回，当有任何套接字已经有数据可供读写时，使用操作系统的事件通知主线程。主线程中有一个selector，它可以监控多个Buffer相连，每个Buffer和一个Socket相连，当任何Buffer中有数据可读写时，selector就会选择该Buffer进行读写，即和该Buffer对应的Socket通信。  </li></ol></blockquote><ol start="2"><li>Netty简介<blockquote><p>Netty的特点  </p><ol><li>设计<br>统一的API，支持多种传输类型，阻塞和非阻塞，简单而强大的线程模型，真正的无连接数据报套接字支持，链接逻辑组件以支持复用  </li><li>易于使用  </li><li>性能<br>比Java核心API更高的吞吐量以及更低的延迟，得益于池化和复用，拥有更低的资源消耗，最少的内存复制  </li><li>健壮性<br>不会因为慢速、快速或者超载的连接而导致OutOfMemoryError，消除在高速网络中NIO应用程序常见的不公平读/写比率  </li><li>安全性<br>完整的SSL/TLS以及StartTLS支持，可用于受限环境下  </li><li>社区驱动<br>发布快速而且频繁  </li></ol><p>Netty常用来做HTTP长连接，或者各种推送通知  </p><p>异步和事件驱动  </p></blockquote></li></ol><ol start="3"><li>Netty的核心组件</li></ol><blockquote><ol><li>Channel<br>Channel是Java NIO的一个基本构造，代表一个到实体的开放连接，如读写操作。可以把Channel看作是传入（入站）和传出（出站）数据的载体，它可以被打开，被关闭，连接或者断开连接。  </li><li>回调<br>回调是一个方法，其他系统在某个操作完成后通知该系统时，就是调用的回调方法。  </li><li>Future<br>异步操作的结果的占位符，它将在未来的某个时候完成，并提供对其结果的访问。在JDK中只允许手动检测对应的操作是否已经完成，或者一直阻塞直到它完成。Netty中自己实现了ChannelFuture,用于异步操作。ChannelFuture能够注册一个或多个监听器ChannelFutureListener, 在操作完成时会调用监听器的operationComplete()方法，ChannelFutureListener提供的通知机制消除了手动检查对应操作是否完成的必要。每个Netty的传出I/O操作都将返回一个ChannelFuture，即它们不会阻塞，Netty是完成异步和事件驱动的。</li><li>事件和ChannelHandler<br>入站事件：连接已被激活或者连接失活，数据读取，用户事件，错误事件。<br>出站事件：打开或者关闭到远程节点的连接，将数据写到或者冲刷到套接字。<br>入站事件-&gt;入站处理器，出站-&gt;出站处理器<br>拦截操作以及高速地转换入站和出站数据，都只需要你提供回调函数或者利用操作返回的Future。Netty为每个Channel分配一个EventLoop来处理所有事件，包括注册感兴趣的事件，将事件派发给ChannelHandler, 安排进一步的动作。Netty的EventLoop是一个线程驱动，处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会变。      </li></ol></blockquote><h3 id="2-你的第一款Netty应用程序"><a href="#2-你的第一款Netty应用程序" class="headerlink" title="2. 你的第一款Netty应用程序"></a>2. 你的第一款Netty应用程序</h3><ol><li><p>Echo服务器</p><blockquote><ol><li>至少一个ChannelHandler，处理从客户端接收到的数据，即业务处理。  </li><li>引导，配置服务器的启动代码，绑定端口，配置Channel。</li><li>ChannelHandler继承ChannelInboundHandlerAdapter，ChannelInboundHandlerAdapter实现ChannelInboundHandler接口，响应入站事件。我们感兴趣的方法有channelRead()对于每个传入的消息要调用，channelReadComplete()通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息。exeptionCaught()在读取操作期间，有异常抛出时会调用。</li><li>针对不同类型的事件来调用ChannelHandler。  </li><li>应用程序通过实现或者扩展ChannelHandler来挂钩到事件的生命周期，并且提供自定义的应用程序逻辑。  </li><li>在架构上，ChannelHandler有助于保持业务逻辑与网络处理代码的分离。   </li><li>服务器的大致流程，其中EchoServerHandler实现业务逻辑，main方法引导服务器<br>7.1 创建一个ServerBootstrap的实例以引导和绑定服务器<br>7.2 创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接收连接以及读写数据<br>7.3 指定服务器绑定本地的InetSocketAddress<br>7.4 使用一个EchoServerHandler的实例初始化每个新的Channel<br>7.5 调用ServerBootstrap.bind()绑定服务器  </li></ol></blockquote></li><li><p>Echo客户端</p><blockquote><ol><li>客户端的流程<br>1.1 连接到服务器<br>1.2 发送一个或者多个消息<br>1.3 对于每个消息，等待并接收从服务器发回的相同的消息<br>1.4 关闭连接  </li><li>ChannelHandler继承SimpleChannelInboundHandler实现ChannelInboundHandler，主要重写三个方法，channelActive()在到服务器的连接已经建立之后将被调用，channelRead0()当从服务器接收到一条消息时被调用，exceptionCaught()在处理过程中引发异常时被调用。  </li><li>SimpleChannelInboundHandler和ChannelInboundHandlerAdapter  </li></ol></blockquote></li></ol><h3 id="3-Netty的组件和设计"><a href="#3-Netty的组件和设计" class="headerlink" title="3. Netty的组件和设计"></a>3. Netty的组件和设计</h3><h3 id="4-传输"><a href="#4-传输" class="headerlink" title="4. 传输"></a>4. 传输</h3><h3 id="5-ByteBuf"><a href="#5-ByteBuf" class="headerlink" title="5. ByteBuf"></a>5. ByteBuf</h3><h3 id="6-ChannelHandler和ChannelPipeline"><a href="#6-ChannelHandler和ChannelPipeline" class="headerlink" title="6. ChannelHandler和ChannelPipeline"></a>6. ChannelHandler和ChannelPipeline</h3><h3 id="7-Eventloop和线程模型"><a href="#7-Eventloop和线程模型" class="headerlink" title="7. Eventloop和线程模型"></a>7. Eventloop和线程模型</h3><h3 id="8-引导"><a href="#8-引导" class="headerlink" title="8. 引导"></a>8. 引导</h3><h3 id="9-单元测试"><a href="#9-单元测试" class="headerlink" title="9. 单元测试"></a>9. 单元测试</h3><h3 id="10-编解码器框架"><a href="#10-编解码器框架" class="headerlink" title="10. 编解码器框架"></a>10. 编解码器框架</h3><h3 id="11-预置的ChannelHandler和编解码器"><a href="#11-预置的ChannelHandler和编解码器" class="headerlink" title="11. 预置的ChannelHandler和编解码器"></a>11. 预置的ChannelHandler和编解码器</h3><h3 id="12-WebSocket"><a href="#12-WebSocket" class="headerlink" title="12. WebSocket"></a>12. WebSocket</h3><h3 id="13-使用UDP广播事件"><a href="#13-使用UDP广播事件" class="headerlink" title="13. 使用UDP广播事件"></a>13. 使用UDP广播事件</h3><h3 id="14-案例研究，第一部分"><a href="#14-案例研究，第一部分" class="headerlink" title="14. 案例研究，第一部分"></a>14. 案例研究，第一部分</h3><h3 id="15-案例研究，第二部分"><a href="#15-案例研究，第二部分" class="headerlink" title="15. 案例研究，第二部分"></a>15. 案例研究，第二部分</h3><h3 id="附录-Maven介绍"><a href="#附录-Maven介绍" class="headerlink" title="附录 Maven介绍"></a>附录 Maven介绍</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Netty——异步和事件驱动&quot;&gt;&lt;a href=&quot;#1-Netty——异步和事件驱动&quot; class=&quot;headerlink&quot; title=&quot;1. Netty——异步和事件驱动&quot;&gt;&lt;/a&gt;1. Netty——异步和事件驱动&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Java网络
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式事务与秒杀技巧</title>
    <link href="http://longman.kim/2018/07/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E7%A7%92%E6%9D%80%E6%8A%80%E5%B7%A7/"/>
    <id>http://longman.kim/2018/07/20/分布式事务与秒杀技巧/</id>
    <published>2018-07-20T08:07:51.000Z</published>
    <updated>2018-07-20T08:08:21.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式事务的解法"><a href="#1-分布式事务的解法" class="headerlink" title="1. 分布式事务的解法"></a>1. 分布式事务的解法</h3><ol><li><p>一个系统操作多个数据库</p><blockquote><p>XA协议（数据库要支持XA协议）<br>基本功能：数据库功能+开源组件（atomikos）实现</p></blockquote></li><li><p>多系统操作多数据库</p><blockquote><p>MQ消息队列（生产者消费者模型），优点是解耦，缺点是不能保证实时性（需要结合业务场景进行规避）  </p></blockquote></li><li><p>TCC补偿机制</p><blockquote><p>可逆操作，编程式分布式事务，一种解决方案<br>atomikos的论文《Tcc For Rest》<br>TCC三要素try(预留资源，临时状态), canfirm(确认操作), cancel(操作回滚)<br>bytetcc</p></blockquote></li><li><p>TOC</p><blockquote><p>未知异常：人工干预</p></blockquote></li><li><p>CAP,BASE</p><blockquote><p>取舍一致性和可用性</p></blockquote></li></ol><h3 id="2-秒杀系统架构分析与实现"><a href="#2-秒杀系统架构分析与实现" class="headerlink" title="2. 秒杀系统架构分析与实现"></a>2. 秒杀系统架构分析与实现</h3><ol><li><p>超卖，解决方案是使用数据库的乐观锁</p></li><li><p>用户重复提交，前端控制防止重复提交，后台限流</p></li><li><p>超过服务器单台机器承受能力，解决方案nginx负载均衡多台机器</p></li><li><p>码农通过脚本攻击，redis(性能每秒10w，用pipeline每秒55w)针对userId限制操作频率</p></li><li><p>超过数据库最大连接数，采用令牌机制，预先生成令牌放在reids中，拿到令牌的可以操作数据库</p></li><li><p>其他方法</p><blockquote><p>采用消息队列，异步执行SQL<br>数据库分库分表<br>微服务架构独立秒杀系统，Docker实现快速扩容</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式事务的解法&quot;&gt;&lt;a href=&quot;#1-分布式事务的解法&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式事务的解法&quot;&gt;&lt;/a&gt;1. 分布式事务的解法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个系统操作多个数据库&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法工程师</title>
    <link href="http://longman.kim/2018/07/19/%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://longman.kim/2018/07/19/算法工程师/</id>
    <published>2018-07-18T17:37:27.000Z</published>
    <updated>2018-07-18T17:48:25.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><h3 id="2-回归"><a href="#2-回归" class="headerlink" title="2. 回归"></a>2. 回归</h3><h3 id="3-推荐"><a href="#3-推荐" class="headerlink" title="3. 推荐"></a>3. 推荐</h3><h3 id="4-深度学习"><a href="#4-深度学习" class="headerlink" title="4. 深度学习"></a>4. 深度学习</h3><h3 id="5-强化学习"><a href="#5-强化学习" class="headerlink" title="5. 强化学习"></a>5. 强化学习</h3><h3 id="6-NLP自然语言处理"><a href="#6-NLP自然语言处理" class="headerlink" title="6. NLP自然语言处理"></a>6. NLP自然语言处理</h3><h3 id="7-机器人定位算法"><a href="#7-机器人定位算法" class="headerlink" title="7. 机器人定位算法"></a>7. 机器人定位算法</h3><h3 id="8-多传感器融合算法"><a href="#8-多传感器融合算法" class="headerlink" title="8. 多传感器融合算法"></a>8. 多传感器融合算法</h3><h3 id="9-SLAM地图构建算法"><a href="#9-SLAM地图构建算法" class="headerlink" title="9. SLAM地图构建算法"></a>9. SLAM地图构建算法</h3><h3 id="10-路径规划算法"><a href="#10-路径规划算法" class="headerlink" title="10. 路径规划算法"></a>10. 路径规划算法</h3><h3 id="11-视觉算法（检测，跟踪）"><a href="#11-视觉算法（检测，跟踪）" class="headerlink" title="11. 视觉算法（检测，跟踪）"></a>11. 视觉算法（检测，跟踪）</h3><h3 id="12-TensorFlow"><a href="#12-TensorFlow" class="headerlink" title="12. TensorFlow"></a>12. TensorFlow</h3><h3 id="13-Caffe"><a href="#13-Caffe" class="headerlink" title="13. Caffe"></a>13. Caffe</h3><h3 id="14-有监督学习"><a href="#14-有监督学习" class="headerlink" title="14. 有监督学习"></a>14. 有监督学习</h3><h3 id="15-无监督学习"><a href="#15-无监督学习" class="headerlink" title="15. 无监督学习"></a>15. 无监督学习</h3><h3 id="16-卡尔曼滤波、粒子滤波"><a href="#16-卡尔曼滤波、粒子滤波" class="headerlink" title="16. 卡尔曼滤波、粒子滤波"></a>16. 卡尔曼滤波、粒子滤波</h3><h3 id="17-马尔科夫决策过程"><a href="#17-马尔科夫决策过程" class="headerlink" title="17. 马尔科夫决策过程"></a>17. 马尔科夫决策过程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分类&quot;&gt;&lt;a href=&quot;#1-分类&quot; class=&quot;headerlink&quot; title=&quot;1. 分类&quot;&gt;&lt;/a&gt;1. 分类&lt;/h3&gt;&lt;h3 id=&quot;2-回归&quot;&gt;&lt;a href=&quot;#2-回归&quot; class=&quot;headerlink&quot; title=&quot;2. 回归&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大数据开发工程师</title>
    <link href="http://longman.kim/2018/07/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://longman.kim/2018/07/19/大数据开发工程师/</id>
    <published>2018-07-18T17:00:07.000Z</published>
    <updated>2018-07-18T17:35:23.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Hadoop生态"><a href="#1-Hadoop生态" class="headerlink" title="1. Hadoop生态"></a>1. Hadoop生态</h3><h5 id="1-对大量数据进行分布式处理的软件框架Hadoop"><a href="#1-对大量数据进行分布式处理的软件框架Hadoop" class="headerlink" title="1. 对大量数据进行分布式处理的软件框架Hadoop"></a>1. 对大量数据进行分布式处理的软件框架Hadoop</h5><h5 id="2-分布式存储系统HDFS"><a href="#2-分布式存储系统HDFS" class="headerlink" title="2. 分布式存储系统HDFS"></a>2. 分布式存储系统HDFS</h5><h5 id="3-分布式计算框架MapReduce"><a href="#3-分布式计算框架MapReduce" class="headerlink" title="3. 分布式计算框架MapReduce"></a>3. 分布式计算框架MapReduce</h5><h5 id="4-分布式计算框架YARN"><a href="#4-分布式计算框架YARN" class="headerlink" title="4. 分布式计算框架YARN"></a>4. 分布式计算框架YARN</h5><h5 id="5-分布式数据库Hbase"><a href="#5-分布式数据库Hbase" class="headerlink" title="5. 分布式数据库Hbase"></a>5. 分布式数据库Hbase</h5><h5 id="6-分布式协调服务Zookeeper"><a href="#6-分布式协调服务Zookeeper" class="headerlink" title="6. 分布式协调服务Zookeeper"></a>6. 分布式协调服务Zookeeper</h5><h5 id="7-工作流引擎Pig-Pig2"><a href="#7-工作流引擎Pig-Pig2" class="headerlink" title="7. 工作流引擎Pig, Pig2"></a>7. 工作流引擎Pig, Pig2</h5><h5 id="8-数据仓库Hive-Hive2"><a href="#8-数据仓库Hive-Hive2" class="headerlink" title="8. 数据仓库Hive, Hive2"></a>8. 数据仓库Hive, Hive2</h5><h5 id="9-日志收集Flume"><a href="#9-日志收集Flume" class="headerlink" title="9. 日志收集Flume"></a>9. 日志收集Flume</h5><h5 id="10-作业流调度系统Oozie"><a href="#10-作业流调度系统Oozie" class="headerlink" title="10. 作业流调度系统Oozie"></a>10. 作业流调度系统Oozie</h5><h5 id="11-数据库TEL工具Sqoop"><a href="#11-数据库TEL工具Sqoop" class="headerlink" title="11. 数据库TEL工具Sqoop"></a>11. 数据库TEL工具Sqoop</h5><h5 id="12-安装部署工具Ambari"><a href="#12-安装部署工具Ambari" class="headerlink" title="12. 安装部署工具Ambari"></a>12. 安装部署工具Ambari</h5><h3 id="2-大数据处理框架Spark"><a href="#2-大数据处理框架Spark" class="headerlink" title="2. 大数据处理框架Spark"></a>2. 大数据处理框架Spark</h3><h3 id="3-基于数据流的实时处理系统Storm"><a href="#3-基于数据流的实时处理系统Storm" class="headerlink" title="3. 基于数据流的实时处理系统Storm"></a>3. 基于数据流的实时处理系统Storm</h3><h3 id="4-开源流处理平台Kafka"><a href="#4-开源流处理平台Kafka" class="headerlink" title="4. 开源流处理平台Kafka"></a>4. 开源流处理平台Kafka</h3><h3 id="5-面向分布式数据流处理和批量数据处理的开源计算平台Flink"><a href="#5-面向分布式数据流处理和批量数据处理的开源计算平台Flink" class="headerlink" title="5. 面向分布式数据流处理和批量数据处理的开源计算平台Flink"></a>5. 面向分布式数据流处理和批量数据处理的开源计算平台Flink</h3><h3 id="6-基于Lucence的搜索服务器Elasticsearch"><a href="#6-基于Lucence的搜索服务器Elasticsearch" class="headerlink" title="6. 基于Lucence的搜索服务器Elasticsearch"></a>6. 基于Lucence的搜索服务器Elasticsearch</h3><h3 id="7-MapReduce"><a href="#7-MapReduce" class="headerlink" title="7. MapReduce"></a>7. MapReduce</h3><h3 id="8-系统Debug-Profiling能力和经验"><a href="#8-系统Debug-Profiling能力和经验" class="headerlink" title="8. 系统Debug/Profiling能力和经验"></a>8. 系统Debug/Profiling能力和经验</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Hadoop生态&quot;&gt;&lt;a href=&quot;#1-Hadoop生态&quot; class=&quot;headerlink&quot; title=&quot;1. Hadoop生态&quot;&gt;&lt;/a&gt;1. Hadoop生态&lt;/h3&gt;&lt;h5 id=&quot;1-对大量数据进行分布式处理的软件框架Hadoop&quot;&gt;&lt;a h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂味</title>
    <link href="http://longman.kim/2018/07/18/%E6%9D%82%E5%91%B3/"/>
    <id>http://longman.kim/2018/07/18/杂味/</id>
    <published>2018-07-18T13:49:13.000Z</published>
    <updated>2018-07-18T16:55:27.424Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-MySQL主从同步的实现方式"><a href="#1-MySQL主从同步的实现方式" class="headerlink" title="1. MySQL主从同步的实现方式"></a>1. MySQL主从同步的实现方式</h5><blockquote><p>MySQL的复制是异步实时，具体步骤是：主服务器把数据更改记录写到binlog中，从服务器把binlog复制到自己的中继日志relay log中，然后重做中继日志，把更改应用到自己的数据库。</p></blockquote><h5 id="2-MySQL存储引擎的对比"><a href="#2-MySQL存储引擎的对比" class="headerlink" title="2. MySQL存储引擎的对比"></a>2. MySQL存储引擎的对比</h5><ol><li><p>Innodb</p><blockquote><p>支持事务、OLTP、行锁、支持外键、缓存索引缓存数据、MVCC(多版本并发控制)</p></blockquote></li><li><p>MyISAM</p><blockquote><p>不支持事务、OLAP、表锁、只缓存索引不缓存数据</p></blockquote></li></ol><h5 id="3-MySQL索引的实现"><a href="#3-MySQL索引的实现" class="headerlink" title="3. MySQL索引的实现"></a>3. MySQL索引的实现</h5><ol><li><p>B+树索引  </p><blockquote><p>记录节点按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。B树中的关键字分布在整棵树中，叶子节点不包含任何关键字信息，而B+树关键字集合分布在叶子节点中，非叶子节点只是叶子节点中关键字的索引。B树中任何一个关键字只出现在一个节点中，而B+树中的关键字必须出现在叶节点中，也可能在非叶节点中重复出现。<br>B+树比B树更适合做文件索引和数据库索引。B树只适合随机检索，B+树同时支持随机检索和顺序检索。B+树的磁盘读写代价更低。B+树的查询效率更加稳定。数据库中基于范围的查询是非常频繁的。<br>B+树索引支持 like ‘xxx%’和 like ‘%xxx’</p></blockquote></li><li><p>全文检索  </p><blockquote><p>倒排索引<br>全文索引支持 like ‘%xxx%’</p></blockquote></li></ol><h5 id="4-处理内存泄漏的经验"><a href="#4-处理内存泄漏的经验" class="headerlink" title="4. 处理内存泄漏的经验"></a>4. 处理内存泄漏的经验</h5><h5 id="5-长连接，离线推送，在线推送，及时通信IM，直播"><a href="#5-长连接，离线推送，在线推送，及时通信IM，直播" class="headerlink" title="5. 长连接，离线推送，在线推送，及时通信IM，直播"></a>5. 长连接，离线推送，在线推送，及时通信IM，直播</h5><ol><li><p>长连接</p><blockquote><p> HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP/1.0默认使用短连接，一次HTTP操作，就建立一次连接，任务结束就中断连接。HTTP/1.1默认使用长连接Connection:keep-alive，保持一定的时间，没有请求再断开。TCP长连接的保活功能主要由服务器应用提供，在给定的连接两个小时内没有任何动作，服务器就会向客户端发送一个探测报文。长连接多用户操作频繁，点对点的通讯，而且连接数不能太多。</p></blockquote></li><li><p>即时通讯IM</p><blockquote><p>C1,C2登录时即时服务IM验证用户名和密码，并登记各自的IP和PORT，并从服务器上拉取好友列表（包括好友的IP和PORT）给C1,C2。C1和C2通讯的方式有两种，一种是C1和C2之间采用TCP连接通讯。一种是C1和Server, C2和Server进行TCP连接，即使用Server中转通讯。<br>如果C1,C2都在内网，需要进行路由器进行NAT才能出去。使用STUN隧道技术，完成透明NAT，受限NAT，端口受限圆锥型NAT，对称型NAT（双向NAT，大公司使用）。<br>同时需要客户端给服务器发送心跳，如果没有响应，就断开长连接。还需要考虑重连机制、双向PingPong机制（ping对方，如果没有在约定的时间内返回就断开socket）、QOS机制（服务质量保证通讯延迟和阻塞）。<br>聊天协议：原生Socket(代表框架CocoAsyncSocket)、WebSocket(代表框架SocketRocket)、MQTT(代表框架MQTTKit)、XMPP(代表框架XMPPFramework)</p></blockquote></li></ol><h5 id="6-https的步骤"><a href="#6-https的步骤" class="headerlink" title="6. https的步骤"></a>6. https的步骤</h5><ol><li>client发送连接请求给server</li><li>server返回服务端证书给client</li><li>client通过浏览器内置根证书对服务端证书CA进行校验</li><li>client通过证书中的公钥加密对称密钥发送给server</li><li>双方通过对称密钥加密数据开始通信</li></ol><h5 id="7-ACCS-阿里云通道服务"><a href="#7-ACCS-阿里云通道服务" class="headerlink" title="7. ACCS(阿里云通道服务)"></a>7. ACCS(阿里云通道服务)</h5><h5 id="8-构建高性能的分布式系统"><a href="#8-构建高性能的分布式系统" class="headerlink" title="8. 构建高性能的分布式系统"></a>8. 构建高性能的分布式系统</h5><ol><li>分布式服务治理框架Dubbo</li><li>分布式消息中间件RocketMQ</li><li>数据库连接池Druid和JSON库Fastjson</li><li>云数据库Redis分支ApasaraCache</li><li>自研富容器技术Pouch和文件分发系统Dragonfly</li><li>开源数据看看AliSQL</li><li>分布式文件系统FastDFS</li><li>分布式数据库OceanBase</li><li>Web服务器Tengine</li><li>Redis缓存服务器AliRedis</li><li>分布式数据库同步系统otter</li><li>系统信息采集和监控工具Tsar</li><li>非侵入式运行期AOP框架Dexposed</li></ol><h5 id="9-互联网时代的用户端"><a href="#9-互联网时代的用户端" class="headerlink" title="9. 互联网时代的用户端"></a>9. 互联网时代的用户端</h5><ol><li>Ant Design，前端的美好呈现</li><li>企业级Web基础框架Egg</li><li>灵活的Android开发框架Atlas</li><li>跨平台移动开发工具Weex </li></ol><h5 id="10-源自最佳实践的参考规范"><a href="#10-源自最佳实践的参考规范" class="headerlink" title="10. 源自最佳实践的参考规范"></a>10. 源自最佳实践的参考规范</h5><ol><li>阿里巴巴Java开发规范</li><li>分布式消息领域的国际标准OpenMessaging</li></ol><h5 id="11-物联网时代"><a href="#11-物联网时代" class="headerlink" title="11. 物联网时代"></a>11. 物联网时代</h5><ol><li>新一代物联网操作系统AliOS Things</li><li>轻量化操作系统AliOS Lite</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-MySQL主从同步的实现方式&quot;&gt;&lt;a href=&quot;#1-MySQL主从同步的实现方式&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL主从同步的实现方式&quot;&gt;&lt;/a&gt;1. MySQL主从同步的实现方式&lt;/h5&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java程序性能优化</title>
    <link href="http://longman.kim/2018/07/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://longman.kim/2018/07/17/Java程序性能优化/</id>
    <published>2018-07-17T14:25:03.000Z</published>
    <updated>2018-07-17T14:25:03.362Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java架构师技术图谱</title>
    <link href="http://longman.kim/2018/07/17/Java%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <id>http://longman.kim/2018/07/17/Java架构师技术图谱/</id>
    <published>2018-07-16T16:23:31.000Z</published>
    <updated>2018-07-17T13:19:25.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1. 源码分析"></a>1. 源码分析</h3><h5 id="1-常用设计模式"><a href="#1-常用设计模式" class="headerlink" title="1. 常用设计模式"></a>1. 常用设计模式</h5><ol><li><p>Proxy代理模式</p><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问，例如Spring AOP。</p></blockquote></li><li><p>Factory工厂模式</p><blockquote><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，例如数据库访问。</p></blockquote></li><li><p>Singleton单例模式</p><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote></li></ol><ol start="4"><li><p>Delegate委派模式</p><blockquote></blockquote></li><li><p>Strategy策略模式</p><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换。</p></blockquote></li><li><p>Prototype原型模式</p><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote></li><li><p>Template模板模式</p><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote></li></ol><h5 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2. Spring"></a>2. Spring</h5><ol><li>Beans<blockquote><p>1 接口实例化<br>构造函数、静态工厂、实例工厂<br>BeanFactory getBean() -&gt; 默认构造函数 -&gt; 属性值注入 -&gt; 实现了InitializingBean接口调用afterPropertiesSet() -&gt; init-method</p></blockquote></li></ol><blockquote><p>2 代理Bean操作<br>JDK的Proxy代理类，CGLIB</p></blockquote><ol start="2"><li>Context<blockquote><p>1 IOC容器设计原理及高级特性<br>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。反射（reflection）允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p></blockquote></li></ol><blockquote><p>2 AOP设计原理<br>JDK的Proxy代理类，CGLIB</p></blockquote><blockquote><p>3 FactoryBean与BeanFactory<br>BeanFactory是IOC最基本的容器，负责生产和管理bean，例如DefaultListableBeanFactory。<br>FactoryBean是一个接口，当容器实现了FactoryBean之后，通过getBean获取到的Bean对象，是实现类中的getObject方法返回的对象。</p></blockquote><ol start="3"><li>Transaction<blockquote><p>1 声明式事务底层原理<br>@Transaction注解，传播行为，隔离级别，是否只读，事务超时，回滚规则。事务管理的切面属于<a href="aop:around" target="_blank" rel="noopener">aop:around</a>即AOP环绕类型的切面。</p></blockquote></li></ol><blockquote><p>2 Spring事务处理机制</p></blockquote><blockquote><p>3 事务的传播与监控<br>PROPAGATION_REQUIRED<br>默认传播机制，支持当前事务，如果没有，则新建一个事务。<br>PROPAGATION_REQUIRED_NEW<br>新建事务，如果当前存在事务，把当前事务挂起。新建的事务与被挂起的事务没有任何关系，是独立的两个事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作。<br>PROPAGATION_SUPPORTS<br>支持当前事务，如果没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY<br>支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_NOT_SUPPORTED<br>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER<br>以非事务方式执行操作，如果当前存在事务，则抛出异常。<br>PROPAGATION_NESTED<br>如果一个事务存在，则运行在一个嵌套的事务中。</p></blockquote><blockquote><p>4 基于Springjdbc手写orm框架</p></blockquote><ol start="4"><li>MVC<blockquote><p>1 MVC原理<br>模型，视图，控制器。</p></blockquote></li></ol><blockquote><p>2 与IOC容器整合的原理</p></blockquote><blockquote><p>3 HandlerMapping实现原理<br>负责定位</p></blockquote><blockquote><p>4 HandlerAdapter实现原理<br>负责调用</p></blockquote><blockquote><p>5 ViewResolver实现原理<br>视图解析</p></blockquote><blockquote><p>6 Controller调用原理</p></blockquote><blockquote><p>7 动态参数匹配原理</p></blockquote><blockquote><p>8 手写实现SpringMVC框架<br>请求-&gt;DispatcherServlet-&gt;处理器映射-&gt;控制器-&gt;模式及逻辑视图名-&gt;视图解析器-&gt;视图-&gt;响应</p></blockquote><h5 id="3-Mybatis"><a href="#3-Mybatis" class="headerlink" title="3. Mybatis"></a>3. Mybatis</h5><ol><li>代码自动生成器：Generator</li><li><p>Mybatis下1对多、多对多嵌套结果、嵌套查询</p></li><li><p>一级缓存、二级缓存使用场景及选择策略</p><blockquote><p>在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认开启一级缓存。二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存。二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个Mapper的二级缓存区域。</p></blockquote></li><li><p>Mybatis与Spring集成Spring-Mybatis分析</p></li><li><p>Spring集成下的SqlSession与Mapper</p></li><li><p>Mybatis的事务</p></li><li><p>分析Mybatis的动态代理的真正实现</p></li><li><p>一步一步手写实现Mybatis1.0到2.0</p></li></ol><p>###2. 并发编程</p><h5 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h5><ol><li>线程通信<blockquote><ol><li>共享内存<br>线程之间通过写-读内存中的公共状态  </li><li>消息传递</li></ol></blockquote></li></ol><h5 id="2-内存模型"><a href="#2-内存模型" class="headerlink" title="2. 内存模型"></a>2. 内存模型</h5><ol><li><p>重排序</p><blockquote><ol><li>编译器优化的重排序</li><li>处理器重排序，指令级并行技术ILP</li><li>内存系统的重排序</li></ol></blockquote></li><li><p>顺序一致性</p></li></ol><ol start="3"><li><p>Happen-Before</p><blockquote><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p></blockquote></li><li><p>As-If-Serial</p><blockquote><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会改变。</p></blockquote></li></ol><h5 id="3-Synchronized"><a href="#3-Synchronized" class="headerlink" title="3. Synchronized"></a>3. Synchronized</h5><ol><li>同步、重量级锁</li><li>Syncronized原理</li><li>锁优化<blockquote><ol><li>自旋锁</li><li>轻量级锁</li><li>重量级锁</li><li>偏向锁</li></ol></blockquote></li></ol><h5 id="4-Volatile"><a href="#4-Volatile" class="headerlink" title="4. Volatile"></a>4. Volatile</h5><ol><li>Volatile实现机制</li><li>内存语义</li><li>内存模型</li></ol><h5 id="5-DCL"><a href="#5-DCL" class="headerlink" title="5. DCL"></a>5. DCL</h5><ol><li>单例模式</li><li>DCL</li><li>解决方案</li></ol><h5 id="6-并发基础"><a href="#6-并发基础" class="headerlink" title="6. 并发基础"></a>6. 并发基础</h5><ol><li><p>AQS</p><blockquote><ol><li>AbstractQueuedSyncronizer同步器</li><li>CLH同步队列</li><li>同步状态的获取与释放</li><li>线程阻塞与唤醒</li></ol></blockquote></li><li><p>CAS</p><blockquote><ol><li>Compare And Swap</li><li>缺陷</li></ol></blockquote></li></ol><h5 id="7-锁"><a href="#7-锁" class="headerlink" title="7. 锁"></a>7. 锁</h5><ol><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>Condition</li></ol><h5 id="8-并发工具类"><a href="#8-并发工具类" class="headerlink" title="8. 并发工具类"></a>8. 并发工具类</h5><ol><li>CyclicBarrier</li><li>CountdownLatch</li><li>Semphore</li></ol><h5 id="9-并发集合"><a href="#9-并发集合" class="headerlink" title="9. 并发集合"></a>9. 并发集合</h5><ol><li>ConcurrentHashMap</li><li>ConcurrentLinkedQueue</li></ol><h5 id="10-原子操作"><a href="#10-原子操作" class="headerlink" title="10. 原子操作"></a>10. 原子操作</h5><ol><li><p>基本类型</p><blockquote><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ol></blockquote></li><li><p>数组</p><blockquote><ol><li>AtomicIntegerArrary</li><li>AtomicLongArrary</li><li>AtomicReferenceArrary</li></ol></blockquote></li><li><p>引用类型</p><blockquote><ol><li>AtomicReference</li><li>AtomicReferenceFieldUpdater</li></ol></blockquote></li></ol><h5 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11. 线程池"></a>11. 线程池</h5><ol><li>Executor</li><li>ThreadPoolExecutor</li><li>Callable和Future</li><li>ScheduledExecutorService</li></ol><h5 id="12-其他"><a href="#12-其他" class="headerlink" title="12. 其他"></a>12. 其他</h5><ol><li>ThreadLocal</li><li>Fork/Join</li></ol><p>###3. 性能调优</p><p>###4. 分布式架构</p><h5 id="1-漫谈分布式架构"><a href="#1-漫谈分布式架构" class="headerlink" title="1. 漫谈分布式架构"></a>1. 漫谈分布式架构</h5><ol><li>初识分布式架构及意义</li><li>如何把应用从单机扩展到分布式</li><li><p>构建分布式架构最重要因素</p><blockquote><ol><li>CDN加速静态文件访问</li><li>分布式存储</li><li>分布式搜索引擎</li><li>应用发布与监控</li><li>应用容灾及机房规划</li><li>系统动态扩容</li></ol></blockquote></li><li><p>分布式架构设计</p><blockquote><ol><li>主流架构模型-SOA架构与微服务架构</li><li>领域驱动设计及业务驱动划分</li><li>分布式架构的基本理论CAP,BASE及其应用</li><li>什么是分布式架构下的高可用设计</li><li>分布式架构下的可伸缩设计</li><li>构建高性能的分布式架构</li></ol></blockquote></li></ol><h5 id="2-分布式架构策略-分而治之"><a href="#2-分布式架构策略-分而治之" class="headerlink" title="2. 分布式架构策略-分而治之"></a>2. 分布式架构策略-分而治之</h5><ol><li>从简到难，从网络通信探究分布式通信的原理</li><li>基于消息方式的系统间通信</li><li>理解通信协议传输过程中的序列化与反序列化机制</li><li><p>基于框架的RPC通信技术</p><blockquote><ol><li>Webservice/Apache Cxf</li><li>RMI/Spring RMI</li><li>Hessian</li></ol></blockquote></li><li><p>传统RPC技术在大型分布式架构下面临的问题</p></li><li>分布式架构下的RPC解决方案</li><li><p>分布式系统的基石-Zookeeper</p><blockquote><ol><li>从0开始搭建3个节点的Zookeeper集群</li><li>深入分析Zookeeper在Discon配置中心的应用</li><li>基于Zookeeper的分布式锁解决方案</li><li>Zookeeper集群升级、迁移</li><li>基于Zookeeper实现分布式服务器动态上线感知</li><li>深入分析Zookeeper ZAB协议及选举机制源码解读</li></ol></blockquote></li><li><p>使用Dubbo对单一应用服务改造</p><blockquote><ol><li>Dubbo管理中心及监控平台安装部署</li><li>Dubbo分布式服务模块划分（领域驱动）</li><li>基于Dubbo的分布式系统架构实战</li><li>Dubbo负载均衡策略分析</li><li>Dubbo服务调试之服务只订阅及服务只注册配置</li><li>Dubbo服务接口的设计原则（实战经验分享）</li><li>Dubbo设计原理及源码分析</li><li>基于Dubbo构建大型分布式电商平台实战雏形</li><li>Dubbo容器机制及高扩展分析</li></ol></blockquote></li></ol><h5 id="3-分布式架构-中间件"><a href="#3-分布式架构-中间件" class="headerlink" title="3. 分布式架构-中间件"></a>3. 分布式架构-中间件</h5><ol><li><p>分布式消息通信</p><blockquote><ol><li>消息中间件在分布式架构中的作用</li><li>ActiveMQ高可用集群企业级部署方案</li><li>ActiveMQ P2P及Pub/Sub模型详解</li><li>ActiveMQ消息确认及重发策略</li><li>ActiveMQ基于Spring完全分布式消息队列实战</li><li>Kafka基于Zookeeper搭建高可用集群实战</li><li>Kafka消息处理过程剖析</li><li>Java客户端实现Kafka生产者与消费者实例</li><li>Kafka的副本机制及选举原理剖析</li><li>基于Kafka实现应用日志实时上报统计分析</li><li>初步认识RabbitMQ及高可用集群部署</li><li>了解RabbitMQ消息分发机制及主题消息分发</li><li>RabbitMQ消息路由机制分析</li><li>RabbitMQ消息确认机制</li></ol></blockquote></li><li><p>分布式缓存</p><blockquote><ol><li>从入门到精通，Redis的数据结构分析</li><li>Redis主从复制原理及无磁盘复制分析</li><li>Redis管道模式详解</li><li>Redis缓存与数据库一致性问题解决方案</li><li>基于Redis实现分布式锁实战</li><li>图解Redis中aof和rdb持久化策略的原理</li><li>Redis读写分离架构实践</li><li>Redis哨兵架构及数据丢失问题分析</li><li>Redis Cluster数据分布算法之Hash Slot</li><li>Redis使用常见问题及性能优化思路</li><li>Redis高可用及高伸缩架构实战</li><li>缓存击穿、缓存雪崩预防策略</li><li>Redis批量查询优化</li><li>Redis高性能集群之Twemproxy or Codis</li></ol></blockquote></li></ol><ol start="3"><li>数据存储<blockquote><ol><li>NoSQL简介及Mongodb基本概念</li><li>Mongodb支持的数据类型分析</li><li>Mongodb可视化客户端及Java API实践</li><li>手写基于Mongodb的orm框架</li><li>Mongodb企业级集群解决方案</li><li>Mongodb聚合、索引及基本执行命令</li><li>Mongodb数据分片、转存及恢复策略</li><li>MySQL主从复制及读写分离</li><li>MySQL+Keepalived实现双主高可用方案实践</li><li>MySQL高性能解决方案之分库分表</li><li>数据库中间件初识Mycat</li><li>基于Mycat实现MySQL数据库读写分离</li><li>基于Mycat实战之数据库切分策略剖析</li><li>Mycat全局表、E表、分片策略分析</li></ol></blockquote></li></ol><ol start="4"><li>后台服务<blockquote><ol><li>基于Openretry部署应用层Nginx以及Nginx+Lua实践</li><li>Nginx反向代理服务器及负载均衡服务配置实战</li><li>利用Keepalived+Nginx实践Nginx高可用方案</li><li>基于Nginx实现访问控制、连接限制</li><li>Nginx动静分离实战</li><li>Nginx Location，Rewrite等语法配置及原理分析</li><li>Nginx提供Https服务</li><li>基于Nginx+Lua完成访问流量实时上报Kafka的实战</li></ol></blockquote></li></ol><ol start="5"><li>高性能NIO框架<blockquote><ol><li>IO的基本概念、NIO、AIO、BIO深入分析</li><li>NIO的核心设计思想</li><li>Netty产生的背景及应用场景分析</li><li>基于Netty实现高性能lm聊天</li><li>基于Netty实现Dubbo多协议通信支持</li><li>Netty无锁串行化及高并发处理机制</li><li>手写实现多协议RPC框架</li></ol></blockquote></li></ol><h5 id="4-分布式解决方案"><a href="#4-分布式解决方案" class="headerlink" title="4. 分布式解决方案"></a>4. 分布式解决方案</h5><ol><li>分布式全局ID生成方案</li><li>Session跨域共享及企业级单点登录解决方案实战</li><li>分布式事务解决方案实战</li><li>高并发下的服务降级、限流实战</li><li>基于分布式架构下分布式锁的解决方案实战</li><li>分布式架构下实现分布式定时调度</li></ol><p>###5. 微服务架构</p><h5 id="1-微框架"><a href="#1-微框架" class="headerlink" title="1. 微框架"></a>1. 微框架</h5><ol><li>Spring Boot与微服务之间的关系</li><li>Spring Boot热部署实战</li><li>核心组件之Starter、Actuator、Auto-Configuration、Cli</li><li>Spring Boot集成Mybatis实现多数据源路由实战</li><li>Spring Boot集成Dubbo实战</li><li>Spring Boot集成Redis实战</li><li>Spring Boot集成Swagger2构建API管理及测试体系</li><li>Spring Boot实现多环境配置动态解析</li></ol><h5 id="2-SpringCloud"><a href="#2-SpringCloud" class="headerlink" title="2. SpringCloud"></a>2. SpringCloud</h5><ol><li>Eureka注册中心</li><li>Ribbon集成Rest实现负载均衡</li><li>Fegion声明式服务调用</li><li>Hystrix服务熔断降级方式</li><li>Zuul实现微服务网关</li><li>Config分布式统一配置中心</li><li>Sleuth调用链路跟踪</li><li>Blus消息总线</li><li>基于Hystrix实现接口降级实战</li><li>Spring Boot集成Spring Cloud实现统一整合方案</li></ol><h5 id="3-Docker虚拟化"><a href="#3-Docker虚拟化" class="headerlink" title="3. Docker虚拟化"></a>3. Docker虚拟化</h5><ol><li>了解Docker的镜像、仓库、容器</li><li>Dockerfile构建lnmp环境部署个人博客wordpress</li><li>Docker Compose构建lnmp环境部署个人博客wordpress</li><li>Docker网络组成、路由互联、Openvswitch</li><li>基于Swarm构建Docker集群实战</li><li>Kubernetes简介</li></ol><h5 id="4-漫谈微服务架构"><a href="#4-漫谈微服务架构" class="headerlink" title="4. 漫谈微服务架构"></a>4. 漫谈微服务架构</h5><ol><li>SOA架构和微服务架构之间的区别和联系</li><li>如何设计微服务及其设计原则</li><li>解惑Spring Boot流行因素及能够解决什么问题</li><li>什么事Spring Cloud，为何选择Spring Cloud</li><li>基于全局分析Spring Cloud各个组件所解决的问题</li></ol><p>###6. 电商项目实战</p><h5 id="1-用户认证系统（Passport）"><a href="#1-用户认证系统（Passport）" class="headerlink" title="1. 用户认证系统（Passport）"></a>1. 用户认证系统（Passport）</h5><ol><li><p>用户注册</p></li><li><p>用户登录</p><blockquote><ol><li>Sso单点登录</li><li>第三方登录</li></ol></blockquote></li><li><p>用户权限控制</p><blockquote><ol><li>UI页面拦截</li><li>业务方法拦截</li></ol></blockquote></li></ol><h5 id="2-搜索模块（大数据）"><a href="#2-搜索模块（大数据）" class="headerlink" title="2. 搜索模块（大数据）"></a>2. 搜索模块（大数据）</h5><h5 id="3-商品管理系统（Item）"><a href="#3-商品管理系统（Item）" class="headerlink" title="3. 商品管理系统（Item）"></a>3. 商品管理系统（Item）</h5><h5 id="4-订单系统（Order）"><a href="#4-订单系统（Order）" class="headerlink" title="4. 订单系统（Order）"></a>4. 订单系统（Order）</h5><h5 id="5-支付系统（Pay）"><a href="#5-支付系统（Pay）" class="headerlink" title="5. 支付系统（Pay）"></a>5. 支付系统（Pay）</h5><h5 id="6-数据统计分析系统（Anal）"><a href="#6-数据统计分析系统（Anal）" class="headerlink" title="6. 数据统计分析系统（Anal）"></a>6. 数据统计分析系统（Anal）</h5><h5 id="7-通知推送系统"><a href="#7-通知推送系统" class="headerlink" title="7. 通知推送系统"></a>7. 通知推送系统</h5><ol><li><p>融云推送</p><blockquote><ol><li>活动推送</li><li>交易信息推送</li><li>异常提醒</li></ol></blockquote></li><li><p>消息中间件</p><blockquote><ol><li>消息同步</li><li>消息处理</li></ol></blockquote></li></ol><h5 id="8-聊天系统"><a href="#8-聊天系统" class="headerlink" title="8. 聊天系统"></a>8. 聊天系统</h5><ol><li>用户群聊</li><li>点对点聊天</li><li>文件断点续传</li></ol><p>###7. 团队协作效率</p><h5 id="1-Maven-Gradle"><a href="#1-Maven-Gradle" class="headerlink" title="1. Maven/Gradle"></a>1. Maven/Gradle</h5><h5 id="2-Jenkins"><a href="#2-Jenkins" class="headerlink" title="2. Jenkins"></a>2. Jenkins</h5><h5 id="3-Sonar"><a href="#3-Sonar" class="headerlink" title="3. Sonar"></a>3. Sonar</h5><h5 id="4-Git"><a href="#4-Git" class="headerlink" title="4. Git"></a>4. Git</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-源码分析&quot;&gt;&lt;a href=&quot;#1-源码分析&quot; class=&quot;headerlink&quot; title=&quot;1. 源码分析&quot;&gt;&lt;/a&gt;1. 源码分析&lt;/h3&gt;&lt;h5 id=&quot;1-常用设计模式&quot;&gt;&lt;a href=&quot;#1-常用设计模式&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从Paxos到Zookeeper分布式一致性原理与实践</title>
    <link href="http://longman.kim/2018/07/15/%E4%BB%8EPaxos%E5%88%B0Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://longman.kim/2018/07/15/从Paxos到Zookeeper分布式一致性原理与实践/</id>
    <published>2018-07-15T10:27:30.000Z</published>
    <updated>2018-07-16T16:22:28.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式架构"><a href="#1-分布式架构" class="headerlink" title="1. 分布式架构"></a>1. 分布式架构</h3><ol><li>从集中式到分布式<blockquote><ol><li>集中式的特点<br>IBM的System/360系列大型主机是集中式计算机系统架构的代表，部署结构简单，单机性能卓越。  </li><li>分布式的特点<br>分布性，多台计算机在空间上随意分布，且机器的分布情况也会随时变动。<br>对等性，计算机之间没有主从之分，都是对等的。副本是分布式系统对数据和服务提供的一种冗余方式，数据副本解决数据丢失问题，服务副本使每个节点都能处理请求。<br>并发性，并发操作共享资源。缺乏全局时钟，很难定义两个事件究竟谁先谁后。故障总是会发生，一条黄金定理是设计时考虑到的异常情况一定会发生。    </li><li>分布式环境的各种问题<br>通信异常，网络光纤、路由器和DNS等硬件设备不可用导致通信异常，系统之间存在延时等。<br>网络分区，分布式系统中只有部分节点能够正常通信，而另一些节点不能，俗称脑裂，存在分布式一致性问题。<br>三态，成功、失败与超时，其中超时情况下无法确定请求是否成功。<br>节点故障，组成分布式系统的服务器节点出现的宕机或者僵死现象。</li></ol></blockquote></li></ol><ol start="2"><li>从ACID到CAP/BASE  <blockquote><ol><li>ACID<br>事务的四个特性。原子性，要么全部成功执行，要么全部不执行。一致性，数据库必须从一个一致性状态转变到另一个一致性状态，不存在事务对数据库的修改一部分已写入另一部没有。隔离性，并发的事务不能相互干扰。持久性，即事务一旦提交，对数据库中对于数据的状态变更就应该是永久性的。</li><li>事务的隔离性<br>未授权读取，最低级别，允许脏读。A事务对数据做了一系列修改但未提交，B事务可以看到数据这一系列的中间值。<br>授权读取，与未授权读取的区别是只允许获取已经被提交的数据，授权读取允许不可重复读。<br>可重复读取，保证在事务的处理过程中，多次读取同一个数据，其值都和事务开始时刻一致的，禁止了不可重复读取(一个事务中多次读取的数据不一样)和脏读（提交前读取，读取后发生回滚），但会出现幻读（读取之后另个一事务插入了新数据）。<br>串行化，要求所有的事务都被串行化执行，不能并发。<br>一般的做法是设置成授权读取，加上乐观锁或者悲观锁。    </li><li>分布式事务<br>事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。  </li><li>CAP和BASE理论<br>CAP理论告诉我们一个分布式系统不可能同时满足一致性（所有的数据都能都得到最新的值）、可用性（在有限时间内返回结果）和分区容错性（任何网络分区有故障仍然能提供一致性和可用性服务），最多只能同时满足其中的两项，其中分区容错性是必须保证的，只需要在一致性和可用性之间寻求平衡。<br>BASE，基本可用（损失部分功能，损失响应时间），弱状态（存在中间状态），最终一致性（经过一段时间后数据一致）。最终一致性的5类变体，因果一致性、读己之所写、会话一致性、单调读一致性、单调写一致性。</li></ol></blockquote></li></ol><h3 id="2-一致性协议"><a href="#2-一致性协议" class="headerlink" title="2. 一致性协议"></a>2. 一致性协议</h3><ol><li><p>2PC与3PC</p><blockquote><ol><li>2PC<br>提交事务请求，事务询问-&gt;执行事务-&gt;各参与者向协调者反馈事务询问的响应<br>执行事务提交，发送提交请求-&gt;事务提交-&gt;反馈事务提交结果-&gt;完成事务，发送回滚请求-&gt;事务回滚-&gt;反馈事务回滚结果-&gt;中断事务<br>原理简单，实现方便。同步阻塞，协调者的单点问题，脑裂，太过保守。  </li><li>3PC<br>阶段一CanCommit，事务询问-&gt;各参与者向协调者反馈事务询问的响应<br>阶段二PreCommit，执行事务预提交，发送预提交请求-&gt;事务预提交-&gt;各参与者向协调者反馈事务执行的响应。中断事务，发送中断请求-&gt;中断事务<br>阶段三doCommit，执行提交，发送提交请求-&gt;事务提交-&gt;反馈事务提交结果-&gt;完成事务。中断事务，发送中断请求-&gt;事务回滚-&gt;反馈事务回滚结果-&gt;中断事务。<br>存在数据不一致情况</li></ol></blockquote></li><li><p>Paxos算法</p><blockquote><ol><li>假设不存在拜占庭将军问题，即消息都是完整的，没有被篡改，在这种情况下提出了Paxos算法。Paxos小岛采用议会的形式通过法令，通过信使传递消息。  </li><li>问题描述，提案的选定，推导过程，数学归纳法证明，Proposer生成提案，Acceptor批准提案，算法优化，算法陈述</li></ol></blockquote></li></ol><h3 id="3-Paxos的工程实践"><a href="#3-Paxos的工程实践" class="headerlink" title="3. Paxos的工程实践"></a>3. Paxos的工程实践</h3><ol><li>Chubby</li><li>Hypertable</li></ol><h3 id="4-Zookeeper与Paxos"><a href="#4-Zookeeper与Paxos" class="headerlink" title="4. Zookeeper与Paxos"></a>4. Zookeeper与Paxos</h3><ol><li>初识Zookeeper</li><li>Zookeeper的ZAB协议</li></ol><h3 id="5-使用Zookeeper"><a href="#5-使用Zookeeper" class="headerlink" title="5. 使用Zookeeper"></a>5. 使用Zookeeper</h3><h3 id="6-Zookeeper的典型应用场景"><a href="#6-Zookeeper的典型应用场景" class="headerlink" title="6. Zookeeper的典型应用场景"></a>6. Zookeeper的典型应用场景</h3><h3 id="7-Zookeeper技术内幕"><a href="#7-Zookeeper技术内幕" class="headerlink" title="7. Zookeeper技术内幕"></a>7. Zookeeper技术内幕</h3><ol><li>系统模型  </li><li>序列化与协议</li><li>客户端</li><li>会话</li><li>服务器启动</li><li>Leader选举<blockquote><ol><li>Leader  </li><li>Follower  </li><li>Observer  </li><li>集群间消息通信  </li></ol></blockquote></li><li>各服务器角色介绍</li><li>请求处理</li><li>数据与存储</li></ol><h3 id="8-Zookeeper运维"><a href="#8-Zookeeper运维" class="headerlink" title="8. Zookeeper运维"></a>8. Zookeeper运维</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式架构&quot;&gt;&lt;a href=&quot;#1-分布式架构&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式架构&quot;&gt;&lt;/a&gt;1. 分布式架构&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;从集中式到分布式&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;集中式的特点&lt;br&gt;IB
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机行业职业发展路线的一些思考</title>
    <link href="http://longman.kim/2018/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://longman.kim/2018/07/15/计算机行业职业发展路线的一些思考/</id>
    <published>2018-07-15T01:54:54.000Z</published>
    <updated>2018-07-15T09:02:04.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>想想自己在计算机行业待了快9年了（本科4年，研究生3年，工作2年），对这个行业却只能说是初步了解。读书期间很抵触做网站，但自己却一个网站都没有搭起来过。那时候很崇拜算法，但没有深入学习，算法也是普通人的水平。现在我工作2年了，从事网站后台开发，却依然是菜鸟级别。技术水平菜，为人处世又不成熟，所以过得让自己不开心，也让身边的人不开心。自命清高，眼高手低，也许说的就是我这种人吧。努力想改变这种状态，却依然在网络上寻找灵丹妙药。其实网上有很多建议，但可能只针对部分人有用，因为每个人自身的情况，所处的环境都不相同。小人常立志，圣人立长志，这句话是从亲人身上学到的。人应该有个目标，然后有自制力的执行自己的目标。有志者，事竟成，破釜沉舟，百二秦关终属楚，苦心人，天不负，卧薪尝胆，三千越甲可吞吴。</p><h3 id="2-行业的预见"><a href="#2-行业的预见" class="headerlink" title="2. 行业的预见"></a>2. 行业的预见</h3><p>我预见计算机行业未来将只会存在设计师、全栈开发工程师、算法工程师、硬件工程师。  </p><ol><li><strong><em>设计师</em></strong><br>人，希望自己独一无二，希望自己美丽漂亮。对美的追求植根于所有人的心中，设计师是将思想化为现实的桥梁，他们需要灵感。设计师就是艺术家，艺术家是为了洗涤人的精神世界，无形而威力巨大。  </li><li><strong><em>全栈开发</em></strong><br>随着技术的不断发展，网站开发的需求量会逐渐减少。到最后，会被云计算公司，类似于亚马逊、微软、阿里巴巴这样的公司所垄断。普通的前端后端开发工程师将会非常被动，因为普通公司的网站都交给那些大型巨头做了，中小型公司不需要自己的IT部门。以后对于普通网站开发的需求，应该是中大型公司，他们要求全栈开发并且对某个行业业务深入了解的人，即会IT技能的业务专家。  </li><li><strong><em>算法工程师</em></strong><br>程序=算法+数据结构，算法是计算机的精髓。从通用的算法（排序，查找等），到AI算法（推荐、学习），算法一直阐述着计算机科学的未来发展之路。  </li><li><strong><em>硬件工程师</em></strong><br>软硬结合，传感器，物联网。从芯片，到外围电路，未来是软硬结合的世界。</li></ol><h3 id="3-个人的发展之路"><a href="#3-个人的发展之路" class="headerlink" title="3. 个人的发展之路"></a>3. 个人的发展之路</h3><ol><li>初级开发工程师  </li><li>中级开发工程师</li><li>高级开发工程师  </li><li>组长  </li><li>室经理  </li><li>部门经理</li><li>CTO  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;想想自己在计算机行业待了快9年了（本科4年，研究生3年，工作2年），对这个行业却只能说是初步了解。读书期间很抵触做网站，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>国内主流互联网公司的RPC和MOM</title>
    <link href="http://longman.kim/2018/07/12/%E5%9B%BD%E5%86%85%E4%B8%BB%E6%B5%81%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84RPC%E5%92%8CMOM/"/>
    <id>http://longman.kim/2018/07/12/国内主流互联网公司的RPC和MOM/</id>
    <published>2018-07-12T09:48:59.000Z</published>
    <updated>2018-07-23T12:14:16.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-RPC服务框架"><a href="#1-RPC服务框架" class="headerlink" title="1. RPC服务框架"></a>1. RPC服务框架</h3><ol><li><p>Dubbo(阿里)</p><blockquote><ol><li>架构<br>Provider(Container), Conumer, Registry, Monitor</li><li>通讯协议<br>2.1 dubbo的特性是连接个数单连接，连接方式长连接，传输协议TCP，传输方式NIO异步通讯，序列化Hessian二进制序列化，适用范围数据包小，消费者比提供者个数多，dubbo不适合传输大数据量的服务。<br>2.2 rmi的特性是多连接，短连接，TCP，同步传输，Java标准二进制序列化，数据包大小混合，消费者和提供者个数差不多。<br>2.3 hessian的特性是多连接，短连接，http，同步传输，hessian二进制序列化，数据包较大，提供者比消费者个数多，可传文件。<br>2.4 http的特性是多连接，短连接，http，同步传输，表单序列化，数据包大小混合，提供者比消费者个数多，不支持传文件。<br>2.5 webservice的特性是多连接，短连接，http，同步传输，SOAP文本序列化。<br>2.6 其他协议thrift、memcached、redis、rest</li><li>注册中心<br>3.1 Zookeeper,临时节点原理<br>3.2 Multicast<br>3.3 Redis<br>3.4 Simple</li><li>集群容错<br>4.1 FailOver<br>读操作的默认方式，失败自动切换，重试其他服务。<br>4.2 FailFast<br>写操作的默认方法，快速失败，只发起一次调用，失败立即报错。<br>4.3 FailBack<br>消息通知，失败自动恢复，记录失败请求，定时重发。<br>4.4 Forking<br>并行调用多个服务器，只要一个成功即可。<br>4.5 Broadcast<br>广播调用所有提供者，任意一台报错则报错。<br>4.6 Failsafe<br>失败安全，出现异常时，直接忽略，常用在写审计日志。</li><li>其他特点<br>5.1 使用微内核+插件技术，利用SPI(ServiceProviderInterface)技术+策略模式，使得Dubbo扩展性极强。<br>5.2 常用配置<br>dubbo:application, dubbo:registry, dubbo:protocol, dubbo:service, dubbo:reference  </li><li>启动流程<br>6.1 服务容器负责启动，加载，运行服务提供者。<br>6.2 服务提供者在启动时，向注册中心注册自己提供的服务。<br>6.3 服务消费者在启动时，向注册中心订阅自己所需的服务。<br>6.4 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>6.5 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者调用，如果调用失败，再选另一台。<br>6.6 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发一次统计数据到监控中心。  </li></ol></blockquote></li><li><p>HSF(阿里)</p></li><li>pigeon(美团点评)</li><li>rdsn(小米)</li><li>motan(微博)</li><li>gRPC(谷歌)</li><li>thrift(脸书)</li><li>tars(腾讯)</li><li>brpc(百度)</li><li>SpringCloud</li></ol><h3 id="2-MOM消息中间件"><a href="#2-MOM消息中间件" class="headerlink" title="2. MOM消息中间件"></a>2. MOM消息中间件</h3><ol><li><p>RocketMQ(阿里)</p><blockquote><ol><li></li></ol></blockquote></li><li><p>QService(微博)</p></li><li>Kafka</li><li><p>RabbitMQ</p><blockquote><ol><li></li></ol></blockquote></li><li><p>ActiveMQ</p></li><li>ZeroMQ</li><li>Redis</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-RPC服务框架&quot;&gt;&lt;a href=&quot;#1-RPC服务框架&quot; class=&quot;headerlink&quot; title=&quot;1. RPC服务框架&quot;&gt;&lt;/a&gt;1. RPC服务框架&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Dubbo(阿里)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站技术架构-核心原理与案例分析</title>
    <link href="http://longman.kim/2018/07/11/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://longman.kim/2018/07/11/大型网站技术架构-核心原理与案例分析/</id>
    <published>2018-07-11T12:02:57.000Z</published>
    <updated>2018-07-13T04:17:49.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-大型网站架构演进"><a href="#1-大型网站架构演进" class="headerlink" title="1. 大型网站架构演进"></a>1. 大型网站架构演进</h3><ol><li><p>大型网站软件系统的特点</p><blockquote><p>高并发，大流量，高可用，海量数据，用户分布广泛，网络情况复杂，安全环境恶劣，需求快速变更，发布频繁，渐进式发展  </p></blockquote></li><li><p>大型网站架构演化发展历程</p><blockquote><ol><li>初始阶段<br>LAMP单机</li><li>应用服务和数据服务分离  </li><li>使用缓存改善网站性能  </li><li>使用应用服务器集群改善网站的并发处理能力</li><li>数据库读写分离</li><li>使用反向代理和CDN加速网站响应  </li><li>使用分布式文件系统和分布式数据库系统</li><li>使用NoSQL和搜索引擎</li><li>业务拆分</li><li>分布式服务</li></ol></blockquote></li><li><p>大型网站架构演化的价值观</p><blockquote><ol><li>网站所需灵活应对</li><li>业务发展是驱动力</li></ol></blockquote></li><li><p>网站架构设计误区</p><blockquote><ol><li>一味追求大公司的解决方案</li><li>为了技术而技术</li><li>企图用技术解决所有问题</li></ol></blockquote></li></ol><h3 id="2-大型网站结构模式"><a href="#2-大型网站结构模式" class="headerlink" title="2. 大型网站结构模式"></a>2. 大型网站结构模式</h3><ol><li><p>网站架构模式</p><blockquote><ol><li>分层<br>应用层，服务层，数据层  </li><li>分割  </li><li>分布式<br>分布式应用和服务，分布式静态资源，分布式数据和存储，分布式计算，分布式配置，分布式锁，分布式文件系统</li><li>集群</li><li>缓存<br>CDN，反向代理，本地缓存，分布式缓存</li><li>异步<br>解耦，异步模式，生产者消费者，提高可用性，加快响应速度，消除并发访问高峰</li><li>冗余<br>冷备份，热备份，灾备数据中心</li><li>自动化<br>发布过程自动化，自动化代码管理，自动化测试，自动化安全检测，自动化部署，自动化监控，自动化报警，自动化失效转移，自动化失效恢复，自动化降级，自动化资源分配</li><li>安全<br>密码，手机校验码，加密，XSS攻击，SQL注入，信息过滤，风险控制</li></ol></blockquote></li><li><p>架构模式在新浪微博的应用</p><blockquote><ol><li>LAMP</li><li>基础服务层：数据库，缓存，存储，搜索</li><li>平台服务和应用服务</li><li>API和业务层</li><li>分布式部署，集群，异步推拉结合，多级缓存，冗余，自动化，安全</li></ol></blockquote></li></ol><h3 id="3-大型网站核心架构要素"><a href="#3-大型网站核心架构要素" class="headerlink" title="3. 大型网站核心架构要素"></a>3. 大型网站核心架构要素</h3><p>最高层次的规划，难以改变的决定</p><ol><li>性能<blockquote><ol><li>浏览器端，浏览器缓存，页面压缩，合理布局，减少cookie传输</li><li>CDN，动静分离，部署反向代理，缓存热点文件</li><li>服务端，本地缓存，分布式缓存，异步消息队列，集群，多线程，改善内存管理</li><li>数据库，索引，缓存，SQL优化，NoSQL</li><li>响应时间，TPS</li></ol></blockquote></li><li>可用性<blockquote><ol><li>7*24小时可用，4个9即99.99%可用</li><li>主要是手段是冗余</li><li>应用服务器，负载均衡，集群</li><li>存储服务器，实时备份</li></ol></blockquote></li><li>伸缩性<blockquote><ol><li>应用服务器用合适的负载均衡器向集群中加机器</li><li>缓存服务器，改进缓存路由算法，保证缓存的可访问性</li><li>关系数据库支持数据复制，主从热备等机制，但很难保证大规模的伸缩性。主要通过路由分区将多个数据库的服务器组成一个集群。NoSQL比较好扩展。</li></ol></blockquote></li><li>扩展性<blockquote><p>如何设计网站的架构使其能够快速响应需求的变化。</p><ol><li>事件驱动架构<br>消息队列</li><li>分布式服务<br>将业务和可复用服务分离，通过分布式服务框架调用。</li></ol></blockquote></li><li>安全性<blockquote><p>保护数据</p></blockquote></li></ol><h3 id="4-瞬时响应：网站的高性能架构"><a href="#4-瞬时响应：网站的高性能架构" class="headerlink" title="4. 瞬时响应：网站的高性能架构"></a>4. 瞬时响应：网站的高性能架构</h3><ol><li>网站性能测试<blockquote><ol><li>响应时间，请求开始到收到响应所需的时间</li><li>并发数，系统能够同时处理请求的数目</li><li>吞吐量，TPS（每秒事务数），QPS（每秒查询数），HPS（每秒HTTP请求数）</li><li>性能技术器<br>系统负载，对象与线程数，内存使用，CPU使用，磁盘与网络I/O</li><li>性能测试方法<br>性能测试，负载测试（直到处理能力下降），压力测试（直到系统崩溃或不能处理任何请求），稳定性测试（不同环境）</li></ol></blockquote></li><li>Web前端性能优化<blockquote><ol><li>减少http请求</li><li>使用浏览器缓存</li><li>启用压缩</li><li>css放在页面最上面，javasript放在页面最下面</li><li>减少cookie传输</li><li>CDN缓存静态资源</li><li>反向代理缓存</li></ol></blockquote></li><li>应用服务器性能优化<blockquote><ol><li>分布式缓存<br>Hash表，读多写少，二八定律</li><li>合理使用缓存<br>频繁修改的数据不适合缓存，非热点数据不适合缓存，可能存在数据不一致和脏读，缓存的可用性，缓存利用LRU(最近最久未用算法)，缓存预热，缓存穿透</li><li>分布式缓存架构<br>更新同步的缓存（与应用部署在一起），互不通信的缓存（与应用部署在不同的服务器，采用Hash一致性算法可伸缩）。Memcached采用TCP通信，序列化协议基于文本的自定义，网络通信基于libevent，内存管理使用固定空间分配，存储时根据数据的size寻找一个大于size的最小的chunk，互不通信的服务器集群架构。</li><li>异步操作<br>使用消息队列</li><li>使用集群<br>负载均衡</li><li>代码优化<br>多线程，线程安全（将对象设计为无状态对象，使用局部对象，并发访问资源时使用锁），资源复用（单例模式，线程池），数据结构，垃圾回收</li></ol></blockquote></li><li>存储性能优化<blockquote><ol><li>机械硬盘和固态硬盘</li><li>B+树和LSM树</li><li>RAID（廉价磁盘冗余阵列）和HDFS（MapReduce）</li></ol></blockquote></li></ol><h3 id="5-网站的高可用架构"><a href="#5-网站的高可用架构" class="headerlink" title="5. 网站的高可用架构"></a>5. 网站的高可用架构</h3><ol><li>网站可用性的度量与考核<blockquote><p>网站不可用时间，网站年度可用性指标（多少个9）</p></blockquote></li><li>高可用的网站架构<blockquote><p>保证服务器硬件故障时服务依然可用、数据依然保存并能够被访问，手段主要是数据和服务的冗余备份及失效转移。应用层使用负载均衡应对高并发，心跳机制将问题服务器从集群中剔除。服务层使用RPC框架，在客户端使用软负载均衡，服务注册中心剔除不可用服务器。数据层需要写入数据时同步复制，实现数据冗余。</p></blockquote></li><li>高可用的应用<blockquote><ol><li>无状态应用</li><li>使用负载均衡进行失效转移</li><li>session管理的发展，seesion复制-&gt;session绑定(hash)-&gt;利用cookie记录session-&gt;session服务器</li></ol></blockquote></li><li>高可用的服务<blockquote><ol><li>服务器分级管理，物理机&gt;虚拟机，线程隔离</li><li>超时设置</li><li>异步调用</li><li>服务降级，拒绝服务，关闭功能</li><li>幂等设计</li></ol></blockquote></li><li>高可用的数据<blockquote><ol><li>数据多备份，实现持久化，并在失效时，快速切换访问数据的副本。</li><li>整个网站共享同一个分布式缓存集群</li><li>CAP原理，优先保证AP，数据一致性保证最终一致性</li><li>数据冷备采用定期备份，不能保证最终一致性，不能保证数据可用性。数据热备分为异步热备（成功写一份，异步写其他副本）和同步热备（多份数据副本同步写入）。关系数据库热备使用master，slave同步机制。读写分离，只写master，只读slave。</li><li>失效转移（将宕机服务器的读写请求路由到其他服务器）。失效确认，应用程序访问失败报告和控制中心的心跳检测。访问转移，重新路由，需要考虑存储不对等的情况。数据恢复，数据复制。</li></ol></blockquote></li><li>高可用网站的软件质量保证<blockquote><ol><li>网站发布<br>发布过程中，每次关闭集群中的一小部分服务器，发布完后可以立即访问，不影响用户</li><li>自动化测试<br>自动化测试工具Selenium</li><li>预发布验证<br>预发布服务器没有配置在负载均衡器上，只运行开发和测试访问。处理错误的一个理念是快速失败。</li><li>代码控制<br>分支开发，主干发布</li><li>自动化发布<br>固定发布日期</li><li>灰度发布<br>每天发布一部分服务器</li></ol></blockquote></li><li>网站运行监控<blockquote><p>不允许没有监控的服务上下</p><ol><li>监控数据采集<br>服务器端日志收集，客户端浏览器日志收集，实时计算框架storm的日志统计与分析，服务器性能监控（系统load、内存占用、磁盘IO、网络IO）Ganglia，运行数据报告（缓存命中率、平均响应延迟时间、待处理任务总数）</li><li>监控管理<br>系统报警，失效转移，自动优雅降级</li></ol></blockquote></li></ol><h3 id="6-永无止境：网站的伸缩性架构"><a href="#6-永无止境：网站的伸缩性架构" class="headerlink" title="6. 永无止境：网站的伸缩性架构"></a>6. 永无止境：网站的伸缩性架构</h3><ol><li><p>网站架构的伸缩性设计</p><blockquote><ol><li>不同功能进行物理分隔实现伸缩<br>纵向分离（分层后分离），横向分离（业务分隔后分离）</li><li>单一功能通过集群规模实现伸缩</li></ol></blockquote></li><li><p>应用服务器集群的伸缩性设计</p><blockquote><ol><li>HTTP重定向负载均衡，返回浏览器302</li><li>DNS域名解析负载均衡，一个域名多个IP</li><li>反向代理负载均衡，应用层（HTTP）负载均衡</li><li>IP负载均衡，修改目的地址的IP</li><li>数据链路层负载均衡，直接路由方式（DR），不修改IP修改MAC，LVS工作在这层</li><li>负载均衡算法<br>轮训（Round Robin, RR），加权轮训（Weighted Round Robin, WRR），随机，最少连接，源地址散列（hash）</li></ol></blockquote></li><li>分布式缓存集群的伸缩性设计<blockquote><p>新加入缓存服务器后使整个缓存服务器集群中已经缓存的数据尽可能还被访问到。</p><ol><li>Memcached分布式缓存集群的访问机制</li><li>分布式缓存的一致性Hash算法，虚拟节点</li></ol></blockquote></li><li>数据存储服务器集群的伸缩性设计<blockquote><ol><li>关系数据库集群的伸缩性设计<br>数据分库，跨库的表不能进行Join操作。进行了分库和主从复制后，单表数据仍很大，需要将一张表拆开分别存储在多个数据库中，即分片。支持数据分片的分布式数据库产品主要有Amoeba和Cobar。Cobar做负载均衡，MySQL做数据迁移。避免事务或者利用补偿机制代替数据库事务，分解数据访问逻辑避免JOIN操作。</li><li>NoSQL数据库的伸缩性设计<br>HBase的架构，HBase依赖可分裂的HRegion以及可伸缩的分布式文件系统HDFS。Zookeeper，HMaster，HRegionServer，HRegion。</li></ol></blockquote></li></ol><h3 id="7-随需应变：网站的可扩展架构"><a href="#7-随需应变：网站的可扩展架构" class="headerlink" title="7. 随需应变：网站的可扩展架构"></a>7. 随需应变：网站的可扩展架构</h3><ol><li>构建可扩展的网站架构<blockquote><p>扩展性（开闭原则，对扩展开放，对修改关闭），伸缩性（增加资源规模提高系统处理能力），模块化，降低模块之间的耦合</p></blockquote></li><li>利用分布式消息队列降低系统耦合性<blockquote><ol><li>事件驱动架构<br>生成者消费者模式就是常见的事件驱动模式，分布式消息队列。</li><li>分布式消息队列<br>FIFO，通过消息对象分解系统耦合性</li></ol></blockquote></li><li>利用分布式服务打造可复用的业务平台<blockquote><p>通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用</p><ol><li>WebService与企业级分布式服务</li><li>大型网站分布式服务的需求与特点<br>负载均衡，失效转移，高效的远程通信，整合异构系统，对应用最少侵入，版本管理，实时监控</li><li>分布式服务框架设计<br>Dubbo，服务框架客户端，服务注册中心，负载均衡策略，服务提供者</li></ol></blockquote></li><li>可扩展的数据结构<blockquote><p>关系数据库的schema，NoSQL的ColumnFamily</p></blockquote></li><li>利用开放平台建设网站生态圈<blockquote><ol><li>API接口</li><li>协议转换</li><li>安全</li><li>审计</li><li>路由</li><li>流程</li></ol></blockquote></li></ol><h3 id="8-固若金汤：网站的安全架构"><a href="#8-固若金汤：网站的安全架构" class="headerlink" title="8. 固若金汤：网站的安全架构"></a>8. 固若金汤：网站的安全架构</h3><ol><li>网站应用攻击与防御<blockquote><ol><li>XSS攻击<br>反射型，嵌入恶意脚本的链接，持久型，黑客提交恶意脚本到正常页面。防护手段有消毒，即对危险字符进行转义。HttpOnly，禁止访问cookie。</li><li>注入攻击<br>SLQ注入攻击，在请求中注入恶意SQL命令。黑客获取数据库结构的手段，开源，错误回显，盲注。防护手段有消毒，正则匹配过滤SQL。参数绑定，预编译。</li><li>CSRF攻击<br>通过跨站请求，以合法身份进行非法操作，其核心是利用了浏览器的cookie或者服务器的session策略，盗用用户身份。防御手段有表单token，验证码，referer check。</li><li>其他攻击和漏洞<br>error code，HTML注释，文件上传，路径遍历</li><li>Web应用防火墙<br>ModSecurity</li><li>网站安全漏洞扫描</li></ol></blockquote></li><li>信息加密技术及密钥安全管理<blockquote><ol><li>单向散列加密<br>密码保存与验证，加盐salt增加破解难度，MD5，SHA</li><li>对称加密<br>DES算法，RC算法</li><li>非对称加密算法<br>RSA算法，HTTPS里面的数字证书</li><li>密钥安全管理<br>密钥和算法放在独立的服务器上甚至做出专用硬件，加解密算法放在应用中，密钥放在独立的服务器中，密钥分片存储</li></ol></blockquote></li><li>信息过滤与反垃圾<blockquote><ol><li>文本匹配<br>正则匹配，Tri树，多级Hash表</li><li>分类算法<br>朴素贝叶斯分类，聚类挖掘</li><li>黑名单</li></ol></blockquote></li><li>电子商务风险控制<blockquote><ol><li>风险<br>账户风险，买家风险，卖家风险，交易风险</li><li>风控<br>规则引擎，统计模型</li></ol></blockquote></li></ol><h3 id="9-淘宝网的架构演化案例分析"><a href="#9-淘宝网的架构演化案例分析" class="headerlink" title="9. 淘宝网的架构演化案例分析"></a>9. 淘宝网的架构演化案例分析</h3><h3 id="10-维基百科的高性能架构设计分析"><a href="#10-维基百科的高性能架构设计分析" class="headerlink" title="10. 维基百科的高性能架构设计分析"></a>10. 维基百科的高性能架构设计分析</h3><h3 id="11-海量分布式存储系统Doris的高可用架构设计分析"><a href="#11-海量分布式存储系统Doris的高可用架构设计分析" class="headerlink" title="11. 海量分布式存储系统Doris的高可用架构设计分析"></a>11. 海量分布式存储系统Doris的高可用架构设计分析</h3><h3 id="12-网购秒杀系统架构设计案例分析"><a href="#12-网购秒杀系统架构设计案例分析" class="headerlink" title="12. 网购秒杀系统架构设计案例分析"></a>12. 网购秒杀系统架构设计案例分析</h3><h3 id="13-大型网站典型故障案例分析"><a href="#13-大型网站典型故障案例分析" class="headerlink" title="13. 大型网站典型故障案例分析"></a>13. 大型网站典型故障案例分析</h3><h3 id="14-架构师领导艺术"><a href="#14-架构师领导艺术" class="headerlink" title="14. 架构师领导艺术"></a>14. 架构师领导艺术</h3><h3 id="15-网站架构师职场攻略"><a href="#15-网站架构师职场攻略" class="headerlink" title="15. 网站架构师职场攻略"></a>15. 网站架构师职场攻略</h3><h3 id="16-漫话网站架构师"><a href="#16-漫话网站架构师" class="headerlink" title="16. 漫话网站架构师"></a>16. 漫话网站架构师</h3><h3 id="附录A-大型网站架构技术一览"><a href="#附录A-大型网站架构技术一览" class="headerlink" title="附录A 大型网站架构技术一览"></a>附录A 大型网站架构技术一览</h3><h3 id="附录B-Web开发技术发展历程"><a href="#附录B-Web开发技术发展历程" class="headerlink" title="附录B Web开发技术发展历程"></a>附录B Web开发技术发展历程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-大型网站架构演进&quot;&gt;&lt;a href=&quot;#1-大型网站架构演进&quot; class=&quot;headerlink&quot; title=&quot;1. 大型网站架构演进&quot;&gt;&lt;/a&gt;1. 大型网站架构演进&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;大型网站软件系统的特点&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七周七并发模型</title>
    <link href="http://longman.kim/2018/07/09/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://longman.kim/2018/07/09/七周七并发模型/</id>
    <published>2018-07-08T17:24:59.000Z</published>
    <updated>2018-07-08T17:24:59.670Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七周七数据库</title>
    <link href="http://longman.kim/2018/07/09/%E4%B8%83%E5%91%A8%E4%B8%83%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://longman.kim/2018/07/09/七周七数据库/</id>
    <published>2018-07-08T17:23:10.000Z</published>
    <updated>2018-07-08T17:24:21.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-PostgreSQL"><a href="#1-PostgreSQL" class="headerlink" title="1. PostgreSQL"></a>1. PostgreSQL</h3><h3 id="2-Riak"><a href="#2-Riak" class="headerlink" title="2. Riak"></a>2. Riak</h3><h3 id="3-Hbase"><a href="#3-Hbase" class="headerlink" title="3. Hbase"></a>3. Hbase</h3><h3 id="4-mongodb"><a href="#4-mongodb" class="headerlink" title="4. mongodb"></a>4. mongodb</h3><h3 id="5-CouchDB"><a href="#5-CouchDB" class="headerlink" title="5. CouchDB"></a>5. CouchDB</h3><h3 id="6-Neo4j"><a href="#6-Neo4j" class="headerlink" title="6. Neo4j"></a>6. Neo4j</h3><h3 id="7-Redis"><a href="#7-Redis" class="headerlink" title="7. Redis"></a>7. Redis</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-PostgreSQL&quot;&gt;&lt;a href=&quot;#1-PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;1. PostgreSQL&quot;&gt;&lt;/a&gt;1. PostgreSQL&lt;/h3&gt;&lt;h3 id=&quot;2-Riak&quot;&gt;&lt;a href=&quot;#2-Ria
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AWS认证考试（云技术架构师）</title>
    <link href="http://longman.kim/2018/07/09/AWS%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95%EF%BC%88%E4%BA%91%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%B8%88%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/09/AWS认证考试（云技术架构师）/</id>
    <published>2018-07-08T17:03:18.000Z</published>
    <updated>2018-07-08T17:03:18.590Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://longman.kim/2018/07/08/Zookeeper/"/>
    <id>http://longman.kim/2018/07/08/Zookeeper/</id>
    <published>2018-07-08T13:55:34.000Z</published>
    <updated>2018-07-11T11:15:39.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Zookeeper是什么？"><a href="#1-Zookeeper是什么？" class="headerlink" title="1. Zookeeper是什么？"></a>1. Zookeeper是什么？</h3><p>Zookeeper是一个分布式的分布式应用程序协调服务，它为分布式应用提供一致性服务，功能包括：配置维护、域名服务、分布式同步、组服务等，提供的接口主要有分布式独享锁、选举、队列。</p><h3 id="2-Zookeeper的架构与组成"><a href="#2-Zookeeper的架构与组成" class="headerlink" title="2. Zookeeper的架构与组成"></a>2. Zookeeper的架构与组成</h3><ol><li>类似于文件系统，多叉树的结构，每个节点znode的大小&lt;1M。Zookeeper服务由多个互相通信的Server构成，其中有一个Server是leader。当leader挂了之后，会重新选择一个新的leader。</li><li>普通的Server能处理read和watch请求，只有leader能处理write请求。因此，当普通Server收到write请求时，它会将请求重定向到leader。Client配置所有Server的列表，但只会选择其中的一个Server进行连接。</li><li>当Client连接的Server挂了之后，Client会重新选择一个Server，建立新的会话。</li><li>update操作必须严格有序执行，对每一个操作都有对应的交易ID。</li><li>Zookeeper中的数据保存在内存，写操作先写磁盘再写内存，更新操作先写更新记录到磁盘再更新内存。</li><li>读写比是10:1时，zookeeper表现最好。  </li><li>zookeeper中不使用相对路径。</li><li>znode中有修改的版本号，ACL的版本号，时间戳等。修改znode时，要对版本号进行核对。</li><li>Zookeeper中ACL控制不是递归的，能访问父节点不一定能访问子节点。<h3 id="3-Fast-Paxos算法，ZAB算法"><a href="#3-Fast-Paxos算法，ZAB算法" class="headerlink" title="3. Fast Paxos算法，ZAB算法"></a>3. Fast Paxos算法，ZAB算法</h3></li><li><strong><em>数据修改</em></strong><br>ZAB(Zookeeper Atomic Broadcast)原子广播协议，是2PC(两阶段提交)协议的变体。<br>1.1  follower收到write请求后，将请求重定向到leader。<br>1.2  leader将write请求（携带序列号64位，前32位SID（服务器的唯一标识）和后32位ZXID（事务ID））广播给follower。<br>1.3  follower将write请求放在history队列里面，然后回复ACK给leader。<br>1.4  leader收到一半的ACK后，广播commit给follower。<br>1.5  follower收到commit请求后，如果发现这个交易的序列号在history队列里面是最小的，就执行该请求。如果发现这个交易的序列号不是最小的，需要等待小的序列号执行commmit后，才执行这个大序列号的交易。</li><li><strong><em>leader挂了后的选举</em></strong><br>服务器如果无法和leader连接时进入leader选举状态，称为looking状态。looking状态的机器会向集群中所有的机器发起投票。投票包含该服务器最近的序列号(sid, zxid)和选举轮次。最开始都投自己，然后比较接收到的序列号（先比较zxid，再比较sid），投给最大序列号对应的服务器，两轮就能确定。</li><li><strong><em>初始化数据恢复</em></strong><br>确保那些在leader服务器上提交的事务最终被执行，丢弃那些只在leader服务器被提出的事务。选择leader完成后，followers发送自己接收的最大zxid的epoch给leader。leader从接收到的epoch中，选择最大的并加1，发送给follower。follower接收到epoch之后，更新自己的epoch。然后将自己的history历史事务集反馈给leader。leader在收到过半的反馈后，从收到的反馈中选择epoch最大，同时zxid最大的follower的事务集合作为初始化事务集合。leader将初始化集合发给follower，follower接收并处理事务集，反馈给leader，leader收到反馈后发送commit。</li><li><strong><em>client挂了后的处理</em></strong><br>zookeeper允许client创建两种类型的节点：persistent, ephemeral，ephemeral类型的节点与client一起共存亡。客户端与follower连接时，会创建一个session, follower和leader都保存了session信息。client定期向follower发送ping包，证明自己活着。leader定期向follower发送ping包，检查是否有超过一半的follower还活着，同时follower会返回session，告诉leader哪些client还活着，这样leader就可以删除不错在客户端的ephemeral节点，ephemeral不允许有children。</li></ol><h3 id="4-动物园管理员（Zookeeper）的故事"><a href="#4-动物园管理员（Zookeeper）的故事" class="headerlink" title="4. 动物园管理员（Zookeeper）的故事"></a>4. 动物园管理员（Zookeeper）的故事</h3><h3 id="5-优点与缺点"><a href="#5-优点与缺点" class="headerlink" title="5. 优点与缺点"></a>5. 优点与缺点</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Zookeeper是什么？&quot;&gt;&lt;a href=&quot;#1-Zookeeper是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Zookeeper是什么？&quot;&gt;&lt;/a&gt;1. Zookeeper是什么？&lt;/h3&gt;&lt;p&gt;Zookeeper是一个分布式的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://longman.kim/2018/07/08/Kafka/"/>
    <id>http://longman.kim/2018/07/08/Kafka/</id>
    <published>2018-07-08T13:32:30.000Z</published>
    <updated>2018-07-13T16:21:42.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Kalfka？"><a href="#1-什么是Kalfka？" class="headerlink" title="1. 什么是Kalfka？"></a>1. 什么是Kalfka？</h3><p>由Scala和Java编写，开源流处理平台，高吞吐量的分布式发布订阅消息系统。</p><h3 id="2-Kalka的各种组件"><a href="#2-Kalka的各种组件" class="headerlink" title="2. Kalka的各种组件"></a>2. Kalka的各种组件</h3><p>Broker，Kafka集群中包含的服务器。<br>Topic,每条发布到Kafka集群中的消息都有一个类别即Topic。不同Topic物理上分开存储，逻辑上一个Topic的消息虽然保存于一个或多个Broker上，但用户只需要指定消息的Topic即可生产或消费。<br>Partition，物理上每个Topic包含一个或多个Partition。<br>Producer，发布消息到Kafka的broker。<br>Consumer，向Kafka读取消息的客户端。<br>Consumer Group，每个Consumer属于一个特定的Consumer Group。<br>Offset，kafka的存储文件按照offset.kafka来命名，方便查找。例如1025的位置只要找到1024.kafka的文件即可，第一个文件是0000000.kafka。</p><h3 id="3-offset的角色"><a href="#3-offset的角色" class="headerlink" title="3. offset的角色"></a>3. offset的角色</h3><h3 id="4-consumer-group是什么"><a href="#4-consumer-group是什么" class="headerlink" title="4. consumer group是什么"></a>4. consumer group是什么</h3><h3 id="5-Zookeeper的角色"><a href="#5-Zookeeper的角色" class="headerlink" title="5. Zookeeper的角色"></a>5. Zookeeper的角色</h3><p>通过Zookeeper来协调broker，例如broker的新增或者失效，Zookeeper将通知生成者和消费者</p><h3 id="6-Kalka可以不使用Zookeeper吗"><a href="#6-Kalka可以不使用Zookeeper吗" class="headerlink" title="6. Kalka可以不使用Zookeeper吗"></a>6. Kalka可以不使用Zookeeper吗</h3><h3 id="7-leader和follower的概念"><a href="#7-leader和follower的概念" class="headerlink" title="7. leader和follower的概念"></a>7. leader和follower的概念</h3><h3 id="8-复制和ISR的角色"><a href="#8-复制和ISR的角色" class="headerlink" title="8. 复制和ISR的角色"></a>8. 复制和ISR的角色</h3><h3 id="9-复制在Kafka中的重要性"><a href="#9-复制在Kafka中的重要性" class="headerlink" title="9. 复制在Kafka中的重要性"></a>9. 复制在Kafka中的重要性</h3><h3 id="10-Kafka启动流程"><a href="#10-Kafka启动流程" class="headerlink" title="10. Kafka启动流程"></a>10. Kafka启动流程</h3><h3 id="11-如何定义一个Partitioning-key"><a href="#11-如何定义一个Partitioning-key" class="headerlink" title="11. 如何定义一个Partitioning key?"></a>11. 如何定义一个Partitioning key?</h3><h3 id="12-生产者的队列什么时候会变满了？"><a href="#12-生产者的队列什么时候会变满了？" class="headerlink" title="12. 生产者的队列什么时候会变满了？"></a>12. 生产者的队列什么时候会变满了？</h3><h3 id="13-介绍下Kafka中Production的API"><a href="#13-介绍下Kafka中Production的API" class="headerlink" title="13. 介绍下Kafka中Production的API"></a>13. 介绍下Kafka中Production的API</h3><h3 id="14-介绍下Kafka中Consumer的API"><a href="#14-介绍下Kafka中Consumer的API" class="headerlink" title="14. 介绍下Kafka中Consumer的API"></a>14. 介绍下Kafka中Consumer的API</h3><h3 id="15-介绍下Kafka中Stream的API"><a href="#15-介绍下Kafka中Stream的API" class="headerlink" title="15. 介绍下Kafka中Stream的API"></a>15. 介绍下Kafka中Stream的API</h3><h3 id="16-介绍下Kafka中Connector的API"><a href="#16-介绍下Kafka中Connector的API" class="headerlink" title="16. 介绍下Kafka中Connector的API"></a>16. 介绍下Kafka中Connector的API</h3><h3 id="17-Kafka和Flume的区别"><a href="#17-Kafka和Flume的区别" class="headerlink" title="17. Kafka和Flume的区别"></a>17. Kafka和Flume的区别</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是Kalfka？&quot;&gt;&lt;a href=&quot;#1-什么是Kalfka？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Kalfka？&quot;&gt;&lt;/a&gt;1. 什么是Kalfka？&lt;/h3&gt;&lt;p&gt;由Scala和Java编写，开源流处理平台，高吞吐量的分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员国外面试流程（同事口述）</title>
    <link href="http://longman.kim/2018/07/06/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9B%BD%E5%A4%96%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B%EF%BC%88%E5%90%8C%E4%BA%8B%E5%8F%A3%E8%BF%B0%EF%BC%89/"/>
    <id>http://longman.kim/2018/07/06/程序员国外面试流程（同事口述）/</id>
    <published>2018-07-06T12:54:55.000Z</published>
    <updated>2018-07-06T13:06:06.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-面试准备"><a href="#1-面试准备" class="headerlink" title="1. 面试准备"></a>1. 面试准备</h3><ol><li><p>英语<br>口语，可以找网上一对一的私教</p></li><li><p>算法<br>ACM类型的算法题目，刷leetcode，打比赛</p></li><li><p>项目  </p></li></ol><ol start="4"><li><p>面向对象设计，设计模式<br>面向对象的思想，设计模式</p></li><li><p>架构<br>AWS的一些架构</p></li></ol><h3 id="2-面试流程"><a href="#2-面试流程" class="headerlink" title="2. 面试流程"></a>2. 面试流程</h3><ol><li>在线做题（一个小时左右网上完成一份试卷）  </li><li>三轮电面（2轮在线编程，1轮项目介绍）  </li><li>一天之内6轮现场面试（白板手写算法，面向对象设计，架构）</li></ol><h3 id="3-机会"><a href="#3-机会" class="headerlink" title="3. 机会"></a>3. 机会</h3><p>使用linkedin，吸引国外公司的HR，多加群</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-面试准备&quot;&gt;&lt;a href=&quot;#1-面试准备&quot; class=&quot;headerlink&quot; title=&quot;1. 面试准备&quot;&gt;&lt;/a&gt;1. 面试准备&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;英语&lt;br&gt;口语，可以找网上一对一的私教&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;算法&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180705</title>
    <link href="http://longman.kim/2018/07/04/%E5%89%A7%E6%9C%AC20180705/"/>
    <id>http://longman.kim/2018/07/04/剧本20180705/</id>
    <published>2018-07-04T14:11:05.000Z</published>
    <updated>2018-07-04T14:11:05.147Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大型网站系统与Java中间件实践</title>
    <link href="http://longman.kim/2018/07/03/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8EJava%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5/"/>
    <id>http://longman.kim/2018/07/03/大型网站系统与Java中间件实践/</id>
    <published>2018-07-03T15:06:54.000Z</published>
    <updated>2018-07-04T14:10:27.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式系统介绍"><a href="#1-分布式系统介绍" class="headerlink" title="1. 分布式系统介绍"></a>1. 分布式系统介绍</h3><p>1.1 分布式中的控制器</p><blockquote><p>请求调用的负载均衡（硬件F5，软件LVS），也称为透明代理，服务请求方和提供方直接多了层代理。名称服务，收集服务提供方的地址信息，把这些信息提供给服务调用方，负载均衡由服务调用方做。规则服务器，不和服务提供方交互，只向调用方提供调用服务的规则。Master+Worker的方式，任务的分配和管理。</p></blockquote><p>1.2 分布式的运算器</p><blockquote><p>DNS服务器进行调度和控制，将域名解析到不同的网站服务器；DNS返回负载均衡器的地址，负载均衡器将请求分发到不同的网站服务器；采用Master控制日志处理器集群的方式，或者规则服务器协调日志处理服务器的动作。</p></blockquote><p>1.3 分布式的存储器</p><blockquote><p>单个KV存储服务器；使用代理（根据K值进行划分）的多个KV存储服务器；采用名称服务的多个KV存储服务器，一种是规则服务器配合完成固定划分的策略，一种是对等看待多台KV存储服务器，灵活的适应KV存储服务器的增加和减少（一致性哈希）；规则服务器返回如何对数据进行划分，以及具体包含KV存储服务器的地址。Master对每个请求，直接返回一个KV服务器对应的地址。</p></blockquote><p>1.4 缺乏全局时钟，采用集群进行处理</p><p>1.5 面对故障独立性，一部分有问题其他部分能正常工作</p><p>1.6 单点故障</p><blockquote><p>最直接的是将功能从单机实现变为集群；一种方法是备份，自动恢复；一种是降低单点的影响范围，例如对数据库做划分</p></blockquote><p>1.7 分布式事务的挑战</p><blockquote><p>2PC, 3PC, BASE, CAP, PAXOS</p></blockquote><h3 id="2-大型网站及其架构演进过程"><a href="#2-大型网站及其架构演进过程" class="headerlink" title="2. 大型网站及其架构演进过程"></a>2. 大型网站及其架构演进过程</h3><p>2.1 大型网站：大访问量，海量数据</p><p>2.2 架构演进</p><blockquote><p>2.2.1 单机<br>2.2.2 数据库与应用分离<br>2.2.3 应用服务器走向集群</p><blockquote><p>2.2.3.1 引入负载均衡<br>2.2.3.2 session问题（session sticky即同一个用户的所有请求被负载均衡到同一台机器，session replication所有机器都保存所有的seesion涉及session同步，session集中存储，基于cookie） </p></blockquote></blockquote><blockquote><p>2.2.4 数据库读写分离</p><blockquote><p>2.2.4.1 数据复制需要考虑数据复制时延问题，MySQL支持Master和Slave模式，异步复制，半同步服务<br>2.2.4.2 如何选择数据源<br>2.2.4.3 搜索引擎是一个读库，索引集群构建方式，全量/增量，实时/非实时<br>2.2.4.4 数据缓存，页面缓存，缓存命中率，缓存的失效，更新  </p></blockquote></blockquote><blockquote><p>2.2.5 分布式存储系统</p><blockquote><p>分布式文件系统（大小文件的存储），分布式Key-Value系统（半结构数据支持），分布式数据库系统，提供高容量，高并发访问，数据冗余容灾的支持</p></blockquote></blockquote><blockquote><p>2.2.6 读写分离后，数据库又遇到瓶颈</p><blockquote><p>2.2.6.1 专库专用，垂直拆分，将不同的表分到不同的数据库。要处理单机跨业务的事务，可以采用分布式事务。<br>2.2.6.2 水平拆分，将同一个表的数据分到不同的数据库。要解决SQL路由的问题，以及分页。</p></blockquote></blockquote><blockquote><p>2.2.7 数据库问题解决后，应用面对的新挑战</p><blockquote><p>应用拆分的方式：根据业务特性<br>走服务化的路</p></blockquote></blockquote><blockquote><p>2.2.8 消息中间件</p><blockquote><p>在分布式系统中完成消息的发送和接受，实现异步和解耦 </p></blockquote></blockquote><h3 id="3-构建Java中间件"><a href="#3-构建Java中间件" class="headerlink" title="3. 构建Java中间件"></a>3. 构建Java中间件</h3><blockquote><p>3.1 JVM, 垃圾回收与内存堆布局，并发编程（线程池，同步，锁，线程通信，异步，并发容器）<br>3.2 动态代理<br>3.3 反射<br>3.4 Java中间件，消息中间件（MOM），服务框架（RPC），软负载中心，持久配置管理，分布式数据层，数据复制/迁移</p></blockquote><h3 id="4-服务框架"><a href="#4-服务框架" class="headerlink" title="4. 服务框架"></a>4. 服务框架</h3><blockquote><p>dubbo, grpc, thrift, motan, rmi, hessian, webservice<br>rmi, rpc, soap, rest  </p></blockquote><p>4.1 服务框架的设计与实现</p><blockquote><ol><li>服务框架需要解决的问题：接口调用-&gt;寻址路由-&gt;编码-&gt;通信-&gt;解码-&gt;实例定位-&gt;服务调用</li><li>远程服务的客户端调用：获取可用服务地址列表-&gt;确定要调用服务的目标机器-&gt;建立链接-&gt;请求序列化-&gt;发送请求-&gt;接收结果-&gt;解析结果  </li><li>服务调用端具体工作：调用发起-&gt;寻址路由-&gt;协议适配/序列化-&gt;网络传输-&gt;反序列化/协议解析-&gt;得到结果返回给调用方  </li><li>配置服务：interfaceName, version, group</li><li>服务调用者与服务提供者直连（服务注册查找中心），基于接口、方法、参数的路由，多机房场景</li><li>网络通信的实现BIO，NIO（IO线程，数据队列，通信对象队列，定时任务），AIO</li><li>多种异步调用方式：Oneway方式，Callback方式，Future方式</li><li>服务提供端具体工作：反序列化/协议解析-&gt;定位服务-&gt;执行方法生成方法-&gt;协议适配/序列化-&gt;网络传输  </li><li>不同服务的线程池隔离，0-1开关，QPS的流控处理，服务升级</li></ol></blockquote><p>4.2 实战中的优化</p><blockquote><p>服务的拆分，服务的粒度，服务缓存，分布式环境中的请求合并</p></blockquote><p>4.3 服务治理</p><blockquote><ol><li><p>管理服务</p><blockquote><ol><li>服务上下线  </li><li>服务路由</li><li>服务限流降级</li><li>服务归组</li><li>服务线程池管理</li><li>机房规则</li><li>服务授权 </li></ol></blockquote></li><li><p>查看服务</p><blockquote><ol><li>服务信息（服务编码）</li><li>服务质量（出错率、响应时间）</li><li>服务容量（能支持的请求量）</li><li>服务依赖（服务之前的依赖关系）</li><li>服务分布（跨机房的分布）</li><li>服务统计（调用次数，出错次数，出错率，响应时间的排名和趋势）</li><li>服务元数据（服务方法和参数）</li><li>服务查询（名称，负责人，发布时间，服务提供者地址列表，质量，容量，依赖，组，版本）</li><li>服务报表（非实时的统计报表）</li><li>服务监视（服务运行时数据的收集和处理）</li></ol></blockquote></li></ol></blockquote><h3 id="5-数据访问层"><a href="#5-数据访问层" class="headerlink" title="5. 数据访问层"></a>5. 数据访问层</h3><ol><li>分布式事务<blockquote><ol><li>2PC  </li></ol></blockquote></li><li>3PC  </li><li>PAXOS   </li><li><p>CAP, BASE </p></li><li><p>Join</p><blockquote><ol><li>把Join操作分成多次的数据库操作</li><li>通过信息冗余变成单表查询</li><li>外部系统（例如搜索引擎）解决</li></ol></blockquote></li><li><p>外键</p></li><li><p>自增序列</p><blockquote><ol><li>UUID的生成方式</li><li></li></ol></blockquote></li><li><p>查询跨库</p></li><li><p>确定执行SQL的目标库</p><blockquote><ol><li>固定哈希算法  </li><li>一致性哈希算法</li></ol></blockquote></li></ol><h3 id="6-消息中间件"><a href="#6-消息中间件" class="headerlink" title="6. 消息中间件"></a>6. 消息中间件</h3><h3 id="7-软负载中心与集中配置管理"><a href="#7-软负载中心与集中配置管理" class="headerlink" title="7. 软负载中心与集中配置管理"></a>7. 软负载中心与集中配置管理</h3><h3 id="8-构建大型网站的其他要素"><a href="#8-构建大型网站的其他要素" class="headerlink" title="8. 构建大型网站的其他要素"></a>8. 构建大型网站的其他要素</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-分布式系统介绍&quot;&gt;&lt;a href=&quot;#1-分布式系统介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式系统介绍&quot;&gt;&lt;/a&gt;1. 分布式系统介绍&lt;/h3&gt;&lt;p&gt;1.1 分布式中的控制器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请求调用的负载
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180703</title>
    <link href="http://longman.kim/2018/07/03/%E5%89%A7%E6%9C%AC20180703/"/>
    <id>http://longman.kim/2018/07/03/剧本20180703/</id>
    <published>2018-07-03T11:20:51.000Z</published>
    <updated>2018-07-04T11:40:16.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-如何体现技术能力？"><a href="#1-如何体现技术能力？" class="headerlink" title="1. 如何体现技术能力？"></a>1. 如何体现技术能力？</h3><blockquote><p>今天看了刘未鹏的文章《怎样花两年时间去面试一个人》，总的感触就是识别一个优秀技术候选人是非常困难的。在学校与教育严重脱节的情况下，技术人员的甄别可以通过以下方法：  </p><ol><li>学历  </li><li>读过的书  </li><li>博客  </li><li>github的提交频率，别人的点赞  </li><li>算法<br>学历方面我在国内已经读了硕士，如果要提升的话，我理解进步的空间应该是去国外的top大学读个博士。如果想往这方面发展，英语是个大关卡。在读的书方面，工作之后读书少了，而且也没有完全理解。因此，我得给自己列个书单。<br><strong>基础书单</strong><br>《深入理解计算机系统》<br>《代码大全》<br>《编程珠玑》/《编程之美》<br>《计算机程序的构造和解释》<br>《设计模式》<br>《重构》<br>《程序员修理之道》<br>《深入理解Linux内核》<br>《TCP/IP详解》<br>《鸟哥的Linux私房菜-基础学习篇》<br>《软件随想录》<br>《黑客与画家》<br>《重来》<br>《编程人生》<br>《UNIX编程艺术》<br>《算法导论》<br>《盛田昭夫》<br>《杰克韦尔奇自传》<br><strong>语言</strong><br>《Effective C++》<br>《深度探索C++对象模型》<br>《C专家编程》<br>《Lua程序设计》<br>《Java编程思想》<br>《深入理解Java虚拟机》<br>《Effective Java》<br>《Java并发编程实战》<br>《Java并发编程的艺术》<br>《Java性能优化权威指南》<br><strong>前端</strong><br>《JavaScript高级程序设计》<br>《JavaScript权威指南》<br>《锋利的jQuery》<br><strong>架构</strong><br>《大型网站系统与Java中间件实践》<br>《大型网站技术架构:核心原理与案例分析》<br>《大型分布式网站架构设计与实践》<br>《大规模分布式存储系统》<br>《深入分析Java Web技术内幕》<br>《Redis设计与实现》<br>《MySQL技术内幕 : InnoDB存储引擎》<br>《微服务设计》<br>《从Paxos到Zookeeper》<br>《Netty权威指南 第2版》<br>《Docker: 容器与容器云》<br>《Head First设计模式》<br>我的博客也开始启动了，虽然不知道能坚持多久，但我还是会努力写下去。一个人在社会中很容易迷茫，只有列出清晰的目标，才能一步一个脚印的向前走。github的确是个好东西，可以自己写些小项目练手。可以自己给自己定需求，画设计，前端开发，后台开发，数据库管理等等。项目的形式可以从小到大，然后分享问题。也可以提供一些基础组件（轮子），让别人使用，打造自己的名气。算法的话，国外很重视，国内未来也会跟着国外走。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-如何体现技术能力？&quot;&gt;&lt;a href=&quot;#1-如何体现技术能力？&quot; class=&quot;headerlink&quot; title=&quot;1. 如何体现技术能力？&quot;&gt;&lt;/a&gt;1. 如何体现技术能力？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;今天看了刘未鹏的文章《怎样花两年时间去
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本20180701</title>
    <link href="http://longman.kim/2018/07/01/%E5%89%A7%E6%9C%AC20180701/"/>
    <id>http://longman.kim/2018/07/01/剧本20180701/</id>
    <published>2018-07-01T15:12:57.000Z</published>
    <updated>2018-07-03T11:19:20.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Guava-Cache的原理与实现"><a href="#1-Guava-Cache的原理与实现" class="headerlink" title="1. Guava Cache的原理与实现"></a>1. Guava Cache的原理与实现</h3><blockquote><p>单机缓存，比较简单的方法是自己用ConcurrentHashMap去实现。Guava Cache实现了自动回收，如果自己采用ConcurrentHashMap需要手动显示回收。Guava Cache提供三种缓存回收方法：基于容量回收，定时回收和基于引用回收。</p></blockquote><h3 id="2-BCOS的架构，技术原理，启动流程"><a href="#2-BCOS的架构，技术原理，启动流程" class="headerlink" title="2. BCOS的架构，技术原理，启动流程"></a>2. BCOS的架构，技术原理，启动流程</h3><blockquote><p>联盟链，参与者（PKI, CA证书，记账者，观察者，白名单，黑名单），共识机制（PBFT, RAFT），多链和跨链，分布式存储leveldb。</p></blockquote><h3 id="3-分布式理论CAP-BASE"><a href="#3-分布式理论CAP-BASE" class="headerlink" title="3. 分布式理论CAP,BASE"></a>3. 分布式理论CAP,BASE</h3><blockquote><p>一致性（C），可用性（A），分区容错性（P），三者不能够被同时满足。BASE代表基本可用，软状态，最终一致性。</p></blockquote><h3 id="4-分布式一致性算法2PC-3PC-PAXOS-ZAB-RAFT-PAFT-RBFT"><a href="#4-分布式一致性算法2PC-3PC-PAXOS-ZAB-RAFT-PAFT-RBFT" class="headerlink" title="4. 分布式一致性算法2PC, 3PC, PAXOS, ZAB, RAFT, PAFT, RBFT"></a>4. 分布式一致性算法2PC, 3PC, PAXOS, ZAB, RAFT, PAFT, RBFT</h3><h3 id="5-挖矿算法POW-POS-DPOS-Leader-BFT"><a href="#5-挖矿算法POW-POS-DPOS-Leader-BFT" class="headerlink" title="5. 挖矿算法POW, POS, DPOS, Leader, BFT"></a>5. 挖矿算法POW, POS, DPOS, Leader, BFT</h3><h3 id="6-消息中间件及RocketMQ模块分解"><a href="#6-消息中间件及RocketMQ模块分解" class="headerlink" title="6. 消息中间件及RocketMQ模块分解"></a>6. 消息中间件及RocketMQ模块分解</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Guava-Cache的原理与实现&quot;&gt;&lt;a href=&quot;#1-Guava-Cache的原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. Guava Cache的原理与实现&quot;&gt;&lt;/a&gt;1. Guava Cache的原理与实现&lt;/h3&gt;&lt;bl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty</title>
    <link href="http://longman.kim/2018/07/01/netty/"/>
    <id>http://longman.kim/2018/07/01/netty/</id>
    <published>2018-07-01T09:08:31.000Z</published>
    <updated>2018-07-01T09:08:31.454Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://longman.kim/2018/07/01/Golang/"/>
    <id>http://longman.kim/2018/07/01/Golang/</id>
    <published>2018-07-01T08:51:02.000Z</published>
    <updated>2018-07-01T08:51:02.784Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://longman.kim/2018/07/01/Docker/"/>
    <id>http://longman.kim/2018/07/01/Docker/</id>
    <published>2018-07-01T08:50:44.000Z</published>
    <updated>2018-07-01T08:50:44.697Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BCOS</title>
    <link href="http://longman.kim/2018/07/01/BCOS/"/>
    <id>http://longman.kim/2018/07/01/BCOS/</id>
    <published>2018-07-01T08:50:23.000Z</published>
    <updated>2018-07-01T08:50:23.201Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>超级账本</title>
    <link href="http://longman.kim/2018/07/01/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/"/>
    <id>http://longman.kim/2018/07/01/超级账本/</id>
    <published>2018-07-01T08:50:09.000Z</published>
    <updated>2018-07-01T08:50:09.308Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>以太坊</title>
    <link href="http://longman.kim/2018/07/01/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    <id>http://longman.kim/2018/07/01/以太坊/</id>
    <published>2018-07-01T08:49:54.000Z</published>
    <updated>2018-07-01T08:49:54.152Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>比特币</title>
    <link href="http://longman.kim/2018/07/01/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://longman.kim/2018/07/01/比特币/</id>
    <published>2018-07-01T08:49:40.000Z</published>
    <updated>2018-07-01T08:49:40.763Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RPC框架Dubbo, Motan, SpringCloud</title>
    <link href="http://longman.kim/2018/07/01/RPC%E6%A1%86%E6%9E%B6Dubbo-Motan-SpringCloud/"/>
    <id>http://longman.kim/2018/07/01/RPC框架Dubbo-Motan-SpringCloud/</id>
    <published>2018-07-01T08:49:17.000Z</published>
    <updated>2018-07-01T08:49:17.814Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式协调服务zookeeper</title>
    <link href="http://longman.kim/2018/07/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper/"/>
    <id>http://longman.kim/2018/07/01/分布式协调服务zookeeper/</id>
    <published>2018-07-01T08:48:47.000Z</published>
    <updated>2018-07-01T08:48:47.113Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式消息订阅系统Kafka</title>
    <link href="http://longman.kim/2018/07/01/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9FKafka/"/>
    <id>http://longman.kim/2018/07/01/分布式消息订阅系统Kafka/</id>
    <published>2018-07-01T08:48:16.000Z</published>
    <updated>2018-07-01T08:48:16.595Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>加入开源项目nutz</title>
    <link href="http://longman.kim/2018/07/01/%E5%8A%A0%E5%85%A5%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEnutz/"/>
    <id>http://longman.kim/2018/07/01/加入开源项目nutz/</id>
    <published>2018-07-01T08:47:23.000Z</published>
    <updated>2018-07-01T08:47:23.519Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java之外的世界</title>
    <link href="http://longman.kim/2018/07/01/Java%E4%B9%8B%E5%A4%96%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://longman.kim/2018/07/01/Java之外的世界/</id>
    <published>2018-07-01T08:45:19.000Z</published>
    <updated>2018-07-01T09:12:53.138Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic"><a href="#1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic" class="headerlink" title="1. 消息中间件的两种模式：点对点的消息队列，发布/订阅的topic"></a>1. 消息中间件的两种模式：点对点的消息队列，发布/订阅的topic</h5><h5 id="2-消息中间件message消费失败怎么办？"><a href="#2-消息中间件message消费失败怎么办？" class="headerlink" title="2. 消息中间件message消费失败怎么办？"></a>2. 消息中间件message消费失败怎么办？</h5><h5 id="3-hbase与mysql的区别"><a href="#3-hbase与mysql的区别" class="headerlink" title="3. hbase与mysql的区别"></a>3. hbase与mysql的区别</h5><h5 id="4-mysql的事务隔离级别"><a href="#4-mysql的事务隔离级别" class="headerlink" title="4. mysql的事务隔离级别"></a>4. mysql的事务隔离级别</h5><h5 id="5-跨越多个数据库的事务"><a href="#5-跨越多个数据库的事务" class="headerlink" title="5. 跨越多个数据库的事务"></a>5. 跨越多个数据库的事务</h5><h5 id="6-如何保证数据一致性，缓存与DB的更新"><a href="#6-如何保证数据一致性，缓存与DB的更新" class="headerlink" title="6. 如何保证数据一致性，缓存与DB的更新"></a>6. 如何保证数据一致性，缓存与DB的更新</h5><h5 id="7-分布式发布订阅消息系统kafka"><a href="#7-分布式发布订阅消息系统kafka" class="headerlink" title="7. 分布式发布订阅消息系统kafka"></a>7. 分布式发布订阅消息系统kafka</h5><h5 id="8-分布式协调服务zookeeper"><a href="#8-分布式协调服务zookeeper" class="headerlink" title="8. 分布式协调服务zookeeper"></a>8. 分布式协调服务zookeeper</h5><h5 id="9-RPC框架dubbo-dubbox-motan-thrift-grpc-avro-SpringCloud"><a href="#9-RPC框架dubbo-dubbox-motan-thrift-grpc-avro-SpringCloud" class="headerlink" title="9. RPC框架dubbo, dubbox, motan, thrift, grpc, avro, SpringCloud"></a>9. RPC框架dubbo, dubbox, motan, thrift, grpc, avro, SpringCloud</h5><h5 id="10-消息中间件RabbitMQ-ActiveMQ-RocketMQ-Redis-Kafka-ZeroMQ"><a href="#10-消息中间件RabbitMQ-ActiveMQ-RocketMQ-Redis-Kafka-ZeroMQ" class="headerlink" title="10. 消息中间件RabbitMQ, ActiveMQ, RocketMQ, Redis, Kafka, ZeroMQ"></a>10. 消息中间件RabbitMQ, ActiveMQ, RocketMQ, Redis, Kafka, ZeroMQ</h5><h5 id="11-分布式常见问题"><a href="#11-分布式常见问题" class="headerlink" title="11. 分布式常见问题"></a>11. 分布式常见问题</h5><h5 id="12-如何做异常的监控"><a href="#12-如何做异常的监控" class="headerlink" title="12. 如何做异常的监控"></a>12. 如何做异常的监控</h5><h5 id="13-go语言的协程与c-和python的对比"><a href="#13-go语言的协程与c-和python的对比" class="headerlink" title="13. go语言的协程与c++和python的对比"></a>13. go语言的协程与c++和python的对比</h5><h5 id="14-区块链技术的介绍"><a href="#14-区块链技术的介绍" class="headerlink" title="14. 区块链技术的介绍"></a>14. 区块链技术的介绍</h5><h5 id="15-过去一年最自豪的一件事情"><a href="#15-过去一年最自豪的一件事情" class="headerlink" title="15. 过去一年最自豪的一件事情"></a>15. 过去一年最自豪的一件事情</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic&quot;&gt;&lt;a href=&quot;#1-消息中间件的两种模式：点对点的消息队列，发布-订阅的topic&quot; class=&quot;headerlink&quot; title=&quot;1. 消息中间件的两种模式：点对点的消息队列，发布/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剧本1</title>
    <link href="http://longman.kim/2018/06/30/%E5%89%A7%E6%9C%AC1/"/>
    <id>http://longman.kim/2018/06/30/剧本1/</id>
    <published>2018-06-30T13:33:08.000Z</published>
    <updated>2018-07-01T04:02:58.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-人生如戏"><a href="#1-人生如戏" class="headerlink" title="1. 人生如戏"></a>1. 人生如戏</h3><p>&emsp;&emsp;有人说一生很长，有人说一生很短，但长短真的那么重要吗？人终究会死，死了就什么也没有了。没有烦恼，没有快乐。衡量人生的长短是没有任何意义的，有人活着他已经死了，有人死了他还活着。关键是人的价值，在历史中的价值，那才是人应该去追求的真谛。让我们静下心想想应该怎么过完自己的一生，是庸庸碌碌，还是人生如戏。没有梦想，人和咸鱼有什么区别？但现实情况是，我们大多数人就是咸鱼。我们的梦想是赚钱，赚很多的钱，让自己买得起车买得起房。然后呢，我们没有然后。钱，成为了生存下来的唯一目标。天下熙熙皆为利来，天下攘攘皆为利往。我们有问过自己，到底自己想要什么吗？没有，时间推着我们走，走到哪里算哪里。人生本不该如此，人生如戏，我们要做自己的主宰，做设计人生的导演，做表演人生的演员。这是一场戏，没有NG，所有的镜头必须一次过。这场戏中，我们无法自欺欺人，唯有亲身示范。</p><h3 id="2-优秀的导演"><a href="#2-优秀的导演" class="headerlink" title="2. 优秀的导演"></a>2. 优秀的导演</h3><p>&emsp;&emsp;每一个人生都有自己的主题，有的是喜剧，有的是悲剧，有的是无厘头。里面的主角也各不相同，他们在各自的圈子里演绎自己的人生。在这出戏里，一个关键的人物就是导演。他要构思剧本，调整灯光，整理道具，搭建舞台。他是这出戏的总设计师，是这出戏唯一的领班人。没有其他人可以，但不能没有导演。那作为一个导演应该怎么做呢？每一出戏，导完了，导演的作用也就消失了。戏只有一部，成败在此一举。所以，导演要给自己的戏定性。剧情究竟是一波三折呢，还是全局开挂？什么时候能看到戏的高潮？戏里的每一分每一秒，导演都需要精雕细琢，容不得半点放水。导演的职责是什么呢？设计好台词，把灯光调的切合剧情氛围一些，让舞台变得更大，清除外界的干扰。<br>&emsp;&emsp;如果我是导演，我该怎么设计好人生的这场大戏呢？一个出生贫苦的乡下孩子，在少年时代享受了成绩优秀带来的快感。当他的圈子慢慢变大后，他的优秀变得不那么明显。不过在小圈子内，他还是可以自我陶醉，因为他的部分优秀。在他进入大学后，他的人生没有明确的目标，但他延续了之前的部分努力，所以在糊里糊涂中读了研究生。大学4年，研究生3年，在这7年的时间里，他始终认为自己像小学时候一样优秀。直到他在名企实习，但却没有被最终留用后，他发现了自己的落后。他想改，可以蹉跎的7年，懒惰的惯性让我总是无法走出困境。工作两年，当领导在他的评语上留下了不能胜任工作的时候，他开始恐慌。他突然发现，自己真的落后了，并且他已经30岁了，然而还是无法一技压身。他开始痛苦，开始彷徨，开始自我怀疑，以为自己的人生就这样完了。<br>&emsp;&emsp;然而，生活的挫折并没有将他打到。他改变了自己，给自己设定了明确的目标。从外在的发型，眼镜，着装，走路的姿势，说话的语气，面部的表情，待人的真诚，到内在的价值观，人生观，知识面等等。他喜欢公开表达自己对时事的观点，对政策的目的进行了分析，喜欢和别人进行深入的沟通，待人接物更加礼貌更加友善。他每天笑脸迎人，充满阳光与活力，身上散发着睿智的气息。他深知人性，能化尴尬为幽默，让他人在与他相处时，开心快乐。他精通数学与英语，能够快速心算。同时，对高等数学十分热爱，喜欢抽象生活中的小细节。他能讲一口流利的英语，在和外国人的交流时能够侃侃而谈，自然亲切。他拥有深厚的专业知识，对自己领域的每个小细节都清清楚楚。对所有的专业知识，都烂熟于心。在不断的实践过程中，他努力总结，总能做到举一反三，触类旁通。对国内外最新的专业动态，他都时刻关注，并尽早使用。同时，他在不断构建自己的技术壁垒。从参与新事物，到自己能够创造新事物。在这个自我不断改变的过程中，他收获了金钱，职称。他的心态有了明显的变化，自己在社会上有一定的地位了，生活有了保障了。但他总感觉缺少什么似的，他发现自己努力的结果，最终还是让自己过上富足的生活。而他的初衷是让自己在历史的长河中流芳千古呀，当发现自己无力改变这个现实时，他突然变得沮丧。他突然对天发问，这一切究竟是否是他想要的。时间还是不停流转，慢慢他发现人是渺小的，是否伟大也没有那么有意义。人都死了，被后人称赞伟大又有什么用呢？难道在九泉之下，就会因为后人的歌颂而复活吗？人生没有那么复杂，只是人把它想复杂了。简简单单，做自己喜欢做的事情，然后做到专业。开开心心，幸福快乐的活着。</p><h3 id="3-优秀的演员"><a href="#3-优秀的演员" class="headerlink" title="3. 优秀的演员"></a>3. 优秀的演员</h3><p>&emsp;&emsp;优秀的演员是可以练出来的，伟大的演员依靠天赋。只有十年如一日的练习，才能做到剧本台词烂熟于心，表情动作轻车熟路。有了导演的指导，演员只需要不断的修行自己。在导演构建的大框架之下，运用自己的才能在细微之处做创新。具体如何实施呢，让自己回到高三时代。拥有明确的目标，规律的作息，合理的运动，持之以恒的学习。作为一个执行者，没有捷径可走，唯一的路就是持之以恒，不断学习。</p><h3 id="4-精彩的人生"><a href="#4-精彩的人生" class="headerlink" title="4. 精彩的人生"></a>4. 精彩的人生</h3><p>&emsp;&emsp;精彩的人生应该是什么样子的，是争斗的快乐，与人争斗的快乐。是智慧的博弈，是肉体的厮杀。是对弱者的碾压，是对强者的崇拜。人性的完全释放，不在压抑，让自己的情绪改变世界。成为世界的主宰，掌握生命的权利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-人生如戏&quot;&gt;&lt;a href=&quot;#1-人生如戏&quot; class=&quot;headerlink&quot; title=&quot;1. 人生如戏&quot;&gt;&lt;/a&gt;1. 人生如戏&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有人说一生很长，有人说一生很短，但长短真的那么重要吗？人终究会死，死了就什么也没
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java基础知识点</title>
    <link href="http://longman.kim/2018/06/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://longman.kim/2018/06/28/Java基础知识点/</id>
    <published>2018-06-27T17:02:04.000Z</published>
    <updated>2018-06-30T02:53:27.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h3><h5 id="1-ThreadPoolExecutor线程池"><a href="#1-ThreadPoolExecutor线程池" class="headerlink" title="1. ThreadPoolExecutor线程池"></a>1. ThreadPoolExecutor线程池</h5><h5 id="2-HashTable-TreeMap-LinkedHashMap-HashMap-HashSet-ArraryList-CurrentHashMap"><a href="#2-HashTable-TreeMap-LinkedHashMap-HashMap-HashSet-ArraryList-CurrentHashMap" class="headerlink" title="2. HashTable, TreeMap, LinkedHashMap, HashMap, HashSet, ArraryList, CurrentHashMap"></a>2. HashTable, TreeMap, LinkedHashMap, HashMap, HashSet, ArraryList, CurrentHashMap</h5><blockquote><p>HashTable不支持null键和null值，HashMap支持<br>HashTable和HashMap都是用哈希表，采用链地址法解决冲突<br>HashTable容量扩充时2n+1,为奇数使得数据分布均匀。HashMap容量扩充时2的幂次方，采用位运算，效率高，但增加了哈希冲突。为了减少哈希冲突，在计算hashcode时，HashMap做了位运算打散数据。在JDK8中，如果链表的长度大于8，将采用红黑树来存储。<br>HashTable是线程安全的，HashMap是线程不安全的，CurrentHashMap是线程安全的，HashTable已经被淘汰了<br>ConcurrentHashMap常用于缓存，在读操作多于写操作时，更加合适<br>HashMap在并发编程中会造成链中出现环，导致死循环。HashTable用的syncronized是互斥锁，效率下降很严重。ConcurrentHashMap采用分段锁技术，不同段争抢不同的锁，充分利用volatile的可见性，get不需要锁，put需要锁。<br>LinkedHashMap是有序的，它保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时带参数，按照应用次数排序。场景，输出的顺序与输入的顺序相同。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序。默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。场景，按自然顺序或者自定义顺序遍历。<br>HashSet是Set的一个实现类，以对象作为元素，不允许相同的元素。<br>ArraryList和Vector都是通过数组实现，但Vector支持线程同步，LinkedList是通过链表实现  </p></blockquote><h5 id="3-String-StringBuilder-StringBuffer"><a href="#3-String-StringBuilder-StringBuffer" class="headerlink" title="3. String, StringBuilder, StringBuffer"></a>3. String, StringBuilder, StringBuffer</h5><blockquote><p>String类是final类，final类是不能被继承的，而且final类中的方法都是final的。String中用char数组保存字符串，String一旦被创建就是固定不变的了，任何对String的修改都将生成新的String对象。<br>静态常量池是指.class中保存的字面量，运行时常量池保存在方法区中。String a = “ok”;String b = “ok”; String c = new String(“ok”), 在这里a,b执行方法区常量池中的对象，而c指向堆中的对象，只要是new出来的，在堆中就会有一份对象，所以a = b != c。再举个例子String a = “helloworld”; String b = “helloworld”; String c = “hello” + “world”. 在这里a = b = c, 因为当一个字符串是由多个字符串常量连接而成时，它本身也是字符串常量。字面量”+”拼接在编译期间进行，拼接后的字符串放在常量池中，而字符串引用的”+”拼接在运行时创建，新创建的字符串放在堆中。<br>intern方法的使用，对于任意两个字符串s和t, 当且仅当s.equals(t)为true时，s.intern()==t.intern()才为true.当一个String实例调用intern方法时，java会在常量池中找是否有相同的字符串常量，如果有，则返回其引用。如果没有，就在常量池中创建一个，然后返回其引用。<br>==用于基本数据类型的比较，equals用于对象的比较。如果equals没有重写，比较是引用。如果equals重写了，比较的是内容。String, Double, Date, Integer都进行了重写，比较的是内容。<br>运行速度方面StringBuilder>StringBuffer>String，因为添加字符串String涉及重新分配内存及回收内存。StringBuffer是线程安全的，在操作上加了syncronized, StringBuilder不是线程安全的。<br>String适用于少量的字符串操作，StringBuilder适用于单线程下在字符缓冲区进行大量的操作，StringBuffer适用于多线程下在字符缓冲区进行大量操作。  </p></blockquote><h5 id="4-ThreadLocal"><a href="#4-ThreadLocal" class="headerlink" title="4. ThreadLocal"></a>4. ThreadLocal</h5><blockquote><p>ThreadLocal为每个线程创建变量的副本，方式是每个线程内部有一个ThreadLocal.ThreadLocalMap。使用的应用场景数据库连接，Session管理。</p></blockquote><h5 id="5-CopyOnWrite机制，线程安全，CopyOnWriteArrayList-CopyOnWriteArrarySet"><a href="#5-CopyOnWrite机制，线程安全，CopyOnWriteArrayList-CopyOnWriteArrarySet" class="headerlink" title="5. CopyOnWrite机制，线程安全，CopyOnWriteArrayList, CopyOnWriteArrarySet"></a>5. CopyOnWrite机制，线程安全，CopyOnWriteArrayList, CopyOnWriteArrarySet</h5><blockquote><p>写时复制技术，每个修改之前都加ReentrantLock使并发写互斥。读写分离，读写可能不一致，不保证实时一致性，保证最终一致性。</p></blockquote><h5 id="6-volatile-syncronized-偏向锁，自旋锁，ReentrantLock-Condition-CountDownLatch-CycliBarrier-Semaphore-ReentrantReadAndWriteLock-Timer-乐观锁，悲观锁，可重入锁"><a href="#6-volatile-syncronized-偏向锁，自旋锁，ReentrantLock-Condition-CountDownLatch-CycliBarrier-Semaphore-ReentrantReadAndWriteLock-Timer-乐观锁，悲观锁，可重入锁" class="headerlink" title="6. volatile, syncronized, 偏向锁，自旋锁，ReentrantLock, Condition, CountDownLatch, CycliBarrier, Semaphore, ReentrantReadAndWriteLock, Timer, 乐观锁，悲观锁，可重入锁"></a>6. volatile, syncronized, 偏向锁，自旋锁，ReentrantLock, Condition, CountDownLatch, CycliBarrier, Semaphore, ReentrantReadAndWriteLock, Timer, 乐观锁，悲观锁，可重入锁</h5><blockquote><ol><li>自旋锁，正常情况下，如果线程没有抢到锁，它的线程状态会变成阻塞。如果使用自旋锁，则线程不阻塞，它会一种循环等待（在另外一个核上，所以需要多核处理器）锁被其他线程释放，被称为忙等。自旋锁比较适合竞争不激烈的情况，缺点是浪费CPU资源。<strong><em>自适应自旋锁</em></strong>是指自旋等待的时间不固定，它会偏向给之前获得过该锁的线程更多的自旋等待时间。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SpinLock &#123;  </span><br><span class="line">private AutomicReference&lt;Thread&gt; sign = new AutomicReference&lt;&gt;();</span><br><span class="line">public void lock() &#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line">while (!sign.compareAndSet(null, current))&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line">sign.compareAndSet(current, null);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>重入锁  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Reentrant &#123;</span><br><span class="line">public syncronized void outer() &#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;</span><br><span class="line">public syncronized void inner() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>偏向锁，它会偏向第一个访问锁的线程。运行过程中，如果同步锁只有一个线程访问，不存在多线程争用的情况，则会给该线程一个偏向锁。如果遇到其他线程抢占锁，则偏向锁被挂起，锁被恢复为标准的轻量锁。适合只有一个线程访问同步块的场景。  </li><li>乐观锁，乐观的思想，认为读多写少。更新的时候判断下是否被别人更新过，过程是读-&gt;比较-&gt;写，一般采用版本号的方法。java中乐观锁的实现是通过CAS。  </li><li>悲观锁，认为写多，每次读写都会上锁，其他线程想读写数据会被阻塞。java中的悲观锁就是Syncronize，在使用AQS框架下的锁时，会先尝试使用CAS乐观锁去获取锁，获取不到，才会转换为悲观锁，例如ReentrantLock就是这种策略。  </li><li>重量级锁syncronized，追求吞吐量，适合同步块执行时间长的场景。  </li><li>轻量级锁</li></ol></blockquote><h5 id="7-Java的并发包current中的AQS-CAS-ArrayBlockingQueue-LinkedBlockingQueue-Unsafe-Locksupport"><a href="#7-Java的并发包current中的AQS-CAS-ArrayBlockingQueue-LinkedBlockingQueue-Unsafe-Locksupport" class="headerlink" title="7. Java的并发包current中的AQS, CAS, ArrayBlockingQueue, LinkedBlockingQueue, Unsafe, Locksupport"></a>7. Java的并发包current中的AQS, CAS, ArrayBlockingQueue, LinkedBlockingQueue, Unsafe, Locksupport</h5><blockquote><p>下面四种锁都是通过AQS实现  </p><ol><li>ReentrantLock，记录当前线程获得原子状态的次数，大于0获得了重进入的效果，其他线程被park，等于0代表释放了原子状态。ReentrantLock是可重入的。  </li><li>Semaphore记录当前还有多少次许可可以使用，为0时就需要等待了，实现了并发量的控制。  </li><li>CountDownLatch闭锁要保持其状态，在这个状态达到终止态之前，所有线程park，闭锁设置初始值，这个值就是闭锁需要被countDown()的次数。只有初始值变为0时，等待的所有线程才通过。  </li><li>FutureTask  </li></ol></blockquote><h5 id="8-线程生命周期，wait-sleep"><a href="#8-线程生命周期，wait-sleep" class="headerlink" title="8. 线程生命周期，wait(), sleep()"></a>8. 线程生命周期，wait(), sleep()</h5><h5 id="9-Java-IO-Java-NIO-NIO的底层实现-Selector-Channel-ByteBuffer"><a href="#9-Java-IO-Java-NIO-NIO的底层实现-Selector-Channel-ByteBuffer" class="headerlink" title="9. Java IO, Java NIO, NIO的底层实现, Selector, Channel, ByteBuffer"></a>9. Java IO, Java NIO, NIO的底层实现, Selector, Channel, ByteBuffer</h5><h5 id="10-Java代理Proxy-CLIB代理，ASM"><a href="#10-Java代理Proxy-CLIB代理，ASM" class="headerlink" title="10. Java代理Proxy, CLIB代理，ASM"></a>10. Java代理Proxy, CLIB代理，ASM</h5><h5 id="11-反射的作用与原理"><a href="#11-反射的作用与原理" class="headerlink" title="11. 反射的作用与原理"></a>11. 反射的作用与原理</h5><blockquote><p>Java在运行时能够动态获取类的信息并调用类的方法称为Java的反射，它的原理主要是通过分析.class文件中的字节码，得到类，类的属性和方法。使用反射主要借助下面四个类：Class, Constructor, Field, Method</p></blockquote><h5 id="12-Java异常的层次结构"><a href="#12-Java异常的层次结构" class="headerlink" title="12. Java异常的层次结构"></a>12. Java异常的层次结构</h5><h5 id="13-类的加载机制，可能出现的问题"><a href="#13-类的加载机制，可能出现的问题" class="headerlink" title="13. 类的加载机制，可能出现的问题"></a>13. 类的加载机制，可能出现的问题</h5><blockquote><ol><li>Bootstrap Classloader由C++写类加载器，它加载java核心类库以及bootclasspath指定路径下的jar包，主要是以java, javax, sun开头的类。Extension Classloader用来加载扩展类，主要是ext及ext.dirs指定路径下的jar包。Application Classloader是标准的系统加载类，它加载classpath指定路径下的jar包，也是系统默认的类加载器。  </li><li>双亲委派机制，当一个类加载器收到加载请求时，它首先会让父类去加载（父类会将请求传递到它自己的父类，直到Bootstrap Classloader），直到父类不能加载时，它才去尝试加载。好处是具备了一种带优先级的的层次关系，保证java程序的稳定运行。  </li><li>类加载器加载类的顺序：检查该类是否已经被加载了，如果没有被加载，首先调用父类加载器，如果父类加载器不能加载这个类，则尝试加载这个类  </li><li>类加载过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</li></ol></blockquote><h5 id="14-序列化与反序列化"><a href="#14-序列化与反序列化" class="headerlink" title="14. 序列化与反序列化"></a>14. 序列化与反序列化</h5><h5 id="15-hashcode-equals"><a href="#15-hashcode-equals" class="headerlink" title="15. hashcode, equals"></a>15. hashcode, equals</h5><h5 id="16-Java强引用，软引用，弱引用，虚引用"><a href="#16-Java强引用，软引用，弱引用，虚引用" class="headerlink" title="16. Java强引用，软引用，弱引用，虚引用"></a>16. Java强引用，软引用，弱引用，虚引用</h5><h5 id="17-Java垃圾回收，可达性分析，标记清除-整理，复制，分代收集，Serial-Parallel-CMS-G1"><a href="#17-Java垃圾回收，可达性分析，标记清除-整理，复制，分代收集，Serial-Parallel-CMS-G1" class="headerlink" title="17. Java垃圾回收，可达性分析，标记清除/整理，复制，分代收集，Serial, Parallel, CMS, G1"></a>17. Java垃圾回收，可达性分析，标记清除/整理，复制，分代收集，Serial, Parallel, CMS, G1</h5><h5 id="18-Callable-CompletableFuture-Future-FutureTask"><a href="#18-Callable-CompletableFuture-Future-FutureTask" class="headerlink" title="18. Callable, CompletableFuture, Future, FutureTask"></a>18. Callable, CompletableFuture, Future, FutureTask</h5><h5 id="19-分布式锁的实现"><a href="#19-分布式锁的实现" class="headerlink" title="19. 分布式锁的实现"></a>19. 分布式锁的实现</h5><h5 id="20-限流，降级"><a href="#20-限流，降级" class="headerlink" title="20. 限流，降级"></a>20. 限流，降级</h5><h5 id="21-负载均衡-全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy-Nginx"><a href="#21-负载均衡-全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy-Nginx" class="headerlink" title="21. 负载均衡(全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy/Nginx)"></a>21. 负载均衡(全局域名解析，局部域名解析，4层负载LVS，7层负载均衡HAProxy/Nginx)</h5><h5 id="22-Spring-SpringMVC-SpringBoot原理与流程，IOC-AOP"><a href="#22-Spring-SpringMVC-SpringBoot原理与流程，IOC-AOP" class="headerlink" title="22. Spring, SpringMVC, SpringBoot原理与流程，IOC, AOP"></a>22. Spring, SpringMVC, SpringBoot原理与流程，IOC, AOP</h5><h5 id="23-netty-rocketmq"><a href="#23-netty-rocketmq" class="headerlink" title="23. netty, rocketmq"></a>23. netty, rocketmq</h5><h5 id="24-秒杀系统的设计，微信红包的社交，海量数据的分析"><a href="#24-秒杀系统的设计，微信红包的社交，海量数据的分析" class="headerlink" title="24. 秒杀系统的设计，微信红包的社交，海量数据的分析"></a>24. 秒杀系统的设计，微信红包的社交，海量数据的分析</h5><h5 id="25-redis-mysql，事务，索引，2PC-3PC，ACID，一致性哈希"><a href="#25-redis-mysql，事务，索引，2PC-3PC，ACID，一致性哈希" class="headerlink" title="25. redis, mysql，事务，索引，2PC/3PC，ACID，一致性哈希"></a>25. redis, mysql，事务，索引，2PC/3PC，ACID，一致性哈希</h5><h5 id="26-TCP三次握手四次挥手，滑动窗口"><a href="#26-TCP三次握手四次挥手，滑动窗口" class="headerlink" title="26. TCP三次握手四次挥手，滑动窗口"></a>26. TCP三次握手四次挥手，滑动窗口</h5><h5 id="27-linux命令grep-awk-sed-top-jstat-jstack-free-jmap"><a href="#27-linux命令grep-awk-sed-top-jstat-jstack-free-jmap" class="headerlink" title="27. linux命令grep, awk, sed, top, jstat, jstack, free, jmap"></a>27. linux命令grep, awk, sed, top, jstat, jstack, free, jmap</h5><h5 id="28-常用设计模式"><a href="#28-常用设计模式" class="headerlink" title="28. 常用设计模式"></a>28. 常用设计模式</h5><h5 id="29-Servlet与容器，Servlet生命周期，JSP"><a href="#29-Servlet与容器，Servlet生命周期，JSP" class="headerlink" title="29. Servlet与容器，Servlet生命周期，JSP"></a>29. Servlet与容器，Servlet生命周期，JSP</h5><h5 id="30-通用算法"><a href="#30-通用算法" class="headerlink" title="30. 通用算法"></a>30. 通用算法</h5><h5 id="31-C-对象模型，虚函数表"><a href="#31-C-对象模型，虚函数表" class="headerlink" title="31. C++对象模型，虚函数表"></a>31. C++对象模型，虚函数表</h5><h5 id="32-SimpleDateFormat线程不安全"><a href="#32-SimpleDateFormat线程不安全" class="headerlink" title="32. SimpleDateFormat线程不安全"></a>32. SimpleDateFormat线程不安全</h5><blockquote><p>当多个线程共享一个SimpleDateFormat对象时，由于SimpleDateFormat执行format, parse操作时，是使用自己的成员变量Calendar，也就意味着多个线程共享该Calendar。这个Calendar的初始化是由调用方决定的，A线程设置Calendar为1990, 在A执行parse或者format之前，B线程设置Calendar为2018，这时A再执行parse或者format会报错。</p></blockquote><h5 id="33-如何权衡可用性和一致性"><a href="#33-如何权衡可用性和一致性" class="headerlink" title="33. 如何权衡可用性和一致性"></a>33. 如何权衡可用性和一致性</h5><h5 id="34-C-中的模板和Java中泛型有何异同？"><a href="#34-C-中的模板和Java中泛型有何异同？" class="headerlink" title="34. C++中的模板和Java中泛型有何异同？"></a>34. C++中的模板和Java中泛型有何异同？</h5><h5 id="35-Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？"><a href="#35-Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？" class="headerlink" title="35. Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？"></a>35. Java的泛型如何在运行时识别类型，多态中如何区分父类和子类？</h5><h5 id="36-SpringBoot原理机制和启动流程"><a href="#36-SpringBoot原理机制和启动流程" class="headerlink" title="36. SpringBoot原理机制和启动流程"></a>36. SpringBoot原理机制和启动流程</h5><h5 id="37-Java中的阻塞队列"><a href="#37-Java中的阻塞队列" class="headerlink" title="37. Java中的阻塞队列"></a>37. Java中的阻塞队列</h5><blockquote></blockquote><h5 id="38-select-poll-epool"><a href="#38-select-poll-epool" class="headerlink" title="38. select, poll, epool"></a>38. select, poll, epool</h5><blockquote><p>都是同步非阻塞的IO多路复用方式，都会在select操作上阻塞。select/poll会顺序扫描fd是否就绪，而且支持的fd数量有限。epool基于事件驱动的方式，不是采用顺序扫描，当fd就绪时，立即回调函数rollback。</p></blockquote><h5 id="39-BeanFactory和FactoryBean"><a href="#39-BeanFactory和FactoryBean" class="headerlink" title="39. BeanFactory和FactoryBean"></a>39. BeanFactory和FactoryBean</h5><blockquote><p>BeanFactory是一个Bean工厂，作用就是配置，新建，管理各种Bean。FactoryBean是一个Bean，类型是工厂Bean，用来管理Bean，它本身由Spring管理。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java基础知识点&quot;&gt;&lt;a href=&quot;#Java基础知识点&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识点&quot;&gt;&lt;/a&gt;Java基础知识点&lt;/h3&gt;&lt;h5 id=&quot;1-ThreadPoolExecutor线程池&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式锁的三种实现方式</title>
    <link href="http://longman.kim/2018/06/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://longman.kim/2018/06/19/分布式锁的三种实现方式/</id>
    <published>2018-06-19T14:07:51.000Z</published>
    <updated>2018-06-19T14:07:51.993Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>全局唯一序列号的生成方法</title>
    <link href="http://longman.kim/2018/06/19/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/"/>
    <id>http://longman.kim/2018/06/19/全局唯一序列号的生成方法/</id>
    <published>2018-06-19T14:07:32.000Z</published>
    <updated>2018-06-19T14:07:32.416Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的异常处理</title>
    <link href="http://longman.kim/2018/06/19/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://longman.kim/2018/06/19/Java的异常处理/</id>
    <published>2018-06-19T14:05:26.000Z</published>
    <updated>2018-06-19T14:05:26.685Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
